
HummingBit.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003508  00000800  00000800  00000800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000074  20000000  00003d08  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e4  20000074  00003d7c  00010074  2**2
                  ALLOC
  3 .stack        00000400  20000358  00004060  00010074  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00010074  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0001009c  2**0
                  CONTENTS, READONLY
  6 .debug_info   00053093  00000000  00000000  000100f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000682b  00000000  00000000  00063188  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000a13d  00000000  00000000  000699b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000890  00000000  00000000  00073af0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000d40  00000000  00000000  00074380  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001b189  00000000  00000000  000750c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00017408  00000000  00000000  00090249  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00073478  00000000  00000000  000a7651  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000014ec  00000000  00000000  0011aacc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000800 <exception_table>:
     800:	58 07 00 20 6d 35 00 00 69 35 00 00 69 35 00 00     X.. m5..i5..i5..
	...
     82c:	69 35 00 00 00 00 00 00 00 00 00 00 69 35 00 00     i5..........i5..
     83c:	69 35 00 00 69 35 00 00 69 35 00 00 69 35 00 00     i5..i5..i5..i5..
     84c:	69 35 00 00 f1 2b 00 00 69 35 00 00 69 35 00 00     i5...+..i5..i5..
     85c:	00 00 00 00 69 35 00 00 c1 2b 00 00 d1 2b 00 00     ....i5...+...+..
     86c:	e1 2b 00 00 51 25 00 00 41 2b 00 00 51 2b 00 00     .+..Q%..A+..Q+..
     87c:	4d 16 00 00 69 35 00 00 69 35 00 00 69 35 00 00     M...i5..i5..i5..

0000088c <__do_global_dtors_aux>:
     88c:	b510      	push	{r4, lr}
     88e:	4c06      	ldr	r4, [pc, #24]	; (8a8 <__do_global_dtors_aux+0x1c>)
     890:	7823      	ldrb	r3, [r4, #0]
     892:	2b00      	cmp	r3, #0
     894:	d107      	bne.n	8a6 <__do_global_dtors_aux+0x1a>
     896:	4b05      	ldr	r3, [pc, #20]	; (8ac <__do_global_dtors_aux+0x20>)
     898:	2b00      	cmp	r3, #0
     89a:	d002      	beq.n	8a2 <__do_global_dtors_aux+0x16>
     89c:	4804      	ldr	r0, [pc, #16]	; (8b0 <__do_global_dtors_aux+0x24>)
     89e:	e000      	b.n	8a2 <__do_global_dtors_aux+0x16>
     8a0:	bf00      	nop
     8a2:	2301      	movs	r3, #1
     8a4:	7023      	strb	r3, [r4, #0]
     8a6:	bd10      	pop	{r4, pc}
     8a8:	20000074 	.word	0x20000074
     8ac:	00000000 	.word	0x00000000
     8b0:	00003d08 	.word	0x00003d08

000008b4 <frame_dummy>:
     8b4:	4b08      	ldr	r3, [pc, #32]	; (8d8 <frame_dummy+0x24>)
     8b6:	b510      	push	{r4, lr}
     8b8:	2b00      	cmp	r3, #0
     8ba:	d003      	beq.n	8c4 <frame_dummy+0x10>
     8bc:	4907      	ldr	r1, [pc, #28]	; (8dc <frame_dummy+0x28>)
     8be:	4808      	ldr	r0, [pc, #32]	; (8e0 <frame_dummy+0x2c>)
     8c0:	e000      	b.n	8c4 <frame_dummy+0x10>
     8c2:	bf00      	nop
     8c4:	4807      	ldr	r0, [pc, #28]	; (8e4 <frame_dummy+0x30>)
     8c6:	6803      	ldr	r3, [r0, #0]
     8c8:	2b00      	cmp	r3, #0
     8ca:	d100      	bne.n	8ce <frame_dummy+0x1a>
     8cc:	bd10      	pop	{r4, pc}
     8ce:	4b06      	ldr	r3, [pc, #24]	; (8e8 <frame_dummy+0x34>)
     8d0:	2b00      	cmp	r3, #0
     8d2:	d0fb      	beq.n	8cc <frame_dummy+0x18>
     8d4:	4798      	blx	r3
     8d6:	e7f9      	b.n	8cc <frame_dummy+0x18>
     8d8:	00000000 	.word	0x00000000
     8dc:	20000078 	.word	0x20000078
     8e0:	00003d08 	.word	0x00003d08
     8e4:	00003d08 	.word	0x00003d08
     8e8:	00000000 	.word	0x00000000

000008ec <spi_reset>:
 *
 * \param[in,out] module Pointer to the software instance struct
 */
void spi_reset(
		struct spi_module *const module)
{
     8ec:	b570      	push	{r4, r5, r6, lr}
     8ee:	0005      	movs	r5, r0
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     8f0:	6804      	ldr	r4, [r0, #0]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
     8f2:	0020      	movs	r0, r4
     8f4:	4b0e      	ldr	r3, [pc, #56]	; (930 <spi_reset+0x44>)
     8f6:	4798      	blx	r3
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
     8f8:	231f      	movs	r3, #31
     8fa:	4018      	ands	r0, r3
     8fc:	3b1e      	subs	r3, #30
     8fe:	4083      	lsls	r3, r0
     900:	2280      	movs	r2, #128	; 0x80
     902:	490c      	ldr	r1, [pc, #48]	; (934 <spi_reset+0x48>)
     904:	508b      	str	r3, [r1, r2]
	SercomSpi *const spi_module = &(module->hw->SPI);
     906:	682a      	ldr	r2, [r5, #0]
	return (spi_module->SYNCBUSY.reg);
     908:	69d3      	ldr	r3, [r2, #28]
#  endif

	while (spi_is_syncing(module)) {
     90a:	2b00      	cmp	r3, #0
     90c:	d1fc      	bne.n	908 <spi_reset+0x1c>
		/* Wait until the synchronization is complete */
	}

	/* Disbale interrupt */
	spi_module->INTENCLR.reg = SERCOM_SPI_INTENCLR_MASK;
     90e:	338f      	adds	r3, #143	; 0x8f
     910:	7523      	strb	r3, [r4, #20]
	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SERCOM_SPI_INTFLAG_MASK;
     912:	7623      	strb	r3, [r4, #24]

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
     914:	6823      	ldr	r3, [r4, #0]
     916:	2202      	movs	r2, #2
     918:	4393      	bics	r3, r2
     91a:	6023      	str	r3, [r4, #0]
	SercomSpi *const spi_module = &(module->hw->SPI);
     91c:	682a      	ldr	r2, [r5, #0]
	return (spi_module->SYNCBUSY.reg);
     91e:	69d3      	ldr	r3, [r2, #28]

	/* Disable the module */
	spi_disable(module);

	while (spi_is_syncing(module)) {
     920:	2b00      	cmp	r3, #0
     922:	d1fc      	bne.n	91e <spi_reset+0x32>
		/* Wait until the synchronization is complete */
	}

	/* Software reset the module */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_SWRST;
     924:	6823      	ldr	r3, [r4, #0]
     926:	2201      	movs	r2, #1
     928:	4313      	orrs	r3, r2
     92a:	6023      	str	r3, [r4, #0]
}
     92c:	bd70      	pop	{r4, r5, r6, pc}
     92e:	46c0      	nop			; (mov r8, r8)
     930:	00002ba1 	.word	0x00002ba1
     934:	e000e100 	.word	0xe000e100

00000938 <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
     938:	b5f0      	push	{r4, r5, r6, r7, lr}
     93a:	b08b      	sub	sp, #44	; 0x2c
     93c:	0005      	movs	r5, r0
     93e:	000c      	movs	r4, r1
     940:	0016      	movs	r6, r2
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
     942:	6029      	str	r1, [r5, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
     944:	680b      	ldr	r3, [r1, #0]
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
     946:	201c      	movs	r0, #28
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
     948:	079b      	lsls	r3, r3, #30
     94a:	d501      	bpl.n	950 <spi_init+0x18>
	_sercom_instances[instance_index] = module;
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
     94c:	b00b      	add	sp, #44	; 0x2c
     94e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
     950:	680b      	ldr	r3, [r1, #0]
		return STATUS_BUSY;
     952:	3817      	subs	r0, #23
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
     954:	07db      	lsls	r3, r3, #31
     956:	d4f9      	bmi.n	94c <spi_init+0x14>
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     958:	0008      	movs	r0, r1
     95a:	4b6f      	ldr	r3, [pc, #444]	; (b18 <spi_init+0x1e0>)
     95c:	4798      	blx	r3
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
     95e:	4a6f      	ldr	r2, [pc, #444]	; (b1c <spi_init+0x1e4>)
     960:	6a11      	ldr	r1, [r2, #32]
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
     962:	1c87      	adds	r7, r0, #2
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
     964:	2301      	movs	r3, #1
     966:	40bb      	lsls	r3, r7
     968:	430b      	orrs	r3, r1
     96a:	6213      	str	r3, [r2, #32]
	gclk_chan_conf.source_generator = config->generator_source;
     96c:	a909      	add	r1, sp, #36	; 0x24
     96e:	2724      	movs	r7, #36	; 0x24
     970:	5df3      	ldrb	r3, [r6, r7]
     972:	700b      	strb	r3, [r1, #0]
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
     974:	300e      	adds	r0, #14
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
     976:	b2c3      	uxtb	r3, r0
     978:	9301      	str	r3, [sp, #4]
     97a:	0018      	movs	r0, r3
     97c:	4b68      	ldr	r3, [pc, #416]	; (b20 <spi_init+0x1e8>)
     97e:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
     980:	9801      	ldr	r0, [sp, #4]
     982:	4b68      	ldr	r3, [pc, #416]	; (b24 <spi_init+0x1ec>)
     984:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
     986:	5df0      	ldrb	r0, [r6, r7]
     988:	2100      	movs	r1, #0
     98a:	4b67      	ldr	r3, [pc, #412]	; (b28 <spi_init+0x1f0>)
     98c:	4798      	blx	r3
	if (config->mode == SPI_MODE_MASTER) {
     98e:	7833      	ldrb	r3, [r6, #0]
     990:	2b01      	cmp	r3, #1
     992:	d03f      	beq.n	a14 <spi_init+0xdc>
	if (config->mode == SPI_MODE_SLAVE) {
     994:	7833      	ldrb	r3, [r6, #0]
     996:	2b00      	cmp	r3, #0
     998:	d103      	bne.n	9a2 <spi_init+0x6a>
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x2);
     99a:	6823      	ldr	r3, [r4, #0]
     99c:	2208      	movs	r2, #8
     99e:	4313      	orrs	r3, r2
     9a0:	6023      	str	r3, [r4, #0]
     9a2:	002b      	movs	r3, r5
     9a4:	330c      	adds	r3, #12
     9a6:	0029      	movs	r1, r5
     9a8:	3128      	adds	r1, #40	; 0x28
		module->callback[i]        = NULL;
     9aa:	2200      	movs	r2, #0
     9ac:	c304      	stmia	r3!, {r2}
	for (i = 0; i < SPI_CALLBACK_N; i++) {
     9ae:	428b      	cmp	r3, r1
     9b0:	d1fc      	bne.n	9ac <spi_init+0x74>
	module->tx_buffer_ptr              = NULL;
     9b2:	2300      	movs	r3, #0
     9b4:	62eb      	str	r3, [r5, #44]	; 0x2c
	module->rx_buffer_ptr              = NULL;
     9b6:	62ab      	str	r3, [r5, #40]	; 0x28
	module->remaining_tx_buffer_length = 0x0000;
     9b8:	2400      	movs	r4, #0
     9ba:	86ab      	strh	r3, [r5, #52]	; 0x34
	module->remaining_rx_buffer_length = 0x0000;
     9bc:	862b      	strh	r3, [r5, #48]	; 0x30
	module->registered_callback        = 0x00;
     9be:	3336      	adds	r3, #54	; 0x36
     9c0:	54ec      	strb	r4, [r5, r3]
	module->enabled_callback           = 0x00;
     9c2:	3301      	adds	r3, #1
     9c4:	54ec      	strb	r4, [r5, r3]
	module->status                     = STATUS_OK;
     9c6:	3301      	adds	r3, #1
     9c8:	54ec      	strb	r4, [r5, r3]
	module->dir                        = SPI_DIRECTION_IDLE;
     9ca:	3b35      	subs	r3, #53	; 0x35
     9cc:	726b      	strb	r3, [r5, #9]
	module->locked                     = false;
     9ce:	712c      	strb	r4, [r5, #4]
	instance_index = _sercom_get_sercom_inst_index(module->hw);
     9d0:	6828      	ldr	r0, [r5, #0]
     9d2:	4b51      	ldr	r3, [pc, #324]	; (b18 <spi_init+0x1e0>)
     9d4:	4798      	blx	r3
     9d6:	0007      	movs	r7, r0
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
     9d8:	4954      	ldr	r1, [pc, #336]	; (b2c <spi_init+0x1f4>)
     9da:	4b55      	ldr	r3, [pc, #340]	; (b30 <spi_init+0x1f8>)
     9dc:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
     9de:	00bf      	lsls	r7, r7, #2
     9e0:	4b54      	ldr	r3, [pc, #336]	; (b34 <spi_init+0x1fc>)
     9e2:	50fd      	str	r5, [r7, r3]
	SercomSpi *const spi_module = &(module->hw->SPI);
     9e4:	682f      	ldr	r7, [r5, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     9e6:	ab04      	add	r3, sp, #16
     9e8:	2280      	movs	r2, #128	; 0x80
     9ea:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
     9ec:	705c      	strb	r4, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
     9ee:	3a7f      	subs	r2, #127	; 0x7f
     9f0:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
     9f2:	70dc      	strb	r4, [r3, #3]
	if(config->mode == SPI_MODE_SLAVE) {
     9f4:	7833      	ldrb	r3, [r6, #0]
     9f6:	2b00      	cmp	r3, #0
     9f8:	d102      	bne.n	a00 <spi_init+0xc8>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
     9fa:	2200      	movs	r2, #0
     9fc:	ab04      	add	r3, sp, #16
     9fe:	709a      	strb	r2, [r3, #2]
	uint32_t pad_pinmuxes[] = {
     a00:	6ab3      	ldr	r3, [r6, #40]	; 0x28
     a02:	9305      	str	r3, [sp, #20]
     a04:	6af3      	ldr	r3, [r6, #44]	; 0x2c
     a06:	9306      	str	r3, [sp, #24]
     a08:	6b33      	ldr	r3, [r6, #48]	; 0x30
     a0a:	9307      	str	r3, [sp, #28]
     a0c:	6b73      	ldr	r3, [r6, #52]	; 0x34
     a0e:	9308      	str	r3, [sp, #32]
     a10:	2400      	movs	r4, #0
     a12:	e00b      	b.n	a2c <spi_init+0xf4>
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
     a14:	6823      	ldr	r3, [r4, #0]
     a16:	220c      	movs	r2, #12
     a18:	4313      	orrs	r3, r2
     a1a:	6023      	str	r3, [r4, #0]
     a1c:	e7ba      	b.n	994 <spi_init+0x5c>
			current_pinmux = _sercom_get_default_pad(hw, pad);
     a1e:	0038      	movs	r0, r7
     a20:	4b45      	ldr	r3, [pc, #276]	; (b38 <spi_init+0x200>)
     a22:	4798      	blx	r3
     a24:	e00a      	b.n	a3c <spi_init+0x104>
     a26:	3401      	adds	r4, #1
	for (uint8_t pad = 0; pad < 4; pad++) {
     a28:	2c04      	cmp	r4, #4
     a2a:	d010      	beq.n	a4e <spi_init+0x116>
     a2c:	b2e1      	uxtb	r1, r4
		uint32_t current_pinmux = pad_pinmuxes[pad];
     a2e:	00a3      	lsls	r3, r4, #2
     a30:	aa02      	add	r2, sp, #8
     a32:	200c      	movs	r0, #12
     a34:	1812      	adds	r2, r2, r0
     a36:	58d0      	ldr	r0, [r2, r3]
		if (current_pinmux == PINMUX_DEFAULT) {
     a38:	2800      	cmp	r0, #0
     a3a:	d0f0      	beq.n	a1e <spi_init+0xe6>
		if (current_pinmux != PINMUX_UNUSED) {
     a3c:	1c43      	adds	r3, r0, #1
     a3e:	d0f2      	beq.n	a26 <spi_init+0xee>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
     a40:	a904      	add	r1, sp, #16
     a42:	7008      	strb	r0, [r1, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
     a44:	0c00      	lsrs	r0, r0, #16
     a46:	b2c0      	uxtb	r0, r0
     a48:	4b3c      	ldr	r3, [pc, #240]	; (b3c <spi_init+0x204>)
     a4a:	4798      	blx	r3
     a4c:	e7eb      	b.n	a26 <spi_init+0xee>
	module->mode             = config->mode;
     a4e:	7833      	ldrb	r3, [r6, #0]
     a50:	716b      	strb	r3, [r5, #5]
	module->character_size   = config->character_size;
     a52:	7c33      	ldrb	r3, [r6, #16]
     a54:	71ab      	strb	r3, [r5, #6]
	module->receiver_enabled = config->receiver_enable;
     a56:	7cb3      	ldrb	r3, [r6, #18]
     a58:	71eb      	strb	r3, [r5, #7]
	module->master_slave_select_enable = config->master_slave_select_enable;
     a5a:	7d33      	ldrb	r3, [r6, #20]
     a5c:	722b      	strb	r3, [r5, #8]
	uint16_t baud = 0;
     a5e:	2200      	movs	r2, #0
     a60:	ab02      	add	r3, sp, #8
     a62:	80da      	strh	r2, [r3, #6]
	if (config->mode == SPI_MODE_MASTER) {
     a64:	7833      	ldrb	r3, [r6, #0]
     a66:	2b01      	cmp	r3, #1
     a68:	d012      	beq.n	a90 <spi_init+0x158>
	if (config->mode == SPI_MODE_SLAVE) {
     a6a:	7833      	ldrb	r3, [r6, #0]
     a6c:	2b00      	cmp	r3, #0
     a6e:	d126      	bne.n	abe <spi_init+0x186>
		ctrla = config->mode_specific.slave.frame_format;
     a70:	69b0      	ldr	r0, [r6, #24]
		ctrlb = config->mode_specific.slave.address_mode;
     a72:	8bb2      	ldrh	r2, [r6, #28]
		spi_module->ADDR.reg |=
     a74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
     a76:	7ff1      	ldrb	r1, [r6, #31]
     a78:	0409      	lsls	r1, r1, #16
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
     a7a:	7fb4      	ldrb	r4, [r6, #30]
     a7c:	4321      	orrs	r1, r4
		spi_module->ADDR.reg |=
     a7e:	4319      	orrs	r1, r3
     a80:	6279      	str	r1, [r7, #36]	; 0x24
		if (config->mode_specific.slave.preload_enable) {
     a82:	2320      	movs	r3, #32
     a84:	5cf3      	ldrb	r3, [r6, r3]
     a86:	2b00      	cmp	r3, #0
     a88:	d01b      	beq.n	ac2 <spi_init+0x18a>
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
     a8a:	2340      	movs	r3, #64	; 0x40
     a8c:	431a      	orrs	r2, r3
     a8e:	e018      	b.n	ac2 <spi_init+0x18a>
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     a90:	6828      	ldr	r0, [r5, #0]
     a92:	4b21      	ldr	r3, [pc, #132]	; (b18 <spi_init+0x1e0>)
     a94:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
     a96:	300e      	adds	r0, #14
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
     a98:	b2c0      	uxtb	r0, r0
     a9a:	4b29      	ldr	r3, [pc, #164]	; (b40 <spi_init+0x208>)
     a9c:	4798      	blx	r3
     a9e:	0001      	movs	r1, r0
		enum status_code error_code = _sercom_get_sync_baud_val(
     aa0:	ab02      	add	r3, sp, #8
     aa2:	1d9a      	adds	r2, r3, #6
     aa4:	69b0      	ldr	r0, [r6, #24]
     aa6:	4b27      	ldr	r3, [pc, #156]	; (b44 <spi_init+0x20c>)
     aa8:	4798      	blx	r3
     aaa:	0003      	movs	r3, r0
			return STATUS_ERR_INVALID_ARG;
     aac:	2017      	movs	r0, #23
		if (error_code != STATUS_OK) {
     aae:	2b00      	cmp	r3, #0
     ab0:	d000      	beq.n	ab4 <spi_init+0x17c>
     ab2:	e74b      	b.n	94c <spi_init+0x14>
		spi_module->BAUD.reg = (uint8_t)baud;
     ab4:	ab02      	add	r3, sp, #8
     ab6:	3306      	adds	r3, #6
     ab8:	781b      	ldrb	r3, [r3, #0]
     aba:	733b      	strb	r3, [r7, #12]
     abc:	e7d5      	b.n	a6a <spi_init+0x132>
	uint32_t ctrlb = 0;
     abe:	2200      	movs	r2, #0
	uint32_t ctrla = 0;
     ac0:	2000      	movs	r0, #0
	ctrla |= config->mux_setting;
     ac2:	6873      	ldr	r3, [r6, #4]
     ac4:	68b1      	ldr	r1, [r6, #8]
     ac6:	430b      	orrs	r3, r1
     ac8:	68f1      	ldr	r1, [r6, #12]
     aca:	430b      	orrs	r3, r1
     acc:	4303      	orrs	r3, r0
	ctrlb |= config->character_size;
     ace:	7c31      	ldrb	r1, [r6, #16]
     ad0:	430a      	orrs	r2, r1
	if (config->run_in_standby || system_is_debugger_present()) {
     ad2:	7c71      	ldrb	r1, [r6, #17]
     ad4:	2900      	cmp	r1, #0
     ad6:	d103      	bne.n	ae0 <spi_init+0x1a8>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
     ad8:	491b      	ldr	r1, [pc, #108]	; (b48 <spi_init+0x210>)
     ada:	7889      	ldrb	r1, [r1, #2]
     adc:	0789      	lsls	r1, r1, #30
     ade:	d501      	bpl.n	ae4 <spi_init+0x1ac>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
     ae0:	2180      	movs	r1, #128	; 0x80
     ae2:	430b      	orrs	r3, r1
	if (config->receiver_enable) {
     ae4:	7cb1      	ldrb	r1, [r6, #18]
     ae6:	2900      	cmp	r1, #0
     ae8:	d002      	beq.n	af0 <spi_init+0x1b8>
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
     aea:	2180      	movs	r1, #128	; 0x80
     aec:	0289      	lsls	r1, r1, #10
     aee:	430a      	orrs	r2, r1
	if (config->select_slave_low_detect_enable) {
     af0:	7cf1      	ldrb	r1, [r6, #19]
     af2:	2900      	cmp	r1, #0
     af4:	d002      	beq.n	afc <spi_init+0x1c4>
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
     af6:	2180      	movs	r1, #128	; 0x80
     af8:	0089      	lsls	r1, r1, #2
     afa:	430a      	orrs	r2, r1
	if (config->master_slave_select_enable) {
     afc:	7d31      	ldrb	r1, [r6, #20]
     afe:	2900      	cmp	r1, #0
     b00:	d002      	beq.n	b08 <spi_init+0x1d0>
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
     b02:	2180      	movs	r1, #128	; 0x80
     b04:	0189      	lsls	r1, r1, #6
     b06:	430a      	orrs	r2, r1
	spi_module->CTRLA.reg |= ctrla;
     b08:	6839      	ldr	r1, [r7, #0]
     b0a:	430b      	orrs	r3, r1
     b0c:	603b      	str	r3, [r7, #0]
	spi_module->CTRLB.reg |= ctrlb;
     b0e:	687b      	ldr	r3, [r7, #4]
     b10:	431a      	orrs	r2, r3
     b12:	607a      	str	r2, [r7, #4]
	return STATUS_OK;
     b14:	2000      	movs	r0, #0
     b16:	e719      	b.n	94c <spi_init+0x14>
     b18:	000018c5 	.word	0x000018c5
     b1c:	40000400 	.word	0x40000400
     b20:	000033cd 	.word	0x000033cd
     b24:	00003341 	.word	0x00003341
     b28:	000017b9 	.word	0x000017b9
     b2c:	00000bad 	.word	0x00000bad
     b30:	00002b65 	.word	0x00002b65
     b34:	200002b8 	.word	0x200002b8
     b38:	00001805 	.word	0x00001805
     b3c:	000034c5 	.word	0x000034c5
     b40:	000033e9 	.word	0x000033e9
     b44:	00001791 	.word	0x00001791
     b48:	41002000 	.word	0x41002000

00000b4c <spi_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
     b4c:	1c93      	adds	r3, r2, #2
     b4e:	009b      	lsls	r3, r3, #2
     b50:	18c3      	adds	r3, r0, r3
     b52:	6059      	str	r1, [r3, #4]

	/* Set the bit corresponding to the callback_type */
	module->registered_callback |= (1 << callback_type);
     b54:	2136      	movs	r1, #54	; 0x36
     b56:	2301      	movs	r3, #1
     b58:	4093      	lsls	r3, r2
     b5a:	001a      	movs	r2, r3
     b5c:	5c43      	ldrb	r3, [r0, r1]
     b5e:	4313      	orrs	r3, r2
     b60:	5443      	strb	r3, [r0, r1]
}
     b62:	4770      	bx	lr

00000b64 <spi_transceive_buffer_job>:
enum status_code spi_transceive_buffer_job(
		struct spi_module *const module,
		uint8_t *tx_data,
		uint8_t *rx_data,
		uint16_t length)
{
     b64:	b530      	push	{r4, r5, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(rx_data);
	
	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
     b66:	2417      	movs	r4, #23
	if (length == 0) {
     b68:	2b00      	cmp	r3, #0
     b6a:	d101      	bne.n	b70 <spi_transceive_buffer_job+0xc>

	/* Issue internal transceive */
	_spi_transceive_buffer(module, tx_data, rx_data, length);
	
	return STATUS_OK;
}
     b6c:	0020      	movs	r0, r4
     b6e:	bd30      	pop	{r4, r5, pc}
	if (!(module->receiver_enabled)) {
     b70:	79c5      	ldrb	r5, [r0, #7]
		return STATUS_ERR_DENIED;
     b72:	3405      	adds	r4, #5
	if (!(module->receiver_enabled)) {
     b74:	2d00      	cmp	r5, #0
     b76:	d0f9      	beq.n	b6c <spi_transceive_buffer_job+0x8>
	if (module->status == STATUS_BUSY) {
     b78:	341c      	adds	r4, #28
     b7a:	5d05      	ldrb	r5, [r0, r4]
		return STATUS_BUSY;
     b7c:	3c33      	subs	r4, #51	; 0x33
	if (module->status == STATUS_BUSY) {
     b7e:	2d05      	cmp	r5, #5
     b80:	d0f4      	beq.n	b6c <spi_transceive_buffer_job+0x8>
	module->remaining_tx_buffer_length = length;
     b82:	8683      	strh	r3, [r0, #52]	; 0x34
	module->remaining_rx_buffer_length = length;
     b84:	8603      	strh	r3, [r0, #48]	; 0x30
	module->rx_buffer_ptr = rx_data;
     b86:	6282      	str	r2, [r0, #40]	; 0x28
	module->tx_buffer_ptr = tx_data;
     b88:	62c1      	str	r1, [r0, #44]	; 0x2c
	module->status = STATUS_BUSY;
     b8a:	2205      	movs	r2, #5
     b8c:	2338      	movs	r3, #56	; 0x38
     b8e:	54c2      	strb	r2, [r0, r3]
	module->dir = SPI_DIRECTION_BOTH;
     b90:	3b36      	subs	r3, #54	; 0x36
     b92:	7243      	strb	r3, [r0, #9]
	SercomSpi *const hw = &(module->hw->SPI);
     b94:	6803      	ldr	r3, [r0, #0]
	hw->INTENSET.reg = (SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY |
     b96:	759a      	strb	r2, [r3, #22]
	hw->INTFLAG.reg = (SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY |
     b98:	3280      	adds	r2, #128	; 0x80
     b9a:	761a      	strb	r2, [r3, #24]
	if (module->mode == SPI_MODE_SLAVE) {
     b9c:	7942      	ldrb	r2, [r0, #5]
	return STATUS_OK;
     b9e:	2400      	movs	r4, #0
	if (module->mode == SPI_MODE_SLAVE) {
     ba0:	2a00      	cmp	r2, #0
     ba2:	d1e3      	bne.n	b6c <spi_transceive_buffer_job+0x8>
		hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
     ba4:	3202      	adds	r2, #2
     ba6:	761a      	strb	r2, [r3, #24]
		hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
     ba8:	759a      	strb	r2, [r3, #22]
     baa:	e7df      	b.n	b6c <spi_transceive_buffer_job+0x8>

00000bac <_spi_interrupt_handler>:

extern volatile bool spi_reset_1 ;


void _spi_interrupt_handler(uint8_t instance)
{
     bac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	
	
	//*PORT_SET	=  G2_RGB;
	
	/* Get device instance from the look-up table */
	struct spi_module *module = (struct spi_module *)_sercom_instances[instance];
     bae:	0080      	lsls	r0, r0, #2
     bb0:	4b62      	ldr	r3, [pc, #392]	; (d3c <_spi_interrupt_handler+0x190>)
     bb2:	58c5      	ldr	r5, [r0, r3]

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
     bb4:	682e      	ldr	r6, [r5, #0]

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask = module->enabled_callback & module->registered_callback;
     bb6:	2337      	movs	r3, #55	; 0x37
     bb8:	5cef      	ldrb	r7, [r5, r3]
     bba:	2236      	movs	r2, #54	; 0x36
     bbc:	5caa      	ldrb	r2, [r5, r2]
     bbe:	4017      	ands	r7, r2

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
     bc0:	7e33      	ldrb	r3, [r6, #24]
	interrupt_status &= spi_hw->INTENSET.reg;
     bc2:	7db4      	ldrb	r4, [r6, #22]
     bc4:	401c      	ands	r4, r3
	
	/* Data register empty interrupt */ 
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) 
     bc6:	07e3      	lsls	r3, r4, #31
     bc8:	d514      	bpl.n	bf4 <_spi_interrupt_handler+0x48>
	{
		if((module->mode == SPI_MODE_SLAVE) &&(module->dir != SPI_DIRECTION_READ))
     bca:	796b      	ldrb	r3, [r5, #5]
     bcc:	2b00      	cmp	r3, #0
     bce:	d111      	bne.n	bf4 <_spi_interrupt_handler+0x48>
     bd0:	7a6b      	ldrb	r3, [r5, #9]
     bd2:	2b00      	cmp	r3, #0
     bd4:	d00e      	beq.n	bf4 <_spi_interrupt_handler+0x48>
		 {
			//_spi_write(module);
			//*PORT_SET	=  B2_RGB;
			data_to_send = *(module->tx_buffer_ptr);
     bd6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
     bd8:	781a      	ldrb	r2, [r3, #0]
			(module->tx_buffer_ptr)++;
     bda:	3301      	adds	r3, #1
     bdc:	62eb      	str	r3, [r5, #44]	; 0x2c
			spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
     bde:	62b2      	str	r2, [r6, #40]	; 0x28
			(module->remaining_tx_buffer_length)--;
     be0:	8eab      	ldrh	r3, [r5, #52]	; 0x34
     be2:	3b01      	subs	r3, #1
     be4:	b29b      	uxth	r3, r3
     be6:	86ab      	strh	r3, [r5, #52]	; 0x34
		
			if (module->remaining_tx_buffer_length == 0) 
     be8:	8eab      	ldrh	r3, [r5, #52]	; 0x34
     bea:	b29b      	uxth	r3, r3
     bec:	2b00      	cmp	r3, #0
     bee:	d101      	bne.n	bf4 <_spi_interrupt_handler+0x48>
			{
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
     bf0:	3301      	adds	r3, #1
     bf2:	7533      	strb	r3, [r6, #20]
			//*PORT_CLEAR	=  B2_RGB;
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
     bf4:	0763      	lsls	r3, r4, #29
     bf6:	d505      	bpl.n	c04 <_spi_interrupt_handler+0x58>
		/* Check for overflow */
		//*PORT_SET	=  B2_RGB;
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) 
     bf8:	8b73      	ldrh	r3, [r6, #26]
     bfa:	075b      	lsls	r3, r3, #29
     bfc:	d520      	bpl.n	c40 <_spi_interrupt_handler+0x94>
		{
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
     bfe:	6ab3      	ldr	r3, [r6, #40]	; 0x28
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
     c00:	2304      	movs	r3, #4
     c02:	8373      	strh	r3, [r6, #26]
			}
			//*PORT_CLEAR	=  B2_RGB;
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
     c04:	07a3      	lsls	r3, r4, #30
     c06:	d50b      	bpl.n	c20 <_spi_interrupt_handler+0x74>
#  if CONF_SPI_SLAVE_ENABLE == true
		if (module->mode == SPI_MODE_SLAVE) {
     c08:	796b      	ldrb	r3, [r5, #5]
     c0a:	2b00      	cmp	r3, #0
     c0c:	d113      	bne.n	c36 <_spi_interrupt_handler+0x8a>
			
			spi_reset_1 = true;
     c0e:	2201      	movs	r2, #1
     c10:	4b4b      	ldr	r3, [pc, #300]	; (d40 <_spi_interrupt_handler+0x194>)
     c12:	701a      	strb	r2, [r3, #0]
			if(module->dir == SPI_DIRECTION_BOTH) {
     c14:	7a6b      	ldrb	r3, [r5, #9]
     c16:	2b02      	cmp	r3, #2
     c18:	d100      	bne.n	c1c <_spi_interrupt_handler+0x70>
     c1a:	e07a      	b.n	d12 <_spi_interrupt_handler+0x166>
					(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
					
				}
			}
			//*PORT_SET	=  B2_RGB;
			spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
     c1c:	2302      	movs	r3, #2
     c1e:	7633      	strb	r3, [r6, #24]

#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
#  if CONF_SPI_SLAVE_ENABLE == true
        
		/* When a high to low transition is detected on the _SS pin in slave mode */
		if (interrupt_status & SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW) {
     c20:	0723      	lsls	r3, r4, #28
     c22:	d508      	bpl.n	c36 <_spi_interrupt_handler+0x8a>
			if (module->mode == SPI_MODE_SLAVE) {
     c24:	796b      	ldrb	r3, [r5, #5]
     c26:	2b00      	cmp	r3, #0
     c28:	d105      	bne.n	c36 <_spi_interrupt_handler+0x8a>
				//*PORT_SET	=  B2_RGB;
				/* Disable interrupts */
				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW;
     c2a:	3308      	adds	r3, #8
     c2c:	7533      	strb	r3, [r6, #20]
				/* Clear interrupt flag */
				spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW;
     c2e:	7633      	strb	r3, [r6, #24]

				if (callback_mask & (1 << SPI_CALLBACK_SLAVE_SELECT_LOW)) {
     c30:	06bb      	lsls	r3, r7, #26
     c32:	d500      	bpl.n	c36 <_spi_interrupt_handler+0x8a>
     c34:	e074      	b.n	d20 <_spi_interrupt_handler+0x174>
#  endif
#  endif

#  ifdef FEATURE_SPI_ERROR_INTERRUPT
	/* When combined error happen */
	if (interrupt_status & SPI_INTERRUPT_FLAG_COMBINED_ERROR) {
     c36:	b264      	sxtb	r4, r4
     c38:	2c00      	cmp	r4, #0
     c3a:	da00      	bge.n	c3e <_spi_interrupt_handler+0x92>
     c3c:	e074      	b.n	d28 <_spi_interrupt_handler+0x17c>
	}
#  endif
	
	//*PORT_CLEAR	=  G2_RGB;
  
}
     c3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
     c40:	6ab3      	ldr	r3, [r6, #40]	; 0x28
				*(module->rx_buffer_ptr) = received_data;
     c42:	b2db      	uxtb	r3, r3
     c44:	6aaa      	ldr	r2, [r5, #40]	; 0x28
     c46:	7013      	strb	r3, [r2, #0]
				module->rx_buffer_ptr += 1;
     c48:	6aa9      	ldr	r1, [r5, #40]	; 0x28
     c4a:	1c4b      	adds	r3, r1, #1
     c4c:	62ab      	str	r3, [r5, #40]	; 0x28
				module->remaining_rx_buffer_length--;
     c4e:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
     c50:	3b01      	subs	r3, #1
     c52:	b29b      	uxth	r3, r3
     c54:	862b      	strh	r3, [r5, #48]	; 0x30
				buffer_length++;
     c56:	4a3b      	ldr	r2, [pc, #236]	; (d44 <_spi_interrupt_handler+0x198>)
     c58:	7813      	ldrb	r3, [r2, #0]
     c5a:	3301      	adds	r3, #1
     c5c:	b2db      	uxtb	r3, r3
     c5e:	7013      	strb	r3, [r2, #0]
				if(buffer_length == 1)
     c60:	2b01      	cmp	r3, #1
     c62:	d01d      	beq.n	ca0 <_spi_interrupt_handler+0xf4>
				if (module->remaining_rx_buffer_length == 0) 
     c64:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
     c66:	b29b      	uxth	r3, r3
     c68:	2b00      	cmp	r3, #0
     c6a:	d1cb      	bne.n	c04 <_spi_interrupt_handler+0x58>
					buffer_length = 0;
     c6c:	4a35      	ldr	r2, [pc, #212]	; (d44 <_spi_interrupt_handler+0x198>)
     c6e:	7013      	strb	r3, [r2, #0]
					transcation_start = false;
     c70:	4a35      	ldr	r2, [pc, #212]	; (d48 <_spi_interrupt_handler+0x19c>)
     c72:	7013      	strb	r3, [r2, #0]
					firmware_check = false;
     c74:	4a35      	ldr	r2, [pc, #212]	; (d4c <_spi_interrupt_handler+0x1a0>)
     c76:	7013      	strb	r3, [r2, #0]
					serial_timeout = false;
     c78:	4a35      	ldr	r2, [pc, #212]	; (d50 <_spi_interrupt_handler+0x1a4>)
     c7a:	7013      	strb	r3, [r2, #0]
					serial_timeout_count = 0 ;
     c7c:	4a35      	ldr	r2, [pc, #212]	; (d54 <_spi_interrupt_handler+0x1a8>)
     c7e:	7013      	strb	r3, [r2, #0]
					module->status = STATUS_OK;
     c80:	2238      	movs	r2, #56	; 0x38
     c82:	54ab      	strb	r3, [r5, r2]
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
     c84:	3304      	adds	r3, #4
     c86:	7533      	strb	r3, [r6, #20]
					if(module->dir == SPI_DIRECTION_BOTH) {
     c88:	7a6b      	ldrb	r3, [r5, #9]
     c8a:	2b02      	cmp	r3, #2
     c8c:	d03a      	beq.n	d04 <_spi_interrupt_handler+0x158>
					} else if (module->dir == SPI_DIRECTION_READ) {
     c8e:	7a6b      	ldrb	r3, [r5, #9]
     c90:	2b00      	cmp	r3, #0
     c92:	d1b7      	bne.n	c04 <_spi_interrupt_handler+0x58>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
     c94:	07bb      	lsls	r3, r7, #30
     c96:	d5b5      	bpl.n	c04 <_spi_interrupt_handler+0x58>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
     c98:	0028      	movs	r0, r5
     c9a:	692b      	ldr	r3, [r5, #16]
     c9c:	4798      	blx	r3
     c9e:	e7b1      	b.n	c04 <_spi_interrupt_handler+0x58>
					transcation_start = true;
     ca0:	2201      	movs	r2, #1
     ca2:	4b29      	ldr	r3, [pc, #164]	; (d48 <_spi_interrupt_handler+0x19c>)
     ca4:	701a      	strb	r2, [r3, #0]
					serial_timeout = false;
     ca6:	2300      	movs	r3, #0
     ca8:	4a29      	ldr	r2, [pc, #164]	; (d50 <_spi_interrupt_handler+0x1a4>)
     caa:	7013      	strb	r3, [r2, #0]
					serial_timeout_count = 0 ; 
     cac:	4a29      	ldr	r2, [pc, #164]	; (d54 <_spi_interrupt_handler+0x1a8>)
     cae:	7013      	strb	r3, [r2, #0]
					if ((*(module->rx_buffer_ptr-1) == WR_SPI_INT_SET_ALL )) 
     cb0:	780b      	ldrb	r3, [r1, #0]
     cb2:	b2db      	uxtb	r3, r3
     cb4:	2bca      	cmp	r3, #202	; 0xca
     cb6:	d013      	beq.n	ce0 <_spi_interrupt_handler+0x134>
					else if((*(module->rx_buffer_ptr-1) == DEVICE_VERSION) || (*(module->rx_buffer_ptr-1) == WR_SPI_INT_RECEIVE_ALL) )
     cb8:	780b      	ldrb	r3, [r1, #0]
     cba:	b2db      	uxtb	r3, r3
     cbc:	2b8c      	cmp	r3, #140	; 0x8c
     cbe:	d003      	beq.n	cc8 <_spi_interrupt_handler+0x11c>
     cc0:	780b      	ldrb	r3, [r1, #0]
     cc2:	b2db      	uxtb	r3, r3
     cc4:	2bcc      	cmp	r3, #204	; 0xcc
     cc6:	d1cd      	bne.n	c64 <_spi_interrupt_handler+0xb8>
						if(*(module->rx_buffer_ptr-1) == WR_SPI_INT_RECEIVE_ALL)
     cc8:	780b      	ldrb	r3, [r1, #0]
     cca:	b2db      	uxtb	r3, r3
     ccc:	2bcc      	cmp	r3, #204	; 0xcc
     cce:	d010      	beq.n	cf2 <_spi_interrupt_handler+0x146>
							*(module->tx_buffer_ptr)      =	DEVICE_ID_HARDWARE ;
     cd0:	2301      	movs	r3, #1
     cd2:	6aea      	ldr	r2, [r5, #44]	; 0x2c
     cd4:	7013      	strb	r3, [r2, #0]
							*(module->tx_buffer_ptr + 1)  = DEVICE_ID_FIRMWARE ;
     cd6:	6aea      	ldr	r2, [r5, #44]	; 0x2c
     cd8:	7053      	strb	r3, [r2, #1]
							firmware_check				  = true;
     cda:	4a1c      	ldr	r2, [pc, #112]	; (d4c <_spi_interrupt_handler+0x1a0>)
     cdc:	7013      	strb	r3, [r2, #0]
     cde:	e7c1      	b.n	c64 <_spi_interrupt_handler+0xb8>
						module->remaining_tx_buffer_length =  LENGTH_SET_ALL_COMMAND - (INITIAL_LENGTH - module->remaining_tx_buffer_length);
     ce0:	8eab      	ldrh	r3, [r5, #52]	; 0x34
     ce2:	3309      	adds	r3, #9
     ce4:	b29b      	uxth	r3, r3
     ce6:	86ab      	strh	r3, [r5, #52]	; 0x34
						module->remaining_rx_buffer_length =  LENGTH_SET_ALL_COMMAND - (INITIAL_LENGTH - module->remaining_rx_buffer_length);
     ce8:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
     cea:	3309      	adds	r3, #9
     cec:	b29b      	uxth	r3, r3
     cee:	862b      	strh	r3, [r5, #48]	; 0x30
     cf0:	e7b8      	b.n	c64 <_spi_interrupt_handler+0xb8>
							 module->remaining_tx_buffer_length =  LENGTH_SENSOR_MAKE_COMMAND - (INITIAL_LENGTH - module->remaining_tx_buffer_length);
     cf2:	8eab      	ldrh	r3, [r5, #52]	; 0x34
     cf4:	3302      	adds	r3, #2
     cf6:	b29b      	uxth	r3, r3
     cf8:	86ab      	strh	r3, [r5, #52]	; 0x34
							 module->remaining_rx_buffer_length =  LENGTH_SENSOR_MAKE_COMMAND - (INITIAL_LENGTH - module->remaining_rx_buffer_length);
     cfa:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
     cfc:	3302      	adds	r3, #2
     cfe:	b29b      	uxth	r3, r3
     d00:	862b      	strh	r3, [r5, #48]	; 0x30
     d02:	e7af      	b.n	c64 <_spi_interrupt_handler+0xb8>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
     d04:	077b      	lsls	r3, r7, #29
     d06:	d400      	bmi.n	d0a <_spi_interrupt_handler+0x15e>
     d08:	e77c      	b.n	c04 <_spi_interrupt_handler+0x58>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
     d0a:	0028      	movs	r0, r5
     d0c:	696b      	ldr	r3, [r5, #20]
     d0e:	4798      	blx	r3
     d10:	e778      	b.n	c04 <_spi_interrupt_handler+0x58>
				if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
     d12:	077b      	lsls	r3, r7, #29
     d14:	d400      	bmi.n	d18 <_spi_interrupt_handler+0x16c>
     d16:	e781      	b.n	c1c <_spi_interrupt_handler+0x70>
					(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
     d18:	0028      	movs	r0, r5
     d1a:	696b      	ldr	r3, [r5, #20]
     d1c:	4798      	blx	r3
     d1e:	e77d      	b.n	c1c <_spi_interrupt_handler+0x70>
					(module->callback[SPI_CALLBACK_SLAVE_SELECT_LOW])(module);
     d20:	0028      	movs	r0, r5
     d22:	6a2b      	ldr	r3, [r5, #32]
     d24:	4798      	blx	r3
     d26:	e786      	b.n	c36 <_spi_interrupt_handler+0x8a>
		spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
     d28:	2380      	movs	r3, #128	; 0x80
     d2a:	7533      	strb	r3, [r6, #20]
		spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
     d2c:	7633      	strb	r3, [r6, #24]
		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
     d2e:	067b      	lsls	r3, r7, #25
     d30:	d400      	bmi.n	d34 <_spi_interrupt_handler+0x188>
     d32:	e784      	b.n	c3e <_spi_interrupt_handler+0x92>
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
     d34:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     d36:	0028      	movs	r0, r5
     d38:	4798      	blx	r3
}
     d3a:	e780      	b.n	c3e <_spi_interrupt_handler+0x92>
     d3c:	200002b8 	.word	0x200002b8
     d40:	200000f5 	.word	0x200000f5
     d44:	20000090 	.word	0x20000090
     d48:	200000f6 	.word	0x200000f6
     d4c:	200000f1 	.word	0x200000f1
     d50:	200000f3 	.word	0x200000f3
     d54:	200000f4 	.word	0x200000f4

00000d58 <check_timeout>:
To ensure that there all the SPI commands that we are waiting for once started takes less than 
16 msec to complete we used the timer interrupt of the LED to make it happen.If serial timeout occurred 
then reset the SPI so that we have the right SPI bytes in the buffer during the start
********************************************************************************************/
void check_timeout()
{
     d58:	b570      	push	{r4, r5, r6, lr}
	
	if(transcation_start == true)
     d5a:	4b14      	ldr	r3, [pc, #80]	; (dac <check_timeout+0x54>)
     d5c:	781b      	ldrb	r3, [r3, #0]
     d5e:	2b00      	cmp	r3, #0
     d60:	d003      	beq.n	d6a <check_timeout+0x12>
	{
		if(serial_timeout == true)
     d62:	4b13      	ldr	r3, [pc, #76]	; (db0 <check_timeout+0x58>)
     d64:	781b      	ldrb	r3, [r3, #0]
     d66:	2b00      	cmp	r3, #0
     d68:	d100      	bne.n	d6c <check_timeout+0x14>
		}
	}
		
	
	
}
     d6a:	bd70      	pop	{r4, r5, r6, pc}
			update_ORB_single(RGB2_NO , 250 , 0 , 0);
     d6c:	2300      	movs	r3, #0
     d6e:	2200      	movs	r2, #0
     d70:	21fa      	movs	r1, #250	; 0xfa
     d72:	2032      	movs	r0, #50	; 0x32
     d74:	4c0f      	ldr	r4, [pc, #60]	; (db4 <check_timeout+0x5c>)
     d76:	47a0      	blx	r4
			serial_timeout_count = 0;
     d78:	2300      	movs	r3, #0
     d7a:	4a0f      	ldr	r2, [pc, #60]	; (db8 <check_timeout+0x60>)
     d7c:	7013      	strb	r3, [r2, #0]
			serial_timeout = false;
     d7e:	4a0c      	ldr	r2, [pc, #48]	; (db0 <check_timeout+0x58>)
     d80:	7013      	strb	r3, [r2, #0]
			transcation_start = false;
     d82:	4a0a      	ldr	r2, [pc, #40]	; (dac <check_timeout+0x54>)
     d84:	7013      	strb	r3, [r2, #0]
			spi_reset(&spi_slave_instance);
     d86:	4d0d      	ldr	r5, [pc, #52]	; (dbc <check_timeout+0x64>)
     d88:	0028      	movs	r0, r5
     d8a:	4b0d      	ldr	r3, [pc, #52]	; (dc0 <check_timeout+0x68>)
     d8c:	4798      	blx	r3
			spi_slave_init();
     d8e:	4b0d      	ldr	r3, [pc, #52]	; (dc4 <check_timeout+0x6c>)
     d90:	4798      	blx	r3
			spi_transceive_buffer_job(&spi_slave_instance, sensor_outputs, received_value,SPI_LENGTH);
     d92:	2304      	movs	r3, #4
     d94:	4a0c      	ldr	r2, [pc, #48]	; (dc8 <check_timeout+0x70>)
     d96:	490d      	ldr	r1, [pc, #52]	; (dcc <check_timeout+0x74>)
     d98:	0028      	movs	r0, r5
     d9a:	4d0d      	ldr	r5, [pc, #52]	; (dd0 <check_timeout+0x78>)
     d9c:	47a8      	blx	r5
			update_ORB_single(RGB2_NO , 0 , 0 , 0);
     d9e:	2300      	movs	r3, #0
     da0:	2200      	movs	r2, #0
     da2:	2100      	movs	r1, #0
     da4:	2032      	movs	r0, #50	; 0x32
     da6:	47a0      	blx	r4
}
     da8:	e7df      	b.n	d6a <check_timeout+0x12>
     daa:	46c0      	nop			; (mov r8, r8)
     dac:	200000f6 	.word	0x200000f6
     db0:	200000f3 	.word	0x200000f3
     db4:	00001971 	.word	0x00001971
     db8:	200000f4 	.word	0x200000f4
     dbc:	20000104 	.word	0x20000104
     dc0:	000008ed 	.word	0x000008ed
     dc4:	00001085 	.word	0x00001085
     dc8:	200002e4 	.word	0x200002e4
     dcc:	200002f8 	.word	0x200002f8
     dd0:	00000b65 	.word	0x00000b65

00000dd4 <spi_main_loop>:


void spi_main_loop()
{
     dd4:	b5f0      	push	{r4, r5, r6, r7, lr}
     dd6:	46c6      	mov	lr, r8
     dd8:	b500      	push	{lr}
     dda:	b086      	sub	sp, #24
	
	volatile enum status_code error_code = 0x10;
     ddc:	2210      	movs	r2, #16
     dde:	2317      	movs	r3, #23
     de0:	446b      	add	r3, sp
     de2:	701a      	strb	r2, [r3, #0]

	uint8_t i    = 0;
	uint8_t rw   = 0;
	uint8_t mode = 0;
	static bool test = true;
	transmit_value[0] = 0x88;
     de4:	4b45      	ldr	r3, [pc, #276]	; (efc <spi_main_loop+0x128>)
     de6:	3278      	adds	r2, #120	; 0x78
     de8:	701a      	strb	r2, [r3, #0]
	transmit_value[1] = 0xAA;
     dea:	3222      	adds	r2, #34	; 0x22
     dec:	705a      	strb	r2, [r3, #1]
	transmit_value[2] = 0xBB;
     dee:	3211      	adds	r2, #17
     df0:	709a      	strb	r2, [r3, #2]
	transmit_value[3] = 0xCC;
     df2:	3211      	adds	r2, #17
     df4:	70da      	strb	r2, [r3, #3]
	check_timeout();
     df6:	4b42      	ldr	r3, [pc, #264]	; (f00 <spi_main_loop+0x12c>)
     df8:	4798      	blx	r3
	if(transfer_complete_spi_slave == true)
     dfa:	4b42      	ldr	r3, [pc, #264]	; (f04 <spi_main_loop+0x130>)
     dfc:	781b      	ldrb	r3, [r3, #0]
     dfe:	2b00      	cmp	r3, #0
     e00:	d009      	beq.n	e16 <spi_main_loop+0x42>
	{
		rw   = temp_receive[0] & MASK_RW ; 
     e02:	4a41      	ldr	r2, [pc, #260]	; (f08 <spi_main_loop+0x134>)
     e04:	7813      	ldrb	r3, [r2, #0]
		mode = temp_receive[0] & MASK_MODE;
     e06:	7812      	ldrb	r2, [r2, #0]
     e08:	b2d2      	uxtb	r2, r2
		if(rw == WRITE_SPI)
     e0a:	213f      	movs	r1, #63	; 0x3f
     e0c:	438b      	bics	r3, r1
     e0e:	2bc0      	cmp	r3, #192	; 0xc0
     e10:	d005      	beq.n	e1e <spi_main_loop+0x4a>
				default:
					break;
			}
			
		}
		check_buffer();	//Look for more SPI commands if occurred , while completing one operation	
     e12:	4b3e      	ldr	r3, [pc, #248]	; (f0c <spi_main_loop+0x138>)
     e14:	4798      	blx	r3
	}
	
}		
     e16:	b006      	add	sp, #24
     e18:	bc04      	pop	{r2}
     e1a:	4690      	mov	r8, r2
     e1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		mode = temp_receive[0] & MASK_MODE;
     e1e:	3b81      	subs	r3, #129	; 0x81
     e20:	401a      	ands	r2, r3
			switch(mode)
     e22:	b2d3      	uxtb	r3, r2
     e24:	2b0b      	cmp	r3, #11
     e26:	d8f4      	bhi.n	e12 <spi_main_loop+0x3e>
     e28:	0092      	lsls	r2, r2, #2
     e2a:	4b39      	ldr	r3, [pc, #228]	; (f10 <spi_main_loop+0x13c>)
     e2c:	589b      	ldr	r3, [r3, r2]
     e2e:	469f      	mov	pc, r3
					update_LEDS_single(LED1_NO,temp_receive[1]);
     e30:	4b35      	ldr	r3, [pc, #212]	; (f08 <spi_main_loop+0x134>)
     e32:	7859      	ldrb	r1, [r3, #1]
     e34:	b2c9      	uxtb	r1, r1
     e36:	2031      	movs	r0, #49	; 0x31
     e38:	4b36      	ldr	r3, [pc, #216]	; (f14 <spi_main_loop+0x140>)
     e3a:	4798      	blx	r3
					break;
     e3c:	e7e9      	b.n	e12 <spi_main_loop+0x3e>
					update_LEDS_single(LED2_NO,temp_receive[1]);
     e3e:	4b32      	ldr	r3, [pc, #200]	; (f08 <spi_main_loop+0x134>)
     e40:	7859      	ldrb	r1, [r3, #1]
     e42:	b2c9      	uxtb	r1, r1
     e44:	2032      	movs	r0, #50	; 0x32
     e46:	4b33      	ldr	r3, [pc, #204]	; (f14 <spi_main_loop+0x140>)
     e48:	4798      	blx	r3
					break;
     e4a:	e7e2      	b.n	e12 <spi_main_loop+0x3e>
				    update_ORB_single(RGB1_NO , temp_receive[1] , temp_receive[2] , temp_receive[3]);
     e4c:	4b2e      	ldr	r3, [pc, #184]	; (f08 <spi_main_loop+0x134>)
     e4e:	7859      	ldrb	r1, [r3, #1]
     e50:	b2c9      	uxtb	r1, r1
     e52:	789a      	ldrb	r2, [r3, #2]
     e54:	b2d2      	uxtb	r2, r2
     e56:	78db      	ldrb	r3, [r3, #3]
     e58:	b2db      	uxtb	r3, r3
     e5a:	2031      	movs	r0, #49	; 0x31
     e5c:	4c2e      	ldr	r4, [pc, #184]	; (f18 <spi_main_loop+0x144>)
     e5e:	47a0      	blx	r4
					break;
     e60:	e7d7      	b.n	e12 <spi_main_loop+0x3e>
					update_ORB_single(RGB2_NO , temp_receive[1] , temp_receive[2] , temp_receive[3]);
     e62:	4b29      	ldr	r3, [pc, #164]	; (f08 <spi_main_loop+0x134>)
     e64:	7859      	ldrb	r1, [r3, #1]
     e66:	b2c9      	uxtb	r1, r1
     e68:	789a      	ldrb	r2, [r3, #2]
     e6a:	b2d2      	uxtb	r2, r2
     e6c:	78db      	ldrb	r3, [r3, #3]
     e6e:	b2db      	uxtb	r3, r3
     e70:	2032      	movs	r0, #50	; 0x32
     e72:	4c29      	ldr	r4, [pc, #164]	; (f18 <spi_main_loop+0x144>)
     e74:	47a0      	blx	r4
					break;
     e76:	e7cc      	b.n	e12 <spi_main_loop+0x3e>
					update_super_servo_single(SERVO1_NO,temp_receive[1]);
     e78:	4b23      	ldr	r3, [pc, #140]	; (f08 <spi_main_loop+0x134>)
     e7a:	7859      	ldrb	r1, [r3, #1]
     e7c:	b2c9      	uxtb	r1, r1
     e7e:	2031      	movs	r0, #49	; 0x31
     e80:	4b26      	ldr	r3, [pc, #152]	; (f1c <spi_main_loop+0x148>)
     e82:	4798      	blx	r3
					break;
     e84:	e7c5      	b.n	e12 <spi_main_loop+0x3e>
					update_super_servo_single(SERVO2_NO,temp_receive[1]);
     e86:	4b20      	ldr	r3, [pc, #128]	; (f08 <spi_main_loop+0x134>)
     e88:	7859      	ldrb	r1, [r3, #1]
     e8a:	b2c9      	uxtb	r1, r1
     e8c:	2032      	movs	r0, #50	; 0x32
     e8e:	4b23      	ldr	r3, [pc, #140]	; (f1c <spi_main_loop+0x148>)
     e90:	4798      	blx	r3
					break;
     e92:	e7be      	b.n	e12 <spi_main_loop+0x3e>
					update_super_servo_single(SERVO3_NO,temp_receive[1]);
     e94:	4b1c      	ldr	r3, [pc, #112]	; (f08 <spi_main_loop+0x134>)
     e96:	7859      	ldrb	r1, [r3, #1]
     e98:	b2c9      	uxtb	r1, r1
     e9a:	2033      	movs	r0, #51	; 0x33
     e9c:	4b1f      	ldr	r3, [pc, #124]	; (f1c <spi_main_loop+0x148>)
     e9e:	4798      	blx	r3
					break;
     ea0:	e7b7      	b.n	e12 <spi_main_loop+0x3e>
					update_super_servo_single(SERVO4_NO,temp_receive[1]);
     ea2:	4b19      	ldr	r3, [pc, #100]	; (f08 <spi_main_loop+0x134>)
     ea4:	7859      	ldrb	r1, [r3, #1]
     ea6:	b2c9      	uxtb	r1, r1
     ea8:	2034      	movs	r0, #52	; 0x34
     eaa:	4b1c      	ldr	r3, [pc, #112]	; (f1c <spi_main_loop+0x148>)
     eac:	4798      	blx	r3
					break;
     eae:	e7b0      	b.n	e12 <spi_main_loop+0x3e>
					update_ORB_LED(temp_receive[3],temp_receive[4] ,temp_receive[5] ,temp_receive[6] ,temp_receive[7] ,temp_receive[8],temp_receive[1],temp_receive[2]);
     eb0:	4c15      	ldr	r4, [pc, #84]	; (f08 <spi_main_loop+0x134>)
     eb2:	78e0      	ldrb	r0, [r4, #3]
     eb4:	b2c0      	uxtb	r0, r0
     eb6:	7921      	ldrb	r1, [r4, #4]
     eb8:	b2c9      	uxtb	r1, r1
     eba:	7962      	ldrb	r2, [r4, #5]
     ebc:	b2d2      	uxtb	r2, r2
     ebe:	79a3      	ldrb	r3, [r4, #6]
     ec0:	b2db      	uxtb	r3, r3
     ec2:	4698      	mov	r8, r3
     ec4:	79e5      	ldrb	r5, [r4, #7]
     ec6:	7a26      	ldrb	r6, [r4, #8]
     ec8:	7867      	ldrb	r7, [r4, #1]
     eca:	78a3      	ldrb	r3, [r4, #2]
     ecc:	9303      	str	r3, [sp, #12]
     ece:	9702      	str	r7, [sp, #8]
     ed0:	9601      	str	r6, [sp, #4]
     ed2:	9500      	str	r5, [sp, #0]
     ed4:	4643      	mov	r3, r8
     ed6:	4d12      	ldr	r5, [pc, #72]	; (f20 <spi_main_loop+0x14c>)
     ed8:	47a8      	blx	r5
					update_super_servo(temp_receive[9] , temp_receive[10] , temp_receive[11], temp_receive[12]);
     eda:	7a60      	ldrb	r0, [r4, #9]
     edc:	b2c0      	uxtb	r0, r0
     ede:	7aa1      	ldrb	r1, [r4, #10]
     ee0:	b2c9      	uxtb	r1, r1
     ee2:	7ae2      	ldrb	r2, [r4, #11]
     ee4:	b2d2      	uxtb	r2, r2
     ee6:	7b23      	ldrb	r3, [r4, #12]
     ee8:	b2db      	uxtb	r3, r3
     eea:	4c0e      	ldr	r4, [pc, #56]	; (f24 <spi_main_loop+0x150>)
     eec:	47a0      	blx	r4
					break;
     eee:	e790      	b.n	e12 <spi_main_loop+0x3e>
					switch_off_ORB_LED();
     ef0:	4b0d      	ldr	r3, [pc, #52]	; (f28 <spi_main_loop+0x154>)
     ef2:	4798      	blx	r3
					switch_off_servos();
     ef4:	4b0d      	ldr	r3, [pc, #52]	; (f2c <spi_main_loop+0x158>)
     ef6:	4798      	blx	r3
					break;
     ef8:	e78b      	b.n	e12 <spi_main_loop+0x3e>
     efa:	46c0      	nop			; (mov r8, r8)
     efc:	20000338 	.word	0x20000338
     f00:	00000d59 	.word	0x00000d59
     f04:	200000f7 	.word	0x200000f7
     f08:	20000314 	.word	0x20000314
     f0c:	00000fd5 	.word	0x00000fd5
     f10:	00003b04 	.word	0x00003b04
     f14:	000019c9 	.word	0x000019c9
     f18:	00001971 	.word	0x00001971
     f1c:	00001ec9 	.word	0x00001ec9
     f20:	000018fd 	.word	0x000018fd
     f24:	00001db1 	.word	0x00001db1
     f28:	00001a1d 	.word	0x00001a1d
     f2c:	00001eb5 	.word	0x00001eb5

00000f30 <configure_spi_slave>:
/********************************************************************************************
SPI transfer Mode 0 
Pre-load is important it helps during a reset to have the sensor 0 and sensor 1 value loaded
********************************************************************************************/
void configure_spi_slave(void)
{
     f30:	b570      	push	{r4, r5, r6, lr}
     f32:	b08e      	sub	sp, #56	; 0x38
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
	config->data_order       = SPI_DATA_ORDER_MSB;
     f34:	2400      	movs	r4, #0
     f36:	9401      	str	r4, [sp, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
     f38:	9402      	str	r4, [sp, #8]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
     f3a:	23c0      	movs	r3, #192	; 0xc0
     f3c:	039b      	lsls	r3, r3, #14
     f3e:	9303      	str	r3, [sp, #12]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
     f40:	466b      	mov	r3, sp
     f42:	741c      	strb	r4, [r3, #16]
	config->run_in_standby   = false;
     f44:	745c      	strb	r4, [r3, #17]
	config->receiver_enable  = true;
     f46:	2501      	movs	r5, #1
     f48:	749d      	strb	r5, [r3, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
     f4a:	74dd      	strb	r5, [r3, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
     f4c:	751c      	strb	r4, [r3, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
     f4e:	2324      	movs	r3, #36	; 0x24
     f50:	466a      	mov	r2, sp
     f52:	54d4      	strb	r4, [r2, r3]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
     f54:	220c      	movs	r2, #12
     f56:	2100      	movs	r1, #0
     f58:	a806      	add	r0, sp, #24
     f5a:	4b14      	ldr	r3, [pc, #80]	; (fac <configure_spi_slave+0x7c>)
     f5c:	4798      	blx	r3
	struct spi_config config_spi_slave;
	/* Configure, initialize and enable SERCOM SPI module */
	spi_get_config_defaults(&config_spi_slave);
	config_spi_slave.transfer_mode = SPI_TRANSFER_MODE_0;
	config_spi_slave.mode = SPI_MODE_SLAVE;
     f5e:	466b      	mov	r3, sp
     f60:	701c      	strb	r4, [r3, #0]
	config_spi_slave.mode_specific.slave.preload_enable = true;
     f62:	2320      	movs	r3, #32
     f64:	466a      	mov	r2, sp
     f66:	54d5      	strb	r5, [r2, r3]
	config_spi_slave.mode_specific.slave.frame_format = SPI_FRAME_FORMAT_SPI_FRAME;
     f68:	9406      	str	r4, [sp, #24]
	config_spi_slave.mux_setting = SPI_SLAVE_MUX_SETTING;
	config_spi_slave.pinmux_pad0 = SPI_SLAVE_PINMUX_PAD0;
     f6a:	4b11      	ldr	r3, [pc, #68]	; (fb0 <configure_spi_slave+0x80>)
     f6c:	930a      	str	r3, [sp, #40]	; 0x28
	config_spi_slave.pinmux_pad1 = SPI_SLAVE_PINMUX_PAD1;
     f6e:	4b11      	ldr	r3, [pc, #68]	; (fb4 <configure_spi_slave+0x84>)
     f70:	930b      	str	r3, [sp, #44]	; 0x2c
	config_spi_slave.pinmux_pad2 = SPI_SLAVE_PINMUX_PAD2;
     f72:	4b11      	ldr	r3, [pc, #68]	; (fb8 <configure_spi_slave+0x88>)
     f74:	930c      	str	r3, [sp, #48]	; 0x30
	config_spi_slave.pinmux_pad3 = SPI_SLAVE_PINMUX_PAD3;
     f76:	4b11      	ldr	r3, [pc, #68]	; (fbc <configure_spi_slave+0x8c>)
     f78:	930d      	str	r3, [sp, #52]	; 0x34
	spi_init(&spi_slave_instance,  SLAVE_SPI_MODULE, &config_spi_slave);
     f7a:	4e11      	ldr	r6, [pc, #68]	; (fc0 <configure_spi_slave+0x90>)
     f7c:	4911      	ldr	r1, [pc, #68]	; (fc4 <configure_spi_slave+0x94>)
     f7e:	0030      	movs	r0, r6
     f80:	4b11      	ldr	r3, [pc, #68]	; (fc8 <configure_spi_slave+0x98>)
     f82:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     f84:	6834      	ldr	r4, [r6, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
     f86:	0020      	movs	r0, r4
     f88:	4b10      	ldr	r3, [pc, #64]	; (fcc <configure_spi_slave+0x9c>)
     f8a:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
     f8c:	231f      	movs	r3, #31
     f8e:	4018      	ands	r0, r3
     f90:	4085      	lsls	r5, r0
     f92:	4b0f      	ldr	r3, [pc, #60]	; (fd0 <configure_spi_slave+0xa0>)
     f94:	601d      	str	r5, [r3, #0]
	SercomSpi *const spi_module = &(module->hw->SPI);
     f96:	6832      	ldr	r2, [r6, #0]
	return (spi_module->SYNCBUSY.reg);
     f98:	69d3      	ldr	r3, [r2, #28]
#  endif

	while (spi_is_syncing(module)) {
     f9a:	2b00      	cmp	r3, #0
     f9c:	d1fc      	bne.n	f98 <configure_spi_slave+0x68>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
     f9e:	6823      	ldr	r3, [r4, #0]
     fa0:	2202      	movs	r2, #2
     fa2:	4313      	orrs	r3, r2
     fa4:	6023      	str	r3, [r4, #0]
	spi_enable(&spi_slave_instance);	
}
     fa6:	b00e      	add	sp, #56	; 0x38
     fa8:	bd70      	pop	{r4, r5, r6, pc}
     faa:	46c0      	nop			; (mov r8, r8)
     fac:	00003a0f 	.word	0x00003a0f
     fb0:	00160002 	.word	0x00160002
     fb4:	00170002 	.word	0x00170002
     fb8:	00180002 	.word	0x00180002
     fbc:	00190002 	.word	0x00190002
     fc0:	20000104 	.word	0x20000104
     fc4:	42000c00 	.word	0x42000c00
     fc8:	00000939 	.word	0x00000939
     fcc:	00002ba1 	.word	0x00002ba1
     fd0:	e000e100 	.word	0xe000e100

00000fd4 <check_buffer>:
/********************************************************************************************
Checks the ring buffer if there any new data in the buffer if it is present it will be 
transferred into the temp_receive global variable and we also look into the length of commands
********************************************************************************************/
void check_buffer()
{
     fd4:	b510      	push	{r4, lr}
	uint8_t i =0;
	if(tail_pointer == head_pointer)
     fd6:	4b1c      	ldr	r3, [pc, #112]	; (1048 <check_buffer+0x74>)
     fd8:	781b      	ldrb	r3, [r3, #0]
     fda:	4a1c      	ldr	r2, [pc, #112]	; (104c <check_buffer+0x78>)
     fdc:	7812      	ldrb	r2, [r2, #0]
     fde:	b2db      	uxtb	r3, r3
     fe0:	4293      	cmp	r3, r2
     fe2:	d018      	beq.n	1016 <check_buffer+0x42>
		head_pointer = 0;
	}
	else
	{
		//Transfer receive
		if(ring_buffer[tail_pointer] == 0xCA )
     fe4:	4b18      	ldr	r3, [pc, #96]	; (1048 <check_buffer+0x74>)
     fe6:	781b      	ldrb	r3, [r3, #0]
     fe8:	b2db      	uxtb	r3, r3
     fea:	4a19      	ldr	r2, [pc, #100]	; (1050 <check_buffer+0x7c>)
     fec:	5cd3      	ldrb	r3, [r2, r3]
     fee:	b2db      	uxtb	r3, r3
     ff0:	2200      	movs	r2, #0
     ff2:	2bca      	cmp	r3, #202	; 0xca
     ff4:	d017      	beq.n	1026 <check_buffer+0x52>
		}
		else
		{
			for(i=0; i<LENGTH_SINGLE;i++)
			{
				temp_receive[i] = ring_buffer[tail_pointer];
     ff6:	4914      	ldr	r1, [pc, #80]	; (1048 <check_buffer+0x74>)
     ff8:	4c15      	ldr	r4, [pc, #84]	; (1050 <check_buffer+0x7c>)
     ffa:	4816      	ldr	r0, [pc, #88]	; (1054 <check_buffer+0x80>)
     ffc:	780b      	ldrb	r3, [r1, #0]
     ffe:	b2db      	uxtb	r3, r3
    1000:	5ce3      	ldrb	r3, [r4, r3]
    1002:	b2db      	uxtb	r3, r3
    1004:	5483      	strb	r3, [r0, r2]
				tail_pointer++;
    1006:	780b      	ldrb	r3, [r1, #0]
    1008:	3301      	adds	r3, #1
    100a:	b2db      	uxtb	r3, r3
    100c:	700b      	strb	r3, [r1, #0]
    100e:	3201      	adds	r2, #1
			for(i=0; i<LENGTH_SINGLE;i++)
    1010:	2a04      	cmp	r2, #4
    1012:	d1f3      	bne.n	ffc <check_buffer+0x28>
			}
		}
	}

}
    1014:	bd10      	pop	{r4, pc}
		transfer_complete_spi_slave = false;
    1016:	2300      	movs	r3, #0
    1018:	4a0f      	ldr	r2, [pc, #60]	; (1058 <check_buffer+0x84>)
    101a:	7013      	strb	r3, [r2, #0]
		tail_pointer = 0;
    101c:	4a0a      	ldr	r2, [pc, #40]	; (1048 <check_buffer+0x74>)
    101e:	7013      	strb	r3, [r2, #0]
		head_pointer = 0;
    1020:	4a0a      	ldr	r2, [pc, #40]	; (104c <check_buffer+0x78>)
    1022:	7013      	strb	r3, [r2, #0]
    1024:	e7f6      	b.n	1014 <check_buffer+0x40>
				temp_receive[i] = ring_buffer[tail_pointer];
    1026:	4908      	ldr	r1, [pc, #32]	; (1048 <check_buffer+0x74>)
    1028:	4c09      	ldr	r4, [pc, #36]	; (1050 <check_buffer+0x7c>)
    102a:	480a      	ldr	r0, [pc, #40]	; (1054 <check_buffer+0x80>)
    102c:	780b      	ldrb	r3, [r1, #0]
    102e:	b2db      	uxtb	r3, r3
    1030:	5ce3      	ldrb	r3, [r4, r3]
    1032:	b2db      	uxtb	r3, r3
    1034:	5483      	strb	r3, [r0, r2]
				tail_pointer++;
    1036:	780b      	ldrb	r3, [r1, #0]
    1038:	3301      	adds	r3, #1
    103a:	b2db      	uxtb	r3, r3
    103c:	700b      	strb	r3, [r1, #0]
    103e:	3201      	adds	r2, #1
			for(i=0; i<LENGTH_SET_ALL;i++)
    1040:	2a0d      	cmp	r2, #13
    1042:	d1f3      	bne.n	102c <check_buffer+0x58>
    1044:	e7e6      	b.n	1014 <check_buffer+0x40>
    1046:	46c0      	nop			; (mov r8, r8)
    1048:	20000093 	.word	0x20000093
    104c:	20000091 	.word	0x20000091
    1050:	20000140 	.word	0x20000140
    1054:	20000314 	.word	0x20000314
    1058:	200000f7 	.word	0x200000f7

0000105c <configure_spi_slave_callbacks>:
}



void configure_spi_slave_callbacks(void)
{
    105c:	b510      	push	{r4, lr}
	spi_register_callback(&spi_slave_instance, spi_slave_callback,SPI_CALLBACK_BUFFER_TRANSCEIVED);
    105e:	4c06      	ldr	r4, [pc, #24]	; (1078 <configure_spi_slave_callbacks+0x1c>)
    1060:	2202      	movs	r2, #2
    1062:	4906      	ldr	r1, [pc, #24]	; (107c <configure_spi_slave_callbacks+0x20>)
    1064:	0020      	movs	r0, r4
    1066:	4b06      	ldr	r3, [pc, #24]	; (1080 <configure_spi_slave_callbacks+0x24>)
    1068:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);

	/* Enable callback */
	module->enabled_callback |= (1 << callback_type);
    106a:	2237      	movs	r2, #55	; 0x37
    106c:	5ca3      	ldrb	r3, [r4, r2]
    106e:	2104      	movs	r1, #4
    1070:	430b      	orrs	r3, r1
    1072:	54a3      	strb	r3, [r4, r2]
	spi_enable_callback(&spi_slave_instance, SPI_CALLBACK_BUFFER_TRANSCEIVED);
}
    1074:	bd10      	pop	{r4, pc}
    1076:	46c0      	nop			; (mov r8, r8)
    1078:	20000104 	.word	0x20000104
    107c:	000010e5 	.word	0x000010e5
    1080:	00000b4d 	.word	0x00000b4d

00001084 <spi_slave_init>:



void spi_slave_init()
{
    1084:	b5f0      	push	{r4, r5, r6, r7, lr}
    1086:	b083      	sub	sp, #12
	volatile enum status_code error_code = 0x10;
    1088:	2210      	movs	r2, #16
    108a:	466b      	mov	r3, sp
    108c:	71da      	strb	r2, [r3, #7]
	static bool init = false;
	const uint8_t firmware_version[4] = {0x00,0x00,DEVICE_ID_HARDWARE,DEVICE_ID_FIRMWARE};
	//Initial values are the firmware version
	configure_spi_slave();
    108e:	4b0e      	ldr	r3, [pc, #56]	; (10c8 <spi_slave_init+0x44>)
    1090:	4798      	blx	r3
	configure_spi_slave_callbacks();
    1092:	4b0e      	ldr	r3, [pc, #56]	; (10cc <spi_slave_init+0x48>)
    1094:	4798      	blx	r3
	if(init == false)
    1096:	4b0e      	ldr	r3, [pc, #56]	; (10d0 <spi_slave_init+0x4c>)
    1098:	781b      	ldrb	r3, [r3, #0]
    109a:	2b00      	cmp	r3, #0
    109c:	d111      	bne.n	10c2 <spi_slave_init+0x3e>
	{
		init = true;
    109e:	2201      	movs	r2, #1
    10a0:	4b0b      	ldr	r3, [pc, #44]	; (10d0 <spi_slave_init+0x4c>)
    10a2:	701a      	strb	r2, [r3, #0]
		do
		{
			error_code = spi_transceive_buffer_job(&spi_slave_instance, sensor_outputs, received_value,SPI_LENGTH);
    10a4:	4e0b      	ldr	r6, [pc, #44]	; (10d4 <spi_slave_init+0x50>)
    10a6:	4d0c      	ldr	r5, [pc, #48]	; (10d8 <spi_slave_init+0x54>)
    10a8:	4c0c      	ldr	r4, [pc, #48]	; (10dc <spi_slave_init+0x58>)
    10aa:	2304      	movs	r3, #4
    10ac:	0032      	movs	r2, r6
    10ae:	0029      	movs	r1, r5
    10b0:	0020      	movs	r0, r4
    10b2:	4f0b      	ldr	r7, [pc, #44]	; (10e0 <spi_slave_init+0x5c>)
    10b4:	47b8      	blx	r7
    10b6:	466b      	mov	r3, sp
    10b8:	71d8      	strb	r0, [r3, #7]
    10ba:	3307      	adds	r3, #7
		} while (error_code != STATUS_OK );
    10bc:	781b      	ldrb	r3, [r3, #0]
    10be:	2b00      	cmp	r3, #0
    10c0:	d1f3      	bne.n	10aa <spi_slave_init+0x26>
		
	}
	
}
    10c2:	b003      	add	sp, #12
    10c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    10c6:	46c0      	nop			; (mov r8, r8)
    10c8:	00000f31 	.word	0x00000f31
    10cc:	0000105d 	.word	0x0000105d
    10d0:	20000092 	.word	0x20000092
    10d4:	200002e4 	.word	0x200002e4
    10d8:	200002f8 	.word	0x200002f8
    10dc:	20000104 	.word	0x20000104
    10e0:	00000b65 	.word	0x00000b65

000010e4 <spi_slave_callback>:
{
    10e4:	b570      	push	{r4, r5, r6, lr}
	transfer_complete_spi_slave = true;
    10e6:	2201      	movs	r2, #1
    10e8:	4b21      	ldr	r3, [pc, #132]	; (1170 <spi_slave_callback+0x8c>)
    10ea:	701a      	strb	r2, [r3, #0]
	serial_timeout_count = 0;
    10ec:	2200      	movs	r2, #0
    10ee:	4b21      	ldr	r3, [pc, #132]	; (1174 <spi_slave_callback+0x90>)
    10f0:	701a      	strb	r2, [r3, #0]
	if(spi_reset_1 == true )
    10f2:	4b21      	ldr	r3, [pc, #132]	; (1178 <spi_slave_callback+0x94>)
    10f4:	781b      	ldrb	r3, [r3, #0]
    10f6:	2b00      	cmp	r3, #0
    10f8:	d11b      	bne.n	1132 <spi_slave_callback+0x4e>
		if(received_value[0] == 0xCA)
    10fa:	4b20      	ldr	r3, [pc, #128]	; (117c <spi_slave_callback+0x98>)
    10fc:	781b      	ldrb	r3, [r3, #0]
    10fe:	b2db      	uxtb	r3, r3
    1100:	2200      	movs	r2, #0
    1102:	2bca      	cmp	r3, #202	; 0xca
    1104:	d024      	beq.n	1150 <spi_slave_callback+0x6c>
				ring_buffer[head_pointer] = received_value[i];
    1106:	481e      	ldr	r0, [pc, #120]	; (1180 <spi_slave_callback+0x9c>)
    1108:	4d1c      	ldr	r5, [pc, #112]	; (117c <spi_slave_callback+0x98>)
    110a:	4c1e      	ldr	r4, [pc, #120]	; (1184 <spi_slave_callback+0xa0>)
    110c:	7803      	ldrb	r3, [r0, #0]
    110e:	b2db      	uxtb	r3, r3
    1110:	5ca9      	ldrb	r1, [r5, r2]
    1112:	b2c9      	uxtb	r1, r1
    1114:	54e1      	strb	r1, [r4, r3]
				head_pointer++;
    1116:	7803      	ldrb	r3, [r0, #0]
    1118:	3301      	adds	r3, #1
    111a:	b2db      	uxtb	r3, r3
    111c:	7003      	strb	r3, [r0, #0]
    111e:	3201      	adds	r2, #1
			for(i=0 ; i<LENGTH_SINGLE;i++)
    1120:	2a04      	cmp	r2, #4
    1122:	d1f3      	bne.n	110c <spi_slave_callback+0x28>
		spi_transceive_buffer_job(&spi_slave_instance, sensor_outputs, received_value,SPI_LENGTH);
    1124:	2304      	movs	r3, #4
    1126:	4a15      	ldr	r2, [pc, #84]	; (117c <spi_slave_callback+0x98>)
    1128:	4917      	ldr	r1, [pc, #92]	; (1188 <spi_slave_callback+0xa4>)
    112a:	4818      	ldr	r0, [pc, #96]	; (118c <spi_slave_callback+0xa8>)
    112c:	4c18      	ldr	r4, [pc, #96]	; (1190 <spi_slave_callback+0xac>)
    112e:	47a0      	blx	r4
}
    1130:	bd70      	pop	{r4, r5, r6, pc}
		spi_reset_1 = false;
    1132:	4b11      	ldr	r3, [pc, #68]	; (1178 <spi_slave_callback+0x94>)
    1134:	701a      	strb	r2, [r3, #0]
		spi_reset(&spi_slave_instance);
    1136:	4c15      	ldr	r4, [pc, #84]	; (118c <spi_slave_callback+0xa8>)
    1138:	0020      	movs	r0, r4
    113a:	4b16      	ldr	r3, [pc, #88]	; (1194 <spi_slave_callback+0xb0>)
    113c:	4798      	blx	r3
		spi_slave_init();
    113e:	4b16      	ldr	r3, [pc, #88]	; (1198 <spi_slave_callback+0xb4>)
    1140:	4798      	blx	r3
		spi_transceive_buffer_job(&spi_slave_instance, sensor_outputs, received_value,SPI_LENGTH);
    1142:	2304      	movs	r3, #4
    1144:	4a0d      	ldr	r2, [pc, #52]	; (117c <spi_slave_callback+0x98>)
    1146:	4910      	ldr	r1, [pc, #64]	; (1188 <spi_slave_callback+0xa4>)
    1148:	0020      	movs	r0, r4
    114a:	4c11      	ldr	r4, [pc, #68]	; (1190 <spi_slave_callback+0xac>)
    114c:	47a0      	blx	r4
    114e:	e7ef      	b.n	1130 <spi_slave_callback+0x4c>
				ring_buffer[head_pointer] = received_value[i];
    1150:	480b      	ldr	r0, [pc, #44]	; (1180 <spi_slave_callback+0x9c>)
    1152:	4d0a      	ldr	r5, [pc, #40]	; (117c <spi_slave_callback+0x98>)
    1154:	4c0b      	ldr	r4, [pc, #44]	; (1184 <spi_slave_callback+0xa0>)
    1156:	7803      	ldrb	r3, [r0, #0]
    1158:	b2db      	uxtb	r3, r3
    115a:	5ca9      	ldrb	r1, [r5, r2]
    115c:	b2c9      	uxtb	r1, r1
    115e:	54e1      	strb	r1, [r4, r3]
				head_pointer++;
    1160:	7803      	ldrb	r3, [r0, #0]
    1162:	3301      	adds	r3, #1
    1164:	b2db      	uxtb	r3, r3
    1166:	7003      	strb	r3, [r0, #0]
    1168:	3201      	adds	r2, #1
			for(i=0; i<LENGTH_SET_ALL;i++)
    116a:	2a0d      	cmp	r2, #13
    116c:	d1f3      	bne.n	1156 <spi_slave_callback+0x72>
    116e:	e7d9      	b.n	1124 <spi_slave_callback+0x40>
    1170:	200000f7 	.word	0x200000f7
    1174:	200000f4 	.word	0x200000f4
    1178:	200000f5 	.word	0x200000f5
    117c:	200002e4 	.word	0x200002e4
    1180:	20000091 	.word	0x20000091
    1184:	20000140 	.word	0x20000140
    1188:	200002f8 	.word	0x200002f8
    118c:	20000104 	.word	0x20000104
    1190:	00000b65 	.word	0x00000b65
    1194:	000008ed 	.word	0x000008ed
    1198:	00001085 	.word	0x00001085

0000119c <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
    119c:	b570      	push	{r4, r5, r6, lr}
	cycles_per_ms = system_gclk_gen_get_hz(0);
    119e:	2000      	movs	r0, #0
    11a0:	4b08      	ldr	r3, [pc, #32]	; (11c4 <delay_init+0x28>)
    11a2:	4798      	blx	r3
    11a4:	0005      	movs	r5, r0
	cycles_per_ms /= 1000;
    11a6:	4c08      	ldr	r4, [pc, #32]	; (11c8 <delay_init+0x2c>)
    11a8:	21fa      	movs	r1, #250	; 0xfa
    11aa:	0089      	lsls	r1, r1, #2
    11ac:	47a0      	blx	r4
    11ae:	4b07      	ldr	r3, [pc, #28]	; (11cc <delay_init+0x30>)
    11b0:	6018      	str	r0, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
    11b2:	4907      	ldr	r1, [pc, #28]	; (11d0 <delay_init+0x34>)
    11b4:	0028      	movs	r0, r5
    11b6:	47a0      	blx	r4
    11b8:	4b06      	ldr	r3, [pc, #24]	; (11d4 <delay_init+0x38>)
    11ba:	6018      	str	r0, [r3, #0]

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
    11bc:	2205      	movs	r2, #5
    11be:	4b06      	ldr	r3, [pc, #24]	; (11d8 <delay_init+0x3c>)
    11c0:	601a      	str	r2, [r3, #0]
}
    11c2:	bd70      	pop	{r4, r5, r6, pc}
    11c4:	000032b5 	.word	0x000032b5
    11c8:	000036b5 	.word	0x000036b5
    11cc:	20000000 	.word	0x20000000
    11d0:	000f4240 	.word	0x000f4240
    11d4:	20000004 	.word	0x20000004
    11d8:	e000e010 	.word	0xe000e010

000011dc <adc_get_config_defaults>:
 *
 * \param[out] config  Pointer to configuration struct to initialize to
 *                     default values
 */
void adc_get_config_defaults(struct adc_config *const config)
{
    11dc:	b510      	push	{r4, lr}
	Assert(config);
	config->clock_source                  = GCLK_GENERATOR_0;
    11de:	2200      	movs	r2, #0
    11e0:	2300      	movs	r3, #0
    11e2:	7002      	strb	r2, [r0, #0]
	config->reference                     = ADC_REFERENCE_INT1V;
    11e4:	7042      	strb	r2, [r0, #1]
	config->clock_prescaler               = ADC_CLOCK_PRESCALER_DIV4;
    11e6:	2100      	movs	r1, #0
    11e8:	8042      	strh	r2, [r0, #2]
	config->resolution                    = ADC_RESOLUTION_12BIT;
    11ea:	7101      	strb	r1, [r0, #4]
	config->window.window_mode            = ADC_WINDOW_MODE_DISABLE;
    11ec:	7603      	strb	r3, [r0, #24]
	config->window.window_upper_value     = 0;
    11ee:	6202      	str	r2, [r0, #32]
	config->window.window_lower_value     = 0;
    11f0:	61c2      	str	r2, [r0, #28]
	config->gain_factor                   = ADC_GAIN_FACTOR_1X;
    11f2:	6082      	str	r2, [r0, #8]
#if SAMR21
	config->positive_input                = ADC_POSITIVE_INPUT_PIN6 ;
#else
 	config->positive_input                = ADC_POSITIVE_INPUT_PIN0 ;
    11f4:	7303      	strb	r3, [r0, #12]
#endif
	config->negative_input                = ADC_NEGATIVE_INPUT_GND ;
    11f6:	24c0      	movs	r4, #192	; 0xc0
    11f8:	0164      	lsls	r4, r4, #5
    11fa:	81c4      	strh	r4, [r0, #14]
	config->accumulate_samples            = ADC_ACCUMULATE_DISABLE;
    11fc:	7403      	strb	r3, [r0, #16]
	config->divide_result                 = ADC_DIVIDE_RESULT_DISABLE;
    11fe:	7443      	strb	r3, [r0, #17]
	config->left_adjust                   = false;
    1200:	7483      	strb	r3, [r0, #18]
	config->differential_mode             = false;
    1202:	74c3      	strb	r3, [r0, #19]
	config->freerunning                   = false;
    1204:	7503      	strb	r3, [r0, #20]
	config->event_action                  = ADC_EVENT_ACTION_DISABLED;
    1206:	242a      	movs	r4, #42	; 0x2a
    1208:	5503      	strb	r3, [r0, r4]
	config->run_in_standby                = false;
    120a:	7543      	strb	r3, [r0, #21]
	config->reference_compensation_enable = false;
    120c:	7583      	strb	r3, [r0, #22]
	config->correction.correction_enable  = false;
    120e:	3c06      	subs	r4, #6
    1210:	5503      	strb	r3, [r0, r4]
	config->correction.gain_correction    = ADC_GAINCORR_RESETVALUE;
    1212:	84c2      	strh	r2, [r0, #38]	; 0x26
	config->correction.offset_correction  = ADC_OFFSETCORR_RESETVALUE;
    1214:	8502      	strh	r2, [r0, #40]	; 0x28
	config->sample_length                 = 0;
    1216:	75c1      	strb	r1, [r0, #23]
	config->pin_scan.offset_start_scan    = 0;
    1218:	232b      	movs	r3, #43	; 0x2b
    121a:	54c1      	strb	r1, [r0, r3]
	config->pin_scan.inputs_to_scan       = 0;
    121c:	3301      	adds	r3, #1
    121e:	54c1      	strb	r1, [r0, r3]
}
    1220:	bd10      	pop	{r4, pc}
	...

00001224 <adc_init>:
 */
enum status_code adc_init(
		struct adc_module *const module_inst,
		Adc *hw,
		struct adc_config *config)
{
    1224:	b5f0      	push	{r4, r5, r6, r7, lr}
    1226:	46d6      	mov	lr, sl
    1228:	464f      	mov	r7, r9
    122a:	4646      	mov	r6, r8
    122c:	b5c0      	push	{r6, r7, lr}
    122e:	b096      	sub	sp, #88	; 0x58
    1230:	0007      	movs	r7, r0
    1232:	0016      	movs	r6, r2
	Assert(module_inst);
	Assert(hw);
	Assert(config);

	/* Associate the software module instance with the hardware module */
	module_inst->hw = hw;
    1234:	6001      	str	r1, [r0, #0]
    1236:	4ac6      	ldr	r2, [pc, #792]	; (1550 <adc_init+0x32c>)
    1238:	6a10      	ldr	r0, [r2, #32]
    123a:	2380      	movs	r3, #128	; 0x80
    123c:	005b      	lsls	r3, r3, #1
    123e:	4303      	orrs	r3, r0
    1240:	6213      	str	r3, [r2, #32]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, PM_APBCMASK_ADC);

	if (hw->CTRLA.reg & ADC_CTRLA_SWRST) {
    1242:	780b      	ldrb	r3, [r1, #0]
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
    1244:	2005      	movs	r0, #5
	if (hw->CTRLA.reg & ADC_CTRLA_SWRST) {
    1246:	07db      	lsls	r3, r3, #31
    1248:	d505      	bpl.n	1256 <adc_init+0x32>
	}
#endif

	/* Write configuration to module */
	return _adc_set_config(module_inst, config);
}
    124a:	b016      	add	sp, #88	; 0x58
    124c:	bc1c      	pop	{r2, r3, r4}
    124e:	4690      	mov	r8, r2
    1250:	4699      	mov	r9, r3
    1252:	46a2      	mov	sl, r4
    1254:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (hw->CTRLA.reg & ADC_CTRLA_ENABLE) {
    1256:	780b      	ldrb	r3, [r1, #0]
		return STATUS_ERR_DENIED;
    1258:	3017      	adds	r0, #23
	if (hw->CTRLA.reg & ADC_CTRLA_ENABLE) {
    125a:	079b      	lsls	r3, r3, #30
    125c:	d4f5      	bmi.n	124a <adc_init+0x26>
	module_inst->reference = config->reference;
    125e:	7873      	ldrb	r3, [r6, #1]
    1260:	713b      	strb	r3, [r7, #4]
	if (module_inst->reference == ADC_REFERENCE_INT1V) {
    1262:	2b00      	cmp	r3, #0
    1264:	d104      	bne.n	1270 <adc_init+0x4c>
		case SYSTEM_VOLTAGE_REFERENCE_TEMPSENSE:
			SYSCTRL->VREF.reg |= SYSCTRL_VREF_TSEN;
			break;

		case SYSTEM_VOLTAGE_REFERENCE_BANDGAP:
			SYSCTRL->VREF.reg |= SYSCTRL_VREF_BGOUTEN;
    1266:	4abb      	ldr	r2, [pc, #748]	; (1554 <adc_init+0x330>)
    1268:	6c13      	ldr	r3, [r2, #64]	; 0x40
    126a:	2104      	movs	r1, #4
    126c:	430b      	orrs	r3, r1
    126e:	6413      	str	r3, [r2, #64]	; 0x40
		module_inst->callback[i] = NULL;
    1270:	2300      	movs	r3, #0
    1272:	60bb      	str	r3, [r7, #8]
    1274:	60fb      	str	r3, [r7, #12]
    1276:	613b      	str	r3, [r7, #16]
	module_inst->registered_callback_mask = 0;
    1278:	76bb      	strb	r3, [r7, #26]
	module_inst->enabled_callback_mask = 0;
    127a:	76fb      	strb	r3, [r7, #27]
	module_inst->remaining_conversions = 0;
    127c:	833b      	strh	r3, [r7, #24]
	module_inst->job_status = STATUS_OK;
    127e:	773b      	strb	r3, [r7, #28]
	_adc_instances[0] = module_inst;
    1280:	4bb5      	ldr	r3, [pc, #724]	; (1558 <adc_init+0x334>)
    1282:	601f      	str	r7, [r3, #0]
	if (config->event_action == ADC_EVENT_ACTION_DISABLED &&
    1284:	232a      	movs	r3, #42	; 0x2a
    1286:	5cf3      	ldrb	r3, [r6, r3]
    1288:	2b00      	cmp	r3, #0
    128a:	d105      	bne.n	1298 <adc_init+0x74>
    128c:	7d33      	ldrb	r3, [r6, #20]
    128e:	2b00      	cmp	r3, #0
    1290:	d102      	bne.n	1298 <adc_init+0x74>
		module_inst->software_trigger = true;
    1292:	3301      	adds	r3, #1
    1294:	777b      	strb	r3, [r7, #29]
    1296:	e001      	b.n	129c <adc_init+0x78>
		module_inst->software_trigger = false;
    1298:	2300      	movs	r3, #0
    129a:	777b      	strb	r3, [r7, #29]
	Adc *const adc_module = module_inst->hw;
    129c:	683b      	ldr	r3, [r7, #0]
    129e:	4698      	mov	r8, r3
	gclk_chan_conf.source_generator = config->clock_source;
    12a0:	7833      	ldrb	r3, [r6, #0]
    12a2:	466a      	mov	r2, sp
    12a4:	7013      	strb	r3, [r2, #0]
	system_gclk_chan_set_config(ADC_GCLK_ID, &gclk_chan_conf);
    12a6:	4669      	mov	r1, sp
    12a8:	2013      	movs	r0, #19
    12aa:	4bac      	ldr	r3, [pc, #688]	; (155c <adc_init+0x338>)
    12ac:	4798      	blx	r3
	system_gclk_chan_enable(ADC_GCLK_ID);
    12ae:	2013      	movs	r0, #19
    12b0:	4bab      	ldr	r3, [pc, #684]	; (1560 <adc_init+0x33c>)
    12b2:	4798      	blx	r3
	if (config->pin_scan.inputs_to_scan != 0) {
    12b4:	232c      	movs	r3, #44	; 0x2c
    12b6:	5cf2      	ldrb	r2, [r6, r3]
    12b8:	2a00      	cmp	r2, #0
    12ba:	d054      	beq.n	1366 <adc_init+0x142>
		uint8_t offset = config->pin_scan.offset_start_scan;
    12bc:	3b01      	subs	r3, #1
    12be:	5cf5      	ldrb	r5, [r6, r3]
		uint8_t start_pin =
    12c0:	7b33      	ldrb	r3, [r6, #12]
    12c2:	18eb      	adds	r3, r5, r3
    12c4:	b2db      	uxtb	r3, r3
		uint8_t end_pin =
    12c6:	18d1      	adds	r1, r2, r3
		while (start_pin < end_pin) {
    12c8:	b2c9      	uxtb	r1, r1
    12ca:	428b      	cmp	r3, r1
    12cc:	d221      	bcs.n	1312 <adc_init+0xee>
    12ce:	1952      	adds	r2, r2, r5
    12d0:	b2d3      	uxtb	r3, r2
    12d2:	4699      	mov	r9, r3
	const uint32_t pinmapping[] = {
    12d4:	4ba3      	ldr	r3, [pc, #652]	; (1564 <adc_init+0x340>)
    12d6:	469a      	mov	sl, r3
    12d8:	e003      	b.n	12e2 <adc_init+0xbe>
			offset++;
    12da:	3501      	adds	r5, #1
    12dc:	b2ed      	uxtb	r5, r5
		while (start_pin < end_pin) {
    12de:	454d      	cmp	r5, r9
    12e0:	d017      	beq.n	1312 <adc_init+0xee>
			_adc_configure_ain_pin((offset % 16)+(uint8_t)config->positive_input);
    12e2:	240f      	movs	r4, #15
    12e4:	402c      	ands	r4, r5
    12e6:	7b33      	ldrb	r3, [r6, #12]
    12e8:	18e4      	adds	r4, r4, r3
	const uint32_t pinmapping[] = {
    12ea:	2250      	movs	r2, #80	; 0x50
    12ec:	499e      	ldr	r1, [pc, #632]	; (1568 <adc_init+0x344>)
    12ee:	a802      	add	r0, sp, #8
    12f0:	47d0      	blx	sl
	if (pin <= ADC_EXTCHANNEL_MSB) {
    12f2:	2c09      	cmp	r4, #9
    12f4:	d8f1      	bhi.n	12da <adc_init+0xb6>
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    12f6:	00a4      	lsls	r4, r4, #2
    12f8:	ab02      	add	r3, sp, #8
    12fa:	58e0      	ldr	r0, [r4, r3]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    12fc:	a901      	add	r1, sp, #4
    12fe:	2300      	movs	r3, #0
    1300:	704b      	strb	r3, [r1, #1]
	config->powersave    = false;
    1302:	70cb      	strb	r3, [r1, #3]
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    1304:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    1306:	3301      	adds	r3, #1
    1308:	700b      	strb	r3, [r1, #0]
		system_pinmux_pin_set_config(pin_map_result, &config);
    130a:	b2c0      	uxtb	r0, r0
    130c:	4b97      	ldr	r3, [pc, #604]	; (156c <adc_init+0x348>)
    130e:	4798      	blx	r3
    1310:	e7e3      	b.n	12da <adc_init+0xb6>
		_adc_configure_ain_pin(config->negative_input);
    1312:	89f4      	ldrh	r4, [r6, #14]
	const uint32_t pinmapping[] = {
    1314:	2250      	movs	r2, #80	; 0x50
    1316:	4994      	ldr	r1, [pc, #592]	; (1568 <adc_init+0x344>)
    1318:	a802      	add	r0, sp, #8
    131a:	4b92      	ldr	r3, [pc, #584]	; (1564 <adc_init+0x340>)
    131c:	4798      	blx	r3
	if (pin <= ADC_EXTCHANNEL_MSB) {
    131e:	2c09      	cmp	r4, #9
    1320:	d913      	bls.n	134a <adc_init+0x126>
	adc_module->CTRLA.reg = (config->run_in_standby << ADC_CTRLA_RUNSTDBY_Pos);
    1322:	7d73      	ldrb	r3, [r6, #21]
    1324:	009b      	lsls	r3, r3, #2
    1326:	b2db      	uxtb	r3, r3
    1328:	4642      	mov	r2, r8
    132a:	7013      	strb	r3, [r2, #0]
			(config->reference_compensation_enable << ADC_REFCTRL_REFCOMP_Pos) |
    132c:	7db3      	ldrb	r3, [r6, #22]
    132e:	01db      	lsls	r3, r3, #7
    1330:	7872      	ldrb	r2, [r6, #1]
    1332:	4313      	orrs	r3, r2
    1334:	b2db      	uxtb	r3, r3
	adc_module->REFCTRL.reg =
    1336:	4642      	mov	r2, r8
    1338:	7053      	strb	r3, [r2, #1]
	switch (config->resolution) {
    133a:	7933      	ldrb	r3, [r6, #4]
    133c:	2b34      	cmp	r3, #52	; 0x34
    133e:	d900      	bls.n	1342 <adc_init+0x11e>
    1340:	e17b      	b.n	163a <adc_init+0x416>
    1342:	009b      	lsls	r3, r3, #2
    1344:	4a8a      	ldr	r2, [pc, #552]	; (1570 <adc_init+0x34c>)
    1346:	58d3      	ldr	r3, [r2, r3]
    1348:	469f      	mov	pc, r3
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    134a:	00a4      	lsls	r4, r4, #2
    134c:	ab02      	add	r3, sp, #8
    134e:	58e0      	ldr	r0, [r4, r3]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    1350:	a901      	add	r1, sp, #4
    1352:	2300      	movs	r3, #0
    1354:	704b      	strb	r3, [r1, #1]
	config->powersave    = false;
    1356:	70cb      	strb	r3, [r1, #3]
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    1358:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    135a:	3301      	adds	r3, #1
    135c:	700b      	strb	r3, [r1, #0]
		system_pinmux_pin_set_config(pin_map_result, &config);
    135e:	b2c0      	uxtb	r0, r0
    1360:	4b82      	ldr	r3, [pc, #520]	; (156c <adc_init+0x348>)
    1362:	4798      	blx	r3
    1364:	e7dd      	b.n	1322 <adc_init+0xfe>
		_adc_configure_ain_pin(config->positive_input);
    1366:	7b34      	ldrb	r4, [r6, #12]
	const uint32_t pinmapping[] = {
    1368:	2250      	movs	r2, #80	; 0x50
    136a:	497f      	ldr	r1, [pc, #508]	; (1568 <adc_init+0x344>)
    136c:	a802      	add	r0, sp, #8
    136e:	4b7d      	ldr	r3, [pc, #500]	; (1564 <adc_init+0x340>)
    1370:	4798      	blx	r3
	if (pin <= ADC_EXTCHANNEL_MSB) {
    1372:	2c09      	cmp	r4, #9
    1374:	d915      	bls.n	13a2 <adc_init+0x17e>
		_adc_configure_ain_pin(config->negative_input);
    1376:	89f4      	ldrh	r4, [r6, #14]
	const uint32_t pinmapping[] = {
    1378:	2250      	movs	r2, #80	; 0x50
    137a:	497b      	ldr	r1, [pc, #492]	; (1568 <adc_init+0x344>)
    137c:	a802      	add	r0, sp, #8
    137e:	4b79      	ldr	r3, [pc, #484]	; (1564 <adc_init+0x340>)
    1380:	4798      	blx	r3
	if (pin <= ADC_EXTCHANNEL_MSB) {
    1382:	2c09      	cmp	r4, #9
    1384:	d8cd      	bhi.n	1322 <adc_init+0xfe>
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    1386:	00a4      	lsls	r4, r4, #2
    1388:	ab02      	add	r3, sp, #8
    138a:	58e0      	ldr	r0, [r4, r3]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    138c:	a901      	add	r1, sp, #4
    138e:	2300      	movs	r3, #0
    1390:	704b      	strb	r3, [r1, #1]
	config->powersave    = false;
    1392:	70cb      	strb	r3, [r1, #3]
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    1394:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    1396:	3301      	adds	r3, #1
    1398:	700b      	strb	r3, [r1, #0]
		system_pinmux_pin_set_config(pin_map_result, &config);
    139a:	b2c0      	uxtb	r0, r0
    139c:	4b73      	ldr	r3, [pc, #460]	; (156c <adc_init+0x348>)
    139e:	4798      	blx	r3
    13a0:	e7bf      	b.n	1322 <adc_init+0xfe>
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    13a2:	00a4      	lsls	r4, r4, #2
    13a4:	ab02      	add	r3, sp, #8
    13a6:	58e0      	ldr	r0, [r4, r3]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    13a8:	a901      	add	r1, sp, #4
    13aa:	2300      	movs	r3, #0
    13ac:	704b      	strb	r3, [r1, #1]
	config->powersave    = false;
    13ae:	70cb      	strb	r3, [r1, #3]
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    13b0:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    13b2:	3301      	adds	r3, #1
    13b4:	700b      	strb	r3, [r1, #0]
		system_pinmux_pin_set_config(pin_map_result, &config);
    13b6:	b2c0      	uxtb	r0, r0
    13b8:	4b6c      	ldr	r3, [pc, #432]	; (156c <adc_init+0x348>)
    13ba:	4798      	blx	r3
    13bc:	e7db      	b.n	1376 <adc_init+0x152>
		accumulate = ADC_ACCUMULATE_SAMPLES_16;
    13be:	2304      	movs	r3, #4
		resolution = ADC_RESOLUTION_16BIT;
    13c0:	2410      	movs	r4, #16
		adjres = ADC_DIVIDE_RESULT_4;
    13c2:	2102      	movs	r1, #2
    13c4:	e01a      	b.n	13fc <adc_init+0x1d8>
		adjres = config->divide_result;
    13c6:	7c71      	ldrb	r1, [r6, #17]
		accumulate = config->accumulate_samples;
    13c8:	7c33      	ldrb	r3, [r6, #16]
		resolution = ADC_RESOLUTION_16BIT;
    13ca:	2410      	movs	r4, #16
    13cc:	e016      	b.n	13fc <adc_init+0x1d8>
		accumulate = ADC_ACCUMULATE_SAMPLES_64;
    13ce:	2306      	movs	r3, #6
		resolution = ADC_RESOLUTION_16BIT;
    13d0:	2410      	movs	r4, #16
		adjres = ADC_DIVIDE_RESULT_2;
    13d2:	2101      	movs	r1, #1
    13d4:	e012      	b.n	13fc <adc_init+0x1d8>
		accumulate = ADC_ACCUMULATE_SAMPLES_256;
    13d6:	2308      	movs	r3, #8
		resolution = ADC_RESOLUTION_16BIT;
    13d8:	2410      	movs	r4, #16
		adjres = ADC_DIVIDE_RESULT_DISABLE;
    13da:	2100      	movs	r1, #0
    13dc:	e00e      	b.n	13fc <adc_init+0x1d8>
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;
    13de:	2300      	movs	r3, #0
		resolution = ADC_RESOLUTION_8BIT;
    13e0:	2430      	movs	r4, #48	; 0x30
	uint8_t adjres = 0;
    13e2:	2100      	movs	r1, #0
    13e4:	e00a      	b.n	13fc <adc_init+0x1d8>
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;
    13e6:	2300      	movs	r3, #0
		resolution = ADC_RESOLUTION_10BIT;
    13e8:	2420      	movs	r4, #32
	uint8_t adjres = 0;
    13ea:	2100      	movs	r1, #0
    13ec:	e006      	b.n	13fc <adc_init+0x1d8>
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;
    13ee:	2300      	movs	r3, #0
		resolution = ADC_RESOLUTION_12BIT;
    13f0:	2400      	movs	r4, #0
	uint8_t adjres = 0;
    13f2:	2100      	movs	r1, #0
    13f4:	e002      	b.n	13fc <adc_init+0x1d8>
		accumulate = ADC_ACCUMULATE_SAMPLES_4;
    13f6:	2302      	movs	r3, #2
		resolution = ADC_RESOLUTION_16BIT;
    13f8:	2410      	movs	r4, #16
		adjres = ADC_DIVIDE_RESULT_2;
    13fa:	2101      	movs	r1, #1
	adc_module->AVGCTRL.reg = ADC_AVGCTRL_ADJRES(adjres) | accumulate;
    13fc:	0109      	lsls	r1, r1, #4
    13fe:	2270      	movs	r2, #112	; 0x70
    1400:	400a      	ands	r2, r1
    1402:	4313      	orrs	r3, r2
    1404:	4642      	mov	r2, r8
    1406:	7093      	strb	r3, [r2, #2]
	if (config->sample_length > 63) {
    1408:	7df3      	ldrb	r3, [r6, #23]
		return STATUS_ERR_INVALID_ARG;
    140a:	2017      	movs	r0, #23
	if (config->sample_length > 63) {
    140c:	2b3f      	cmp	r3, #63	; 0x3f
    140e:	d900      	bls.n	1412 <adc_init+0x1ee>
    1410:	e71b      	b.n	124a <adc_init+0x26>
		adc_module->SAMPCTRL.reg =
    1412:	70d3      	strb	r3, [r2, #3]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    1414:	683a      	ldr	r2, [r7, #0]

	if (adc_module->STATUS.reg & ADC_STATUS_SYNCBUSY) {
    1416:	7e53      	ldrb	r3, [r2, #25]
	while (adc_is_syncing(module_inst)) {
    1418:	b25b      	sxtb	r3, r3
    141a:	2b00      	cmp	r3, #0
    141c:	dbfb      	blt.n	1416 <adc_init+0x1f2>
			(config->differential_mode << ADC_CTRLB_DIFFMODE_Pos);
    141e:	7cf3      	ldrb	r3, [r6, #19]
			(config->left_adjust << ADC_CTRLB_LEFTADJ_Pos) |
    1420:	8872      	ldrh	r2, [r6, #2]
    1422:	4313      	orrs	r3, r2
			(config->correction.correction_enable << ADC_CTRLB_CORREN_Pos) |
    1424:	2224      	movs	r2, #36	; 0x24
    1426:	5cb2      	ldrb	r2, [r6, r2]
    1428:	00d2      	lsls	r2, r2, #3
			(config->left_adjust << ADC_CTRLB_LEFTADJ_Pos) |
    142a:	4313      	orrs	r3, r2
			(config->freerunning << ADC_CTRLB_FREERUN_Pos) |
    142c:	7d32      	ldrb	r2, [r6, #20]
    142e:	0092      	lsls	r2, r2, #2
			(config->left_adjust << ADC_CTRLB_LEFTADJ_Pos) |
    1430:	4313      	orrs	r3, r2
    1432:	7cb2      	ldrb	r2, [r6, #18]
    1434:	0052      	lsls	r2, r2, #1
    1436:	4313      	orrs	r3, r2
    1438:	4323      	orrs	r3, r4
	adc_module->CTRLB.reg =
    143a:	4642      	mov	r2, r8
    143c:	8093      	strh	r3, [r2, #4]
	if (config->window.window_mode != ADC_WINDOW_MODE_DISABLE) {
    143e:	7e33      	ldrb	r3, [r6, #24]
    1440:	2b00      	cmp	r3, #0
    1442:	d020      	beq.n	1486 <adc_init+0x262>
		switch (resolution) {
    1444:	2c10      	cmp	r4, #16
    1446:	d100      	bne.n	144a <adc_init+0x226>
    1448:	e0d9      	b.n	15fe <adc_init+0x3da>
    144a:	d800      	bhi.n	144e <adc_init+0x22a>
    144c:	e098      	b.n	1580 <adc_init+0x35c>
    144e:	2c20      	cmp	r4, #32
    1450:	d100      	bne.n	1454 <adc_init+0x230>
    1452:	e0b6      	b.n	15c2 <adc_init+0x39e>
    1454:	2c30      	cmp	r4, #48	; 0x30
    1456:	d116      	bne.n	1486 <adc_init+0x262>
			if (config->differential_mode &&
    1458:	7cf2      	ldrb	r2, [r6, #19]
    145a:	2a00      	cmp	r2, #0
    145c:	d00a      	beq.n	1474 <adc_init+0x250>
					(config->window.window_lower_value > 127 ||
    145e:	69f2      	ldr	r2, [r6, #28]
    1460:	3280      	adds	r2, #128	; 0x80
				return STATUS_ERR_INVALID_ARG;
    1462:	2017      	movs	r0, #23
			if (config->differential_mode &&
    1464:	2aff      	cmp	r2, #255	; 0xff
    1466:	d900      	bls.n	146a <adc_init+0x246>
    1468:	e6ef      	b.n	124a <adc_init+0x26>
					config->window.window_lower_value < -128 ||
    146a:	6a32      	ldr	r2, [r6, #32]
    146c:	3280      	adds	r2, #128	; 0x80
    146e:	2aff      	cmp	r2, #255	; 0xff
    1470:	d900      	bls.n	1474 <adc_init+0x250>
    1472:	e6ea      	b.n	124a <adc_init+0x26>
				return STATUS_ERR_INVALID_ARG;
    1474:	2017      	movs	r0, #23
			} else if (config->window.window_lower_value > 255 ||
    1476:	69f2      	ldr	r2, [r6, #28]
    1478:	2aff      	cmp	r2, #255	; 0xff
    147a:	dd00      	ble.n	147e <adc_init+0x25a>
    147c:	e6e5      	b.n	124a <adc_init+0x26>
    147e:	6a32      	ldr	r2, [r6, #32]
    1480:	2aff      	cmp	r2, #255	; 0xff
    1482:	dd00      	ble.n	1486 <adc_init+0x262>
    1484:	e6e1      	b.n	124a <adc_init+0x26>
	Adc *const adc_module = module_inst->hw;
    1486:	6839      	ldr	r1, [r7, #0]
	if (adc_module->STATUS.reg & ADC_STATUS_SYNCBUSY) {
    1488:	7e4a      	ldrb	r2, [r1, #25]
	while (adc_is_syncing(module_inst)) {
    148a:	b252      	sxtb	r2, r2
    148c:	2a00      	cmp	r2, #0
    148e:	dbfb      	blt.n	1488 <adc_init+0x264>
	adc_module->WINCTRL.reg = config->window.window_mode;
    1490:	4642      	mov	r2, r8
    1492:	7213      	strb	r3, [r2, #8]
	Adc *const adc_module = module_inst->hw;
    1494:	683a      	ldr	r2, [r7, #0]
	if (adc_module->STATUS.reg & ADC_STATUS_SYNCBUSY) {
    1496:	7e53      	ldrb	r3, [r2, #25]
	while (adc_is_syncing(module_inst)) {
    1498:	b25b      	sxtb	r3, r3
    149a:	2b00      	cmp	r3, #0
    149c:	dbfb      	blt.n	1496 <adc_init+0x272>
	adc_module->WINLT.reg =
    149e:	8bb3      	ldrh	r3, [r6, #28]
    14a0:	4642      	mov	r2, r8
    14a2:	8393      	strh	r3, [r2, #28]
	Adc *const adc_module = module_inst->hw;
    14a4:	683a      	ldr	r2, [r7, #0]
	if (adc_module->STATUS.reg & ADC_STATUS_SYNCBUSY) {
    14a6:	7e53      	ldrb	r3, [r2, #25]
	while (adc_is_syncing(module_inst)) {
    14a8:	b25b      	sxtb	r3, r3
    14aa:	2b00      	cmp	r3, #0
    14ac:	dbfb      	blt.n	14a6 <adc_init+0x282>
	adc_module->WINUT.reg = config->window.window_upper_value <<
    14ae:	8c33      	ldrh	r3, [r6, #32]
    14b0:	4642      	mov	r2, r8
    14b2:	8413      	strh	r3, [r2, #32]
	uint8_t inputs_to_scan = config->pin_scan.inputs_to_scan;
    14b4:	232c      	movs	r3, #44	; 0x2c
    14b6:	5cf3      	ldrb	r3, [r6, r3]
	if (inputs_to_scan > 0) {
    14b8:	2b00      	cmp	r3, #0
    14ba:	d005      	beq.n	14c8 <adc_init+0x2a4>
		inputs_to_scan--;
    14bc:	3b01      	subs	r3, #1
    14be:	b2db      	uxtb	r3, r3
		return STATUS_ERR_INVALID_ARG;
    14c0:	2017      	movs	r0, #23
	if (inputs_to_scan > (ADC_INPUTCTRL_INPUTSCAN_Msk >> ADC_INPUTCTRL_INPUTSCAN_Pos) ||
    14c2:	2b0f      	cmp	r3, #15
    14c4:	d900      	bls.n	14c8 <adc_init+0x2a4>
    14c6:	e6c0      	b.n	124a <adc_init+0x26>
			config->pin_scan.offset_start_scan > (ADC_INPUTCTRL_INPUTOFFSET_Msk >> ADC_INPUTCTRL_INPUTOFFSET_Pos)) {
    14c8:	222b      	movs	r2, #43	; 0x2b
    14ca:	5cb1      	ldrb	r1, [r6, r2]
		return STATUS_ERR_INVALID_ARG;
    14cc:	2017      	movs	r0, #23
	if (inputs_to_scan > (ADC_INPUTCTRL_INPUTSCAN_Msk >> ADC_INPUTCTRL_INPUTSCAN_Pos) ||
    14ce:	290f      	cmp	r1, #15
    14d0:	d900      	bls.n	14d4 <adc_init+0x2b0>
    14d2:	e6ba      	b.n	124a <adc_init+0x26>
	Adc *const adc_module = module_inst->hw;
    14d4:	6838      	ldr	r0, [r7, #0]
	if (adc_module->STATUS.reg & ADC_STATUS_SYNCBUSY) {
    14d6:	7e42      	ldrb	r2, [r0, #25]
	while (adc_is_syncing(module_inst)) {
    14d8:	b252      	sxtb	r2, r2
    14da:	2a00      	cmp	r2, #0
    14dc:	dbfb      	blt.n	14d6 <adc_init+0x2b2>
			config->negative_input |
    14de:	89f2      	ldrh	r2, [r6, #14]
			config->positive_input;
    14e0:	7b30      	ldrb	r0, [r6, #12]
			config->negative_input |
    14e2:	4302      	orrs	r2, r0
    14e4:	68b0      	ldr	r0, [r6, #8]
    14e6:	4302      	orrs	r2, r0
			(config->pin_scan.offset_start_scan <<
    14e8:	0509      	lsls	r1, r1, #20
			config->negative_input |
    14ea:	430a      	orrs	r2, r1
			(inputs_to_scan << ADC_INPUTCTRL_INPUTSCAN_Pos) |
    14ec:	041b      	lsls	r3, r3, #16
			config->negative_input |
    14ee:	4313      	orrs	r3, r2
	adc_module->INPUTCTRL.reg =
    14f0:	4642      	mov	r2, r8
    14f2:	6113      	str	r3, [r2, #16]
	adc_module->EVCTRL.reg = config->event_action;
    14f4:	232a      	movs	r3, #42	; 0x2a
    14f6:	5cf3      	ldrb	r3, [r6, r3]
    14f8:	7513      	strb	r3, [r2, #20]
	adc_module->INTENCLR.reg =
    14fa:	230f      	movs	r3, #15
    14fc:	7593      	strb	r3, [r2, #22]
	if (config->correction.correction_enable){
    14fe:	3315      	adds	r3, #21
    1500:	5cf3      	ldrb	r3, [r6, r3]
    1502:	2b00      	cmp	r3, #0
    1504:	d012      	beq.n	152c <adc_init+0x308>
		if (config->correction.gain_correction > ADC_GAINCORR_GAINCORR_Msk) {
    1506:	8cf3      	ldrh	r3, [r6, #38]	; 0x26
    1508:	4a1a      	ldr	r2, [pc, #104]	; (1574 <adc_init+0x350>)
			return STATUS_ERR_INVALID_ARG;
    150a:	2017      	movs	r0, #23
		if (config->correction.gain_correction > ADC_GAINCORR_GAINCORR_Msk) {
    150c:	4293      	cmp	r3, r2
    150e:	d900      	bls.n	1512 <adc_init+0x2ee>
    1510:	e69b      	b.n	124a <adc_init+0x26>
			adc_module->GAINCORR.reg = config->correction.gain_correction <<
    1512:	4642      	mov	r2, r8
    1514:	8493      	strh	r3, [r2, #36]	; 0x24
		if (config->correction.offset_correction > 2047 ||
    1516:	8d32      	ldrh	r2, [r6, #40]	; 0x28
    1518:	2380      	movs	r3, #128	; 0x80
    151a:	011b      	lsls	r3, r3, #4
    151c:	18d3      	adds	r3, r2, r3
    151e:	4915      	ldr	r1, [pc, #84]	; (1574 <adc_init+0x350>)
    1520:	b29b      	uxth	r3, r3
    1522:	428b      	cmp	r3, r1
    1524:	d900      	bls.n	1528 <adc_init+0x304>
    1526:	e690      	b.n	124a <adc_init+0x26>
			adc_module->OFFSETCORR.reg = config->correction.offset_correction <<
    1528:	4643      	mov	r3, r8
    152a:	84da      	strh	r2, [r3, #38]	; 0x26
			ADC_CALIB_BIAS_CAL(
    152c:	4b12      	ldr	r3, [pc, #72]	; (1578 <adc_init+0x354>)
    152e:	681b      	ldr	r3, [r3, #0]
    1530:	015b      	lsls	r3, r3, #5
    1532:	22e0      	movs	r2, #224	; 0xe0
    1534:	00d2      	lsls	r2, r2, #3
    1536:	4013      	ands	r3, r2
			ADC_CALIB_LINEARITY_CAL(
    1538:	4a10      	ldr	r2, [pc, #64]	; (157c <adc_init+0x358>)
    153a:	6851      	ldr	r1, [r2, #4]
    153c:	0149      	lsls	r1, r1, #5
    153e:	6812      	ldr	r2, [r2, #0]
    1540:	0ed2      	lsrs	r2, r2, #27
    1542:	430a      	orrs	r2, r1
    1544:	b2d2      	uxtb	r2, r2
			) |
    1546:	4313      	orrs	r3, r2
	adc_module->CALIB.reg =
    1548:	4642      	mov	r2, r8
    154a:	8513      	strh	r3, [r2, #40]	; 0x28
	return STATUS_OK;
    154c:	2000      	movs	r0, #0
    154e:	e67c      	b.n	124a <adc_init+0x26>
    1550:	40000400 	.word	0x40000400
    1554:	40000800 	.word	0x40000800
    1558:	20000208 	.word	0x20000208
    155c:	000033cd 	.word	0x000033cd
    1560:	00003341 	.word	0x00003341
    1564:	000039fd 	.word	0x000039fd
    1568:	00003c08 	.word	0x00003c08
    156c:	000034c5 	.word	0x000034c5
    1570:	00003b34 	.word	0x00003b34
    1574:	00000fff 	.word	0x00000fff
    1578:	00806024 	.word	0x00806024
    157c:	00806020 	.word	0x00806020
		switch (resolution) {
    1580:	2c00      	cmp	r4, #0
    1582:	d000      	beq.n	1586 <adc_init+0x362>
    1584:	e77f      	b.n	1486 <adc_init+0x262>
			if (config->differential_mode &&
    1586:	7cf2      	ldrb	r2, [r6, #19]
    1588:	2a00      	cmp	r2, #0
    158a:	d00f      	beq.n	15ac <adc_init+0x388>
					(config->window.window_lower_value > 2047 ||
    158c:	69f2      	ldr	r2, [r6, #28]
    158e:	2180      	movs	r1, #128	; 0x80
    1590:	0109      	lsls	r1, r1, #4
    1592:	468c      	mov	ip, r1
    1594:	4462      	add	r2, ip
			if (config->differential_mode &&
    1596:	492a      	ldr	r1, [pc, #168]	; (1640 <adc_init+0x41c>)
				return STATUS_ERR_INVALID_ARG;
    1598:	2017      	movs	r0, #23
			if (config->differential_mode &&
    159a:	428a      	cmp	r2, r1
    159c:	d900      	bls.n	15a0 <adc_init+0x37c>
    159e:	e654      	b.n	124a <adc_init+0x26>
					config->window.window_lower_value < -2048 ||
    15a0:	6a32      	ldr	r2, [r6, #32]
    15a2:	4462      	add	r2, ip
    15a4:	4926      	ldr	r1, [pc, #152]	; (1640 <adc_init+0x41c>)
    15a6:	428a      	cmp	r2, r1
    15a8:	d900      	bls.n	15ac <adc_init+0x388>
    15aa:	e64e      	b.n	124a <adc_init+0x26>
			} else if (config->window.window_lower_value > 4095 ||
    15ac:	4a24      	ldr	r2, [pc, #144]	; (1640 <adc_init+0x41c>)
				return STATUS_ERR_INVALID_ARG;
    15ae:	2017      	movs	r0, #23
			} else if (config->window.window_lower_value > 4095 ||
    15b0:	69f1      	ldr	r1, [r6, #28]
    15b2:	4291      	cmp	r1, r2
    15b4:	dd00      	ble.n	15b8 <adc_init+0x394>
    15b6:	e648      	b.n	124a <adc_init+0x26>
    15b8:	6a31      	ldr	r1, [r6, #32]
    15ba:	4291      	cmp	r1, r2
    15bc:	dd00      	ble.n	15c0 <adc_init+0x39c>
    15be:	e644      	b.n	124a <adc_init+0x26>
    15c0:	e761      	b.n	1486 <adc_init+0x262>
			if (config->differential_mode &&
    15c2:	7cf2      	ldrb	r2, [r6, #19]
    15c4:	2a00      	cmp	r2, #0
    15c6:	d00f      	beq.n	15e8 <adc_init+0x3c4>
					(config->window.window_lower_value > 511 ||
    15c8:	69f2      	ldr	r2, [r6, #28]
    15ca:	2180      	movs	r1, #128	; 0x80
    15cc:	0089      	lsls	r1, r1, #2
    15ce:	468c      	mov	ip, r1
    15d0:	4462      	add	r2, ip
			if (config->differential_mode &&
    15d2:	491c      	ldr	r1, [pc, #112]	; (1644 <adc_init+0x420>)
				return STATUS_ERR_INVALID_ARG;
    15d4:	2017      	movs	r0, #23
			if (config->differential_mode &&
    15d6:	428a      	cmp	r2, r1
    15d8:	d900      	bls.n	15dc <adc_init+0x3b8>
    15da:	e636      	b.n	124a <adc_init+0x26>
					config->window.window_lower_value < -512 ||
    15dc:	6a32      	ldr	r2, [r6, #32]
    15de:	4462      	add	r2, ip
    15e0:	4918      	ldr	r1, [pc, #96]	; (1644 <adc_init+0x420>)
    15e2:	428a      	cmp	r2, r1
    15e4:	d900      	bls.n	15e8 <adc_init+0x3c4>
    15e6:	e630      	b.n	124a <adc_init+0x26>
			} else if (config->window.window_lower_value > 1023 ||
    15e8:	4a16      	ldr	r2, [pc, #88]	; (1644 <adc_init+0x420>)
				return STATUS_ERR_INVALID_ARG;
    15ea:	2017      	movs	r0, #23
			} else if (config->window.window_lower_value > 1023 ||
    15ec:	69f1      	ldr	r1, [r6, #28]
    15ee:	4291      	cmp	r1, r2
    15f0:	dd00      	ble.n	15f4 <adc_init+0x3d0>
    15f2:	e62a      	b.n	124a <adc_init+0x26>
    15f4:	6a31      	ldr	r1, [r6, #32]
    15f6:	4291      	cmp	r1, r2
    15f8:	dd00      	ble.n	15fc <adc_init+0x3d8>
    15fa:	e626      	b.n	124a <adc_init+0x26>
    15fc:	e743      	b.n	1486 <adc_init+0x262>
			if (config->differential_mode &&
    15fe:	7cf2      	ldrb	r2, [r6, #19]
    1600:	2a00      	cmp	r2, #0
    1602:	d00f      	beq.n	1624 <adc_init+0x400>
					(config->window.window_lower_value > 32767 ||
    1604:	69f2      	ldr	r2, [r6, #28]
    1606:	2180      	movs	r1, #128	; 0x80
    1608:	0209      	lsls	r1, r1, #8
    160a:	468c      	mov	ip, r1
    160c:	4462      	add	r2, ip
			if (config->differential_mode &&
    160e:	490e      	ldr	r1, [pc, #56]	; (1648 <adc_init+0x424>)
				return STATUS_ERR_INVALID_ARG;
    1610:	2017      	movs	r0, #23
			if (config->differential_mode &&
    1612:	428a      	cmp	r2, r1
    1614:	d900      	bls.n	1618 <adc_init+0x3f4>
    1616:	e618      	b.n	124a <adc_init+0x26>
					config->window.window_lower_value < -32768 ||
    1618:	6a32      	ldr	r2, [r6, #32]
    161a:	4462      	add	r2, ip
    161c:	490a      	ldr	r1, [pc, #40]	; (1648 <adc_init+0x424>)
    161e:	428a      	cmp	r2, r1
    1620:	d900      	bls.n	1624 <adc_init+0x400>
    1622:	e612      	b.n	124a <adc_init+0x26>
			} else if (config->window.window_lower_value > 65535 ||
    1624:	4a08      	ldr	r2, [pc, #32]	; (1648 <adc_init+0x424>)
				return STATUS_ERR_INVALID_ARG;
    1626:	2017      	movs	r0, #23
			} else if (config->window.window_lower_value > 65535 ||
    1628:	69f1      	ldr	r1, [r6, #28]
    162a:	4291      	cmp	r1, r2
    162c:	dd00      	ble.n	1630 <adc_init+0x40c>
    162e:	e60c      	b.n	124a <adc_init+0x26>
    1630:	6a31      	ldr	r1, [r6, #32]
    1632:	4291      	cmp	r1, r2
    1634:	dd00      	ble.n	1638 <adc_init+0x414>
    1636:	e608      	b.n	124a <adc_init+0x26>
    1638:	e725      	b.n	1486 <adc_init+0x262>
		return STATUS_ERR_INVALID_ARG;
    163a:	2017      	movs	r0, #23
    163c:	e605      	b.n	124a <adc_init+0x26>
    163e:	46c0      	nop			; (mov r8, r8)
    1640:	00000fff 	.word	0x00000fff
    1644:	000003ff 	.word	0x000003ff
    1648:	0000ffff 	.word	0x0000ffff

0000164c <ADC_Handler>:
	}
}

/** Interrupt handler for the ADC module. */
void ADC_Handler(void)
{
    164c:	b570      	push	{r4, r5, r6, lr}
	struct adc_module *module = _adc_instances[instance];
    164e:	4b2e      	ldr	r3, [pc, #184]	; (1708 <ADC_Handler+0xbc>)
    1650:	681c      	ldr	r4, [r3, #0]
	uint32_t flags = module->hw->INTFLAG.reg;
    1652:	6823      	ldr	r3, [r4, #0]
    1654:	7e1d      	ldrb	r5, [r3, #24]
    1656:	b2ed      	uxtb	r5, r5
	if (flags & ADC_INTFLAG_RESRDY) {
    1658:	07ea      	lsls	r2, r5, #31
    165a:	d505      	bpl.n	1668 <ADC_Handler+0x1c>
		if ((module->enabled_callback_mask & (1 << ADC_CALLBACK_READ_BUFFER)) &&
    165c:	7ee2      	ldrb	r2, [r4, #27]
    165e:	07d2      	lsls	r2, r2, #31
    1660:	d502      	bpl.n	1668 <ADC_Handler+0x1c>
    1662:	7ea2      	ldrb	r2, [r4, #26]
    1664:	07d2      	lsls	r2, r2, #31
    1666:	d416      	bmi.n	1696 <ADC_Handler+0x4a>
	if (flags & ADC_INTFLAG_WINMON) {
    1668:	076b      	lsls	r3, r5, #29
    166a:	d508      	bpl.n	167e <ADC_Handler+0x32>
		module->hw->INTFLAG.reg = ADC_INTFLAG_WINMON;
    166c:	2304      	movs	r3, #4
    166e:	6822      	ldr	r2, [r4, #0]
    1670:	7613      	strb	r3, [r2, #24]
		if ((module->enabled_callback_mask & (1 << ADC_CALLBACK_WINDOW)) &&
    1672:	7ee3      	ldrb	r3, [r4, #27]
    1674:	079b      	lsls	r3, r3, #30
    1676:	d502      	bpl.n	167e <ADC_Handler+0x32>
    1678:	7ea3      	ldrb	r3, [r4, #26]
    167a:	079b      	lsls	r3, r3, #30
    167c:	d43c      	bmi.n	16f8 <ADC_Handler+0xac>
	if (flags & ADC_INTFLAG_OVERRUN) {
    167e:	07ab      	lsls	r3, r5, #30
    1680:	d508      	bpl.n	1694 <ADC_Handler+0x48>
		module->hw->INTFLAG.reg = ADC_INTFLAG_OVERRUN;
    1682:	2302      	movs	r3, #2
    1684:	6822      	ldr	r2, [r4, #0]
    1686:	7613      	strb	r3, [r2, #24]
		if ((module->enabled_callback_mask & (1 << ADC_CALLBACK_ERROR)) &&
    1688:	7ee3      	ldrb	r3, [r4, #27]
    168a:	075b      	lsls	r3, r3, #29
    168c:	d502      	bpl.n	1694 <ADC_Handler+0x48>
    168e:	7ea3      	ldrb	r3, [r4, #26]
    1690:	075b      	lsls	r3, r3, #29
    1692:	d435      	bmi.n	1700 <ADC_Handler+0xb4>
	_adc_interrupt_handler(0);
}
    1694:	bd70      	pop	{r4, r5, r6, pc}
			module->hw->INTFLAG.reg = ADC_INTFLAG_RESRDY;
    1696:	2201      	movs	r2, #1
    1698:	761a      	strb	r2, [r3, #24]
	Adc *const adc_module = module_inst->hw;
    169a:	6822      	ldr	r2, [r4, #0]
	if (adc_module->STATUS.reg & ADC_STATUS_SYNCBUSY) {
    169c:	7e53      	ldrb	r3, [r2, #25]
			while (adc_is_syncing(module)) {
    169e:	b25b      	sxtb	r3, r3
    16a0:	2b00      	cmp	r3, #0
    16a2:	dbfb      	blt.n	169c <ADC_Handler+0x50>
			*(module->job_buffer++) = module->hw->RESULT.reg;
    16a4:	6961      	ldr	r1, [r4, #20]
    16a6:	1c8b      	adds	r3, r1, #2
    16a8:	6163      	str	r3, [r4, #20]
    16aa:	8b53      	ldrh	r3, [r2, #26]
    16ac:	b29b      	uxth	r3, r3
    16ae:	800b      	strh	r3, [r1, #0]
			if (--module->remaining_conversions > 0) {
    16b0:	8b23      	ldrh	r3, [r4, #24]
    16b2:	3b01      	subs	r3, #1
    16b4:	b29b      	uxth	r3, r3
    16b6:	8323      	strh	r3, [r4, #24]
    16b8:	2b00      	cmp	r3, #0
    16ba:	d011      	beq.n	16e0 <ADC_Handler+0x94>
				if (module->software_trigger == true) {
    16bc:	7f63      	ldrb	r3, [r4, #29]
    16be:	2b00      	cmp	r3, #0
    16c0:	d0d2      	beq.n	1668 <ADC_Handler+0x1c>
		struct adc_module *const module_inst)
{
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
    16c2:	6822      	ldr	r2, [r4, #0]
    16c4:	7e53      	ldrb	r3, [r2, #25]

	while (adc_is_syncing(module_inst)) {
    16c6:	b25b      	sxtb	r3, r3
    16c8:	2b00      	cmp	r3, #0
    16ca:	dbfb      	blt.n	16c4 <ADC_Handler+0x78>
		/* Wait for synchronization */
	}

	adc_module->SWTRIG.reg |= ADC_SWTRIG_START;
    16cc:	7b13      	ldrb	r3, [r2, #12]
    16ce:	2102      	movs	r1, #2
    16d0:	430b      	orrs	r3, r1
    16d2:	7313      	strb	r3, [r2, #12]
	Adc *const adc_module = module_inst->hw;
    16d4:	6822      	ldr	r2, [r4, #0]
	if (adc_module->STATUS.reg & ADC_STATUS_SYNCBUSY) {
    16d6:	7e53      	ldrb	r3, [r2, #25]

	while (adc_is_syncing(module_inst)) {
    16d8:	b25b      	sxtb	r3, r3
    16da:	2b00      	cmp	r3, #0
    16dc:	dbfb      	blt.n	16d6 <ADC_Handler+0x8a>
    16de:	e7c3      	b.n	1668 <ADC_Handler+0x1c>
				if (module->job_status == STATUS_BUSY) {
    16e0:	7f23      	ldrb	r3, [r4, #28]
    16e2:	2b05      	cmp	r3, #5
    16e4:	d1c0      	bne.n	1668 <ADC_Handler+0x1c>
					module->job_status = STATUS_OK;
    16e6:	2300      	movs	r3, #0
    16e8:	7723      	strb	r3, [r4, #28]
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
	/* Enable interrupt */
	adc_module->INTENCLR.reg = interrupt;
    16ea:	3301      	adds	r3, #1
    16ec:	6822      	ldr	r2, [r4, #0]
    16ee:	7593      	strb	r3, [r2, #22]
					(module->callback[ADC_CALLBACK_READ_BUFFER])(module);
    16f0:	0020      	movs	r0, r4
    16f2:	68a3      	ldr	r3, [r4, #8]
    16f4:	4798      	blx	r3
    16f6:	e7b7      	b.n	1668 <ADC_Handler+0x1c>
			(module->callback[ADC_CALLBACK_WINDOW])(module);
    16f8:	0020      	movs	r0, r4
    16fa:	68e3      	ldr	r3, [r4, #12]
    16fc:	4798      	blx	r3
    16fe:	e7be      	b.n	167e <ADC_Handler+0x32>
			(module->callback[ADC_CALLBACK_ERROR])(module);
    1700:	6923      	ldr	r3, [r4, #16]
    1702:	0020      	movs	r0, r4
    1704:	4798      	blx	r3
}
    1706:	e7c5      	b.n	1694 <ADC_Handler+0x48>
    1708:	20000208 	.word	0x20000208

0000170c <_extint_enable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    170c:	4a04      	ldr	r2, [pc, #16]	; (1720 <_extint_enable+0x14>)
    170e:	7813      	ldrb	r3, [r2, #0]
    1710:	2102      	movs	r1, #2
    1712:	430b      	orrs	r3, r1
    1714:	7013      	strb	r3, [r2, #0]
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    1716:	7853      	ldrb	r3, [r2, #1]
    1718:	b25b      	sxtb	r3, r3
    171a:	2b00      	cmp	r3, #0
    171c:	dbfb      	blt.n	1716 <_extint_enable+0xa>
	}

	while (extint_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    171e:	4770      	bx	lr
    1720:	40001800 	.word	0x40001800

00001724 <_system_extint_init>:
{
    1724:	b500      	push	{lr}
    1726:	b083      	sub	sp, #12
			PM->APBAMASK.reg |= mask;
    1728:	4a12      	ldr	r2, [pc, #72]	; (1774 <_system_extint_init+0x50>)
    172a:	6993      	ldr	r3, [r2, #24]
    172c:	2140      	movs	r1, #64	; 0x40
    172e:	430b      	orrs	r3, r1
    1730:	6193      	str	r3, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    1732:	a901      	add	r1, sp, #4
    1734:	2300      	movs	r3, #0
    1736:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    1738:	2005      	movs	r0, #5
    173a:	4b0f      	ldr	r3, [pc, #60]	; (1778 <_system_extint_init+0x54>)
    173c:	4798      	blx	r3
	system_gclk_chan_enable(EIC_GCLK_ID);
    173e:	2005      	movs	r0, #5
    1740:	4b0e      	ldr	r3, [pc, #56]	; (177c <_system_extint_init+0x58>)
    1742:	4798      	blx	r3
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
    1744:	4a0e      	ldr	r2, [pc, #56]	; (1780 <_system_extint_init+0x5c>)
    1746:	7813      	ldrb	r3, [r2, #0]
    1748:	2101      	movs	r1, #1
    174a:	430b      	orrs	r3, r1
    174c:	7013      	strb	r3, [r2, #0]
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    174e:	7853      	ldrb	r3, [r2, #1]
    1750:	b25b      	sxtb	r3, r3
    1752:	2b00      	cmp	r3, #0
    1754:	dbfb      	blt.n	174e <_system_extint_init+0x2a>
    1756:	4b0b      	ldr	r3, [pc, #44]	; (1784 <_system_extint_init+0x60>)
    1758:	0019      	movs	r1, r3
    175a:	3140      	adds	r1, #64	; 0x40
		_extint_dev.callbacks[j] = NULL;
    175c:	2200      	movs	r2, #0
    175e:	c304      	stmia	r3!, {r2}
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    1760:	4299      	cmp	r1, r3
    1762:	d1fc      	bne.n	175e <_system_extint_init+0x3a>
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    1764:	2210      	movs	r2, #16
    1766:	4b08      	ldr	r3, [pc, #32]	; (1788 <_system_extint_init+0x64>)
    1768:	601a      	str	r2, [r3, #0]
	_extint_enable();
    176a:	4b08      	ldr	r3, [pc, #32]	; (178c <_system_extint_init+0x68>)
    176c:	4798      	blx	r3
}
    176e:	b003      	add	sp, #12
    1770:	bd00      	pop	{pc}
    1772:	46c0      	nop			; (mov r8, r8)
    1774:	40000400 	.word	0x40000400
    1778:	000033cd 	.word	0x000033cd
    177c:	00003341 	.word	0x00003341
    1780:	40001800 	.word	0x40001800
    1784:	2000020c 	.word	0x2000020c
    1788:	e000e100 	.word	0xe000e100
    178c:	0000170d 	.word	0x0000170d

00001790 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    1790:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    1792:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    1794:	2340      	movs	r3, #64	; 0x40
    1796:	2400      	movs	r4, #0
	if (baudrate > (external_clock / 2)) {
    1798:	4281      	cmp	r1, r0
    179a:	d202      	bcs.n	17a2 <_sercom_get_sync_baud_val+0x12>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
		return STATUS_OK;
	}
}
    179c:	0018      	movs	r0, r3
    179e:	bd10      	pop	{r4, pc}
		baud_calculated++;
    17a0:	001c      	movs	r4, r3
		clock_value = clock_value - baudrate;
    17a2:	1a09      	subs	r1, r1, r0
		baud_calculated++;
    17a4:	1c63      	adds	r3, r4, #1
    17a6:	b29b      	uxth	r3, r3
	while (clock_value >= baudrate) {
    17a8:	4288      	cmp	r0, r1
    17aa:	d9f9      	bls.n	17a0 <_sercom_get_sync_baud_val+0x10>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    17ac:	2340      	movs	r3, #64	; 0x40
	if (baud_calculated > 0xFF) {
    17ae:	2cff      	cmp	r4, #255	; 0xff
    17b0:	d8f4      	bhi.n	179c <_sercom_get_sync_baud_val+0xc>
		*baudvalue = baud_calculated;
    17b2:	8014      	strh	r4, [r2, #0]
		return STATUS_OK;
    17b4:	2300      	movs	r3, #0
    17b6:	e7f1      	b.n	179c <_sercom_get_sync_baud_val+0xc>

000017b8 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    17b8:	b510      	push	{r4, lr}
    17ba:	b082      	sub	sp, #8
    17bc:	0004      	movs	r4, r0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    17be:	4b0e      	ldr	r3, [pc, #56]	; (17f8 <sercom_set_gclk_generator+0x40>)
    17c0:	781b      	ldrb	r3, [r3, #0]
    17c2:	2b00      	cmp	r3, #0
    17c4:	d007      	beq.n	17d6 <sercom_set_gclk_generator+0x1e>
    17c6:	2900      	cmp	r1, #0
    17c8:	d105      	bne.n	17d6 <sercom_set_gclk_generator+0x1e>
		/* Save config */
		_sercom_config.generator_source = generator_source;
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
    17ca:	4b0b      	ldr	r3, [pc, #44]	; (17f8 <sercom_set_gclk_generator+0x40>)
    17cc:	785b      	ldrb	r3, [r3, #1]
    17ce:	4283      	cmp	r3, r0
    17d0:	d010      	beq.n	17f4 <sercom_set_gclk_generator+0x3c>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    17d2:	201d      	movs	r0, #29
    17d4:	e00c      	b.n	17f0 <sercom_set_gclk_generator+0x38>
		gclk_chan_conf.source_generator = generator_source;
    17d6:	a901      	add	r1, sp, #4
    17d8:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    17da:	200d      	movs	r0, #13
    17dc:	4b07      	ldr	r3, [pc, #28]	; (17fc <sercom_set_gclk_generator+0x44>)
    17de:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    17e0:	200d      	movs	r0, #13
    17e2:	4b07      	ldr	r3, [pc, #28]	; (1800 <sercom_set_gclk_generator+0x48>)
    17e4:	4798      	blx	r3
		_sercom_config.generator_source = generator_source;
    17e6:	4b04      	ldr	r3, [pc, #16]	; (17f8 <sercom_set_gclk_generator+0x40>)
    17e8:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
    17ea:	2201      	movs	r2, #1
    17ec:	701a      	strb	r2, [r3, #0]
		return STATUS_OK;
    17ee:	2000      	movs	r0, #0
}
    17f0:	b002      	add	sp, #8
    17f2:	bd10      	pop	{r4, pc}
		return STATUS_OK;
    17f4:	2000      	movs	r0, #0
    17f6:	e7fb      	b.n	17f0 <sercom_set_gclk_generator+0x38>
    17f8:	20000094 	.word	0x20000094
    17fc:	000033cd 	.word	0x000033cd
    1800:	00003341 	.word	0x00003341

00001804 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
    1804:	4b20      	ldr	r3, [pc, #128]	; (1888 <_sercom_get_default_pad+0x84>)
    1806:	4298      	cmp	r0, r3
    1808:	d017      	beq.n	183a <_sercom_get_default_pad+0x36>
    180a:	4b20      	ldr	r3, [pc, #128]	; (188c <_sercom_get_default_pad+0x88>)
    180c:	4298      	cmp	r0, r3
    180e:	d024      	beq.n	185a <_sercom_get_default_pad+0x56>
    1810:	4b1f      	ldr	r3, [pc, #124]	; (1890 <_sercom_get_default_pad+0x8c>)
    1812:	4298      	cmp	r0, r3
    1814:	d001      	beq.n	181a <_sercom_get_default_pad+0x16>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
	}

	Assert(false);
	return 0;
    1816:	2000      	movs	r0, #0
}
    1818:	4770      	bx	lr
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    181a:	2901      	cmp	r1, #1
    181c:	d007      	beq.n	182e <_sercom_get_default_pad+0x2a>
    181e:	2900      	cmp	r1, #0
    1820:	d02b      	beq.n	187a <_sercom_get_default_pad+0x76>
    1822:	2902      	cmp	r1, #2
    1824:	d005      	beq.n	1832 <_sercom_get_default_pad+0x2e>
    1826:	2903      	cmp	r1, #3
    1828:	d005      	beq.n	1836 <_sercom_get_default_pad+0x32>
	return 0;
    182a:	2000      	movs	r0, #0
    182c:	e7f4      	b.n	1818 <_sercom_get_default_pad+0x14>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    182e:	4819      	ldr	r0, [pc, #100]	; (1894 <_sercom_get_default_pad+0x90>)
    1830:	e7f2      	b.n	1818 <_sercom_get_default_pad+0x14>
    1832:	4819      	ldr	r0, [pc, #100]	; (1898 <_sercom_get_default_pad+0x94>)
    1834:	e7f0      	b.n	1818 <_sercom_get_default_pad+0x14>
    1836:	4819      	ldr	r0, [pc, #100]	; (189c <_sercom_get_default_pad+0x98>)
    1838:	e7ee      	b.n	1818 <_sercom_get_default_pad+0x14>
    183a:	2901      	cmp	r1, #1
    183c:	d007      	beq.n	184e <_sercom_get_default_pad+0x4a>
    183e:	2900      	cmp	r1, #0
    1840:	d01d      	beq.n	187e <_sercom_get_default_pad+0x7a>
    1842:	2902      	cmp	r1, #2
    1844:	d005      	beq.n	1852 <_sercom_get_default_pad+0x4e>
    1846:	2903      	cmp	r1, #3
    1848:	d005      	beq.n	1856 <_sercom_get_default_pad+0x52>
	return 0;
    184a:	2000      	movs	r0, #0
    184c:	e7e4      	b.n	1818 <_sercom_get_default_pad+0x14>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    184e:	4814      	ldr	r0, [pc, #80]	; (18a0 <_sercom_get_default_pad+0x9c>)
    1850:	e7e2      	b.n	1818 <_sercom_get_default_pad+0x14>
    1852:	4814      	ldr	r0, [pc, #80]	; (18a4 <_sercom_get_default_pad+0xa0>)
    1854:	e7e0      	b.n	1818 <_sercom_get_default_pad+0x14>
    1856:	4814      	ldr	r0, [pc, #80]	; (18a8 <_sercom_get_default_pad+0xa4>)
    1858:	e7de      	b.n	1818 <_sercom_get_default_pad+0x14>
    185a:	2901      	cmp	r1, #1
    185c:	d007      	beq.n	186e <_sercom_get_default_pad+0x6a>
    185e:	2900      	cmp	r1, #0
    1860:	d00f      	beq.n	1882 <_sercom_get_default_pad+0x7e>
    1862:	2902      	cmp	r1, #2
    1864:	d005      	beq.n	1872 <_sercom_get_default_pad+0x6e>
    1866:	2903      	cmp	r1, #3
    1868:	d005      	beq.n	1876 <_sercom_get_default_pad+0x72>
	return 0;
    186a:	2000      	movs	r0, #0
    186c:	e7d4      	b.n	1818 <_sercom_get_default_pad+0x14>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    186e:	480f      	ldr	r0, [pc, #60]	; (18ac <_sercom_get_default_pad+0xa8>)
    1870:	e7d2      	b.n	1818 <_sercom_get_default_pad+0x14>
    1872:	480f      	ldr	r0, [pc, #60]	; (18b0 <_sercom_get_default_pad+0xac>)
    1874:	e7d0      	b.n	1818 <_sercom_get_default_pad+0x14>
    1876:	480f      	ldr	r0, [pc, #60]	; (18b4 <_sercom_get_default_pad+0xb0>)
    1878:	e7ce      	b.n	1818 <_sercom_get_default_pad+0x14>
    187a:	480f      	ldr	r0, [pc, #60]	; (18b8 <_sercom_get_default_pad+0xb4>)
    187c:	e7cc      	b.n	1818 <_sercom_get_default_pad+0x14>
    187e:	480f      	ldr	r0, [pc, #60]	; (18bc <_sercom_get_default_pad+0xb8>)
    1880:	e7ca      	b.n	1818 <_sercom_get_default_pad+0x14>
    1882:	480f      	ldr	r0, [pc, #60]	; (18c0 <_sercom_get_default_pad+0xbc>)
    1884:	e7c8      	b.n	1818 <_sercom_get_default_pad+0x14>
    1886:	46c0      	nop			; (mov r8, r8)
    1888:	42000c00 	.word	0x42000c00
    188c:	42001000 	.word	0x42001000
    1890:	42000800 	.word	0x42000800
    1894:	00050003 	.word	0x00050003
    1898:	00060003 	.word	0x00060003
    189c:	00070003 	.word	0x00070003
    18a0:	00170002 	.word	0x00170002
    18a4:	001e0003 	.word	0x001e0003
    18a8:	001f0003 	.word	0x001f0003
    18ac:	00170003 	.word	0x00170003
    18b0:	00100003 	.word	0x00100003
    18b4:	00190003 	.word	0x00190003
    18b8:	00040003 	.word	0x00040003
    18bc:	00160002 	.word	0x00160002
    18c0:	00160003 	.word	0x00160003

000018c4 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    18c4:	b530      	push	{r4, r5, lr}
    18c6:	b085      	sub	sp, #20
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    18c8:	aa01      	add	r2, sp, #4
    18ca:	4b0b      	ldr	r3, [pc, #44]	; (18f8 <_sercom_get_sercom_inst_index+0x34>)
    18cc:	cb32      	ldmia	r3!, {r1, r4, r5}
    18ce:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    18d0:	0003      	movs	r3, r0
    18d2:	9a01      	ldr	r2, [sp, #4]
    18d4:	4282      	cmp	r2, r0
    18d6:	d00c      	beq.n	18f2 <_sercom_get_sercom_inst_index+0x2e>
    18d8:	9a02      	ldr	r2, [sp, #8]
    18da:	4282      	cmp	r2, r0
    18dc:	d007      	beq.n	18ee <_sercom_get_sercom_inst_index+0x2a>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    18de:	2000      	movs	r0, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    18e0:	9a03      	ldr	r2, [sp, #12]
    18e2:	429a      	cmp	r2, r3
    18e4:	d001      	beq.n	18ea <_sercom_get_sercom_inst_index+0x26>
}
    18e6:	b005      	add	sp, #20
    18e8:	bd30      	pop	{r4, r5, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    18ea:	3002      	adds	r0, #2
    18ec:	e002      	b.n	18f4 <_sercom_get_sercom_inst_index+0x30>
    18ee:	2001      	movs	r0, #1
    18f0:	e000      	b.n	18f4 <_sercom_get_sercom_inst_index+0x30>
    18f2:	2000      	movs	r0, #0
			return i;
    18f4:	b2c0      	uxtb	r0, r0
    18f6:	e7f6      	b.n	18e6 <_sercom_get_sercom_inst_index+0x22>
    18f8:	00003c58 	.word	0x00003c58

000018fc <update_ORB_LED>:
Do not update the battery status LED unless the voltage is less than a value (not yet fixed)
once you have the values make sure you have the compare values sorted in ascending order and 
also associate the Pins with the compare values
********************************************************************************************/
void update_ORB_LED(uint8_t r1 ,uint8_t g1 ,uint8_t b1 ,uint8_t r2 ,uint8_t g2 ,uint8_t b2 ,uint8_t l1 , uint8_t l4 )
{
    18fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    18fe:	ac06      	add	r4, sp, #24
    1900:	7827      	ldrb	r7, [r4, #0]
    1902:	ac07      	add	r4, sp, #28
    1904:	7826      	ldrb	r6, [r4, #0]
    1906:	ac08      	add	r4, sp, #32
    1908:	7825      	ldrb	r5, [r4, #0]
    190a:	ac09      	add	r4, sp, #36	; 0x24
    190c:	7824      	ldrb	r4, [r4, #0]
    190e:	46a4      	mov	ip, r4
	
 	temp_compare_array_2[0] = 255-r1;//Left -- R
    1910:	43c0      	mvns	r0, r0
    1912:	b2c0      	uxtb	r0, r0
    1914:	4c11      	ldr	r4, [pc, #68]	; (195c <update_ORB_LED+0x60>)
    1916:	7020      	strb	r0, [r4, #0]
 	temp_compare_array_2[1] = 255-g1;//Left  -- G
    1918:	43c9      	mvns	r1, r1
    191a:	b2c9      	uxtb	r1, r1
    191c:	7061      	strb	r1, [r4, #1]
 	temp_compare_array_2[2] = 255-b1;//Left  -- B
    191e:	43d2      	mvns	r2, r2
    1920:	b2d2      	uxtb	r2, r2
    1922:	70a2      	strb	r2, [r4, #2]
 	temp_compare_array_2[3] = 255-r2;//Right -- R
    1924:	43db      	mvns	r3, r3
    1926:	b2db      	uxtb	r3, r3
    1928:	70e3      	strb	r3, [r4, #3]
 	temp_compare_array_2[4] = 255-g2;//Right  -- G
    192a:	43fb      	mvns	r3, r7
    192c:	b2db      	uxtb	r3, r3
    192e:	7123      	strb	r3, [r4, #4]
 	temp_compare_array_2[5] = 255-b2;//Right -- B
    1930:	43f3      	mvns	r3, r6
    1932:	b2db      	uxtb	r3, r3
    1934:	7163      	strb	r3, [r4, #5]
	temp_compare_array_2[6] = 255-l1;//led1
    1936:	43eb      	mvns	r3, r5
    1938:	b2db      	uxtb	r3, r3
    193a:	71a3      	strb	r3, [r4, #6]
	if(status_battery == false)
    193c:	4b08      	ldr	r3, [pc, #32]	; (1960 <update_ORB_LED+0x64>)
    193e:	781b      	ldrb	r3, [r3, #0]
    1940:	2b00      	cmp	r3, #0
    1942:	d103      	bne.n	194c <update_ORB_LED+0x50>
	{
		temp_compare_array_2[7] = 255-l4;//led4 
    1944:	4663      	mov	r3, ip
    1946:	43db      	mvns	r3, r3
    1948:	b2db      	uxtb	r3, r3
    194a:	71e3      	strb	r3, [r4, #7]
	}  
	initializing_pin_array();
    194c:	4b05      	ldr	r3, [pc, #20]	; (1964 <update_ORB_LED+0x68>)
    194e:	4798      	blx	r3
	increasing_sort_tag();
    1950:	4b05      	ldr	r3, [pc, #20]	; (1968 <update_ORB_LED+0x6c>)
    1952:	4798      	blx	r3
	update_compare_array = true;
    1954:	2201      	movs	r2, #1
    1956:	4b05      	ldr	r3, [pc, #20]	; (196c <update_ORB_LED+0x70>)
    1958:	701a      	strb	r2, [r3, #0]

}
    195a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    195c:	2000034c 	.word	0x2000034c
    1960:	2000000e 	.word	0x2000000e
    1964:	00002e91 	.word	0x00002e91
    1968:	00002c6d 	.word	0x00002c6d
    196c:	200000f8 	.word	0x200000f8

00001970 <update_ORB_single>:


void update_ORB_single(uint8_t port_no , uint8_t r , uint8_t g , uint8_t b)
{
    1970:	b510      	push	{r4, lr}
	volatile uint32_t* const  PORT_SET		      = PORT_SET_REGISTER_ADD;
	volatile uint32_t* const PORT_CLEAR			  = PORT_CLEAR_REGISTER_ADD;
	uint32_t B2_RGB = 0x08000000;
	
	if(port_no == '1') //ASCII 1
    1972:	2831      	cmp	r0, #49	; 0x31
    1974:	d009      	beq.n	198a <update_ORB_single+0x1a>
	{
		temp_compare_array_2[0] = 255-r;//Left -- R
		temp_compare_array_2[1] = 255-g;//Left  -- G
		temp_compare_array_2[2] = 255-b;//Left  -- B
	}
	else if(port_no == '2')//ASCII 2
    1976:	2832      	cmp	r0, #50	; 0x32
    1978:	d012      	beq.n	19a0 <update_ORB_single+0x30>
	{
		temp_compare_array_2[3] = 255-r;//Right -- R
		temp_compare_array_2[4] = 255-g;//Right  -- G
		temp_compare_array_2[5] = 255-b;//Right -- B
	}
	initializing_pin_array();
    197a:	4b0f      	ldr	r3, [pc, #60]	; (19b8 <update_ORB_single+0x48>)
    197c:	4798      	blx	r3
	increasing_sort_tag();
    197e:	4b0f      	ldr	r3, [pc, #60]	; (19bc <update_ORB_single+0x4c>)
    1980:	4798      	blx	r3

	update_compare_array = true;
    1982:	2201      	movs	r2, #1
    1984:	4b0e      	ldr	r3, [pc, #56]	; (19c0 <update_ORB_single+0x50>)
    1986:	701a      	strb	r2, [r3, #0]
}
    1988:	bd10      	pop	{r4, pc}
		temp_compare_array_2[0] = 255-r;//Left -- R
    198a:	43c9      	mvns	r1, r1
    198c:	b2c9      	uxtb	r1, r1
    198e:	480d      	ldr	r0, [pc, #52]	; (19c4 <update_ORB_single+0x54>)
    1990:	7001      	strb	r1, [r0, #0]
		temp_compare_array_2[1] = 255-g;//Left  -- G
    1992:	43d2      	mvns	r2, r2
    1994:	b2d2      	uxtb	r2, r2
    1996:	7042      	strb	r2, [r0, #1]
		temp_compare_array_2[2] = 255-b;//Left  -- B
    1998:	43db      	mvns	r3, r3
    199a:	b2db      	uxtb	r3, r3
    199c:	7083      	strb	r3, [r0, #2]
    199e:	e7ec      	b.n	197a <update_ORB_single+0xa>
		temp_compare_array_2[3] = 255-r;//Right -- R
    19a0:	43c9      	mvns	r1, r1
    19a2:	b2c9      	uxtb	r1, r1
    19a4:	4807      	ldr	r0, [pc, #28]	; (19c4 <update_ORB_single+0x54>)
    19a6:	70c1      	strb	r1, [r0, #3]
		temp_compare_array_2[4] = 255-g;//Right  -- G
    19a8:	43d2      	mvns	r2, r2
    19aa:	b2d2      	uxtb	r2, r2
    19ac:	7102      	strb	r2, [r0, #4]
		temp_compare_array_2[5] = 255-b;//Right -- B
    19ae:	43db      	mvns	r3, r3
    19b0:	b2db      	uxtb	r3, r3
    19b2:	7143      	strb	r3, [r0, #5]
    19b4:	e7e1      	b.n	197a <update_ORB_single+0xa>
    19b6:	46c0      	nop			; (mov r8, r8)
    19b8:	00002e91 	.word	0x00002e91
    19bc:	00002c6d 	.word	0x00002c6d
    19c0:	200000f8 	.word	0x200000f8
    19c4:	2000034c 	.word	0x2000034c

000019c8 <update_LEDS_single>:

void update_LEDS_single(uint8_t port_no, uint8_t led)
{
    19c8:	b510      	push	{r4, lr}
	volatile uint32_t* const  PORT_SET		      = PORT_SET_REGISTER_ADD;
	volatile uint32_t* const PORT_CLEAR           = PORT_CLEAR_REGISTER_ADD;
	uint32_t B2_RGB = 0x08000000;
	if(led == 0xff)
    19ca:	29ff      	cmp	r1, #255	; 0xff
    19cc:	d00b      	beq.n	19e6 <update_LEDS_single+0x1e>
	{
		led = 0xfe;
	}
	switch (port_no)
    19ce:	2831      	cmp	r0, #49	; 0x31
    19d0:	d00b      	beq.n	19ea <update_LEDS_single+0x22>
    19d2:	2832      	cmp	r0, #50	; 0x32
    19d4:	d00e      	beq.n	19f4 <update_LEDS_single+0x2c>
			}
			break;
		default:
			break;
	}
	initializing_pin_array();
    19d6:	4b0c      	ldr	r3, [pc, #48]	; (1a08 <update_LEDS_single+0x40>)
    19d8:	4798      	blx	r3
	increasing_sort_tag();
    19da:	4b0c      	ldr	r3, [pc, #48]	; (1a0c <update_LEDS_single+0x44>)
    19dc:	4798      	blx	r3
	update_compare_array = true;
    19de:	2201      	movs	r2, #1
    19e0:	4b0b      	ldr	r3, [pc, #44]	; (1a10 <update_LEDS_single+0x48>)
    19e2:	701a      	strb	r2, [r3, #0]

}
    19e4:	bd10      	pop	{r4, pc}
		led = 0xfe;
    19e6:	3901      	subs	r1, #1
    19e8:	e7f1      	b.n	19ce <update_LEDS_single+0x6>
			temp_compare_array_2[6] = 255 - led;//Led1
    19ea:	43c9      	mvns	r1, r1
    19ec:	b2c9      	uxtb	r1, r1
    19ee:	4b09      	ldr	r3, [pc, #36]	; (1a14 <update_LEDS_single+0x4c>)
    19f0:	7199      	strb	r1, [r3, #6]
			break;
    19f2:	e7f0      	b.n	19d6 <update_LEDS_single+0xe>
		    if(status_battery == false)
    19f4:	4b08      	ldr	r3, [pc, #32]	; (1a18 <update_LEDS_single+0x50>)
    19f6:	781b      	ldrb	r3, [r3, #0]
    19f8:	2b00      	cmp	r3, #0
    19fa:	d1ec      	bne.n	19d6 <update_LEDS_single+0xe>
				temp_compare_array_2[7] = 255  -led;//Led4
    19fc:	43c9      	mvns	r1, r1
    19fe:	b2c9      	uxtb	r1, r1
    1a00:	4b04      	ldr	r3, [pc, #16]	; (1a14 <update_LEDS_single+0x4c>)
    1a02:	71d9      	strb	r1, [r3, #7]
    1a04:	e7e7      	b.n	19d6 <update_LEDS_single+0xe>
    1a06:	46c0      	nop			; (mov r8, r8)
    1a08:	00002e91 	.word	0x00002e91
    1a0c:	00002c6d 	.word	0x00002c6d
    1a10:	200000f8 	.word	0x200000f8
    1a14:	2000034c 	.word	0x2000034c
    1a18:	2000000e 	.word	0x2000000e

00001a1c <switch_off_ORB_LED>:


void switch_off_ORB_LED()
{
    1a1c:	b510      	push	{r4, lr}
	temp_compare_array_2[0] = 255;//Left  -- R
    1a1e:	4b09      	ldr	r3, [pc, #36]	; (1a44 <switch_off_ORB_LED+0x28>)
    1a20:	22ff      	movs	r2, #255	; 0xff
    1a22:	701a      	strb	r2, [r3, #0]
	temp_compare_array_2[1] = 255;//Left  -- G
    1a24:	705a      	strb	r2, [r3, #1]
	temp_compare_array_2[2] = 255;//Left  -- B
    1a26:	709a      	strb	r2, [r3, #2]
	temp_compare_array_2[3] = 255;//Right -- R
    1a28:	70da      	strb	r2, [r3, #3]
	temp_compare_array_2[4] = 255;//Right -- G
    1a2a:	711a      	strb	r2, [r3, #4]
	temp_compare_array_2[5] = 255;//Right -- B
    1a2c:	715a      	strb	r2, [r3, #5]
	temp_compare_array_2[6] = 255;//Led1
    1a2e:	719a      	strb	r2, [r3, #6]
	temp_compare_array_2[7] = 255;//Led4
    1a30:	71da      	strb	r2, [r3, #7]
	initializing_pin_array();
    1a32:	4b05      	ldr	r3, [pc, #20]	; (1a48 <switch_off_ORB_LED+0x2c>)
    1a34:	4798      	blx	r3
	increasing_sort_tag();
    1a36:	4b05      	ldr	r3, [pc, #20]	; (1a4c <switch_off_ORB_LED+0x30>)
    1a38:	4798      	blx	r3
	update_compare_array = true;
    1a3a:	2201      	movs	r2, #1
    1a3c:	4b04      	ldr	r3, [pc, #16]	; (1a50 <switch_off_ORB_LED+0x34>)
    1a3e:	701a      	strb	r2, [r3, #0]
    1a40:	bd10      	pop	{r4, pc}
    1a42:	46c0      	nop			; (mov r8, r8)
    1a44:	2000034c 	.word	0x2000034c
    1a48:	00002e91 	.word	0x00002e91
    1a4c:	00002c6d 	.word	0x00002c6d
    1a50:	200000f8 	.word	0x200000f8

00001a54 <filter_volatge_monitor>:
voltage reading. Read only the max values of the filtered values. Check if the value received is 
in limits of the previous  if not add to the overall value, if not ignore the value for 5 times before
adding it to the main value.
********************************************************************************************/
uint8_t filter_volatge_monitor(uint8_t sensor_input)
{
    1a54:	b510      	push	{r4, lr}
	uint8_t sensor_output = 0;
	static uint8_t sensor_output_inf_filter = 0;
	static uint8_t init = false; 
	static uint8_t out_range = 0;
	if(init == false)
    1a56:	4b18      	ldr	r3, [pc, #96]	; (1ab8 <filter_volatge_monitor+0x64>)
    1a58:	781b      	ldrb	r3, [r3, #0]
    1a5a:	2b00      	cmp	r3, #0
    1a5c:	d104      	bne.n	1a68 <filter_volatge_monitor+0x14>
	{
		init = true;
    1a5e:	2201      	movs	r2, #1
    1a60:	4b15      	ldr	r3, [pc, #84]	; (1ab8 <filter_volatge_monitor+0x64>)
    1a62:	701a      	strb	r2, [r3, #0]
		sensor_output_inf_filter = sensor_input;
    1a64:	4b15      	ldr	r3, [pc, #84]	; (1abc <filter_volatge_monitor+0x68>)
    1a66:	7018      	strb	r0, [r3, #0]
	}
	//sensor_output_inf_filter = (9*sensor_output_inf_filter + sensor_input)/10;
	if((sensor_input < (sensor_output_inf_filter + THRESHOLD_NOISE)) && (sensor_input > (sensor_output_inf_filter - THRESHOLD_NOISE)))
    1a68:	4a14      	ldr	r2, [pc, #80]	; (1abc <filter_volatge_monitor+0x68>)
    1a6a:	7812      	ldrb	r2, [r2, #0]
    1a6c:	1d51      	adds	r1, r2, #5
    1a6e:	4288      	cmp	r0, r1
    1a70:	da02      	bge.n	1a78 <filter_volatge_monitor+0x24>
    1a72:	1f51      	subs	r1, r2, #5
    1a74:	4288      	cmp	r0, r1
    1a76:	dc09      	bgt.n	1a8c <filter_volatge_monitor+0x38>
		sensor_output_inf_filter = (9*sensor_output_inf_filter + sensor_input)/10;
		out_range = 0;
	}
	else
	{
		out_range++;
    1a78:	4911      	ldr	r1, [pc, #68]	; (1ac0 <filter_volatge_monitor+0x6c>)
    1a7a:	780b      	ldrb	r3, [r1, #0]
    1a7c:	3301      	adds	r3, #1
    1a7e:	b2db      	uxtb	r3, r3
    1a80:	700b      	strb	r3, [r1, #0]
		if(out_range == THRESHOLD_OUT_RANGE)
    1a82:	2b03      	cmp	r3, #3
    1a84:	d00e      	beq.n	1aa4 <filter_volatge_monitor+0x50>
			sensor_output_inf_filter = (9*sensor_output_inf_filter + sensor_input)/10;
		}
	}
	
	sensor_output   = sensor_output_inf_filter;
	return sensor_output;
    1a86:	4b0d      	ldr	r3, [pc, #52]	; (1abc <filter_volatge_monitor+0x68>)
    1a88:	7818      	ldrb	r0, [r3, #0]
}
    1a8a:	bd10      	pop	{r4, pc}
		sensor_output_inf_filter = (9*sensor_output_inf_filter + sensor_input)/10;
    1a8c:	00d3      	lsls	r3, r2, #3
    1a8e:	189a      	adds	r2, r3, r2
    1a90:	1810      	adds	r0, r2, r0
    1a92:	210a      	movs	r1, #10
    1a94:	4b0b      	ldr	r3, [pc, #44]	; (1ac4 <filter_volatge_monitor+0x70>)
    1a96:	4798      	blx	r3
    1a98:	4b08      	ldr	r3, [pc, #32]	; (1abc <filter_volatge_monitor+0x68>)
    1a9a:	7018      	strb	r0, [r3, #0]
		out_range = 0;
    1a9c:	2200      	movs	r2, #0
    1a9e:	4b08      	ldr	r3, [pc, #32]	; (1ac0 <filter_volatge_monitor+0x6c>)
    1aa0:	701a      	strb	r2, [r3, #0]
    1aa2:	e7f0      	b.n	1a86 <filter_volatge_monitor+0x32>
			sensor_output_inf_filter = (9*sensor_output_inf_filter + sensor_input)/10;
    1aa4:	00d3      	lsls	r3, r2, #3
    1aa6:	189a      	adds	r2, r3, r2
    1aa8:	1810      	adds	r0, r2, r0
    1aaa:	210a      	movs	r1, #10
    1aac:	4b05      	ldr	r3, [pc, #20]	; (1ac4 <filter_volatge_monitor+0x70>)
    1aae:	4798      	blx	r3
    1ab0:	4b02      	ldr	r3, [pc, #8]	; (1abc <filter_volatge_monitor+0x68>)
    1ab2:	7018      	strb	r0, [r3, #0]
    1ab4:	e7e7      	b.n	1a86 <filter_volatge_monitor+0x32>
    1ab6:	46c0      	nop			; (mov r8, r8)
    1ab8:	20000097 	.word	0x20000097
    1abc:	2000009b 	.word	0x2000009b
    1ac0:	20000099 	.word	0x20000099
    1ac4:	000037c9 	.word	0x000037c9

00001ac8 <read_all_sensors>:


void read_all_sensors()
{
    1ac8:	b5f0      	push	{r4, r5, r6, r7, lr}
    1aca:	b083      	sub	sp, #12
    1acc:	2400      	movs	r4, #0
	
	uint8_t i = 0;
	
	for(i= 0; i< NO_SENSORS; i++)
	{
		temp_sensor_outputs[i] = adc_start_read_result(sensor_analog_inputs[i]);
    1ace:	4e29      	ldr	r6, [pc, #164]	; (1b74 <read_all_sensors+0xac>)
    1ad0:	4f29      	ldr	r7, [pc, #164]	; (1b78 <read_all_sensors+0xb0>)
    1ad2:	e030      	b.n	1b36 <read_all_sensors+0x6e>
		if(i==BATTERY_MONITOR_SENSOR_VALUE)
		{
			//look for maximum values to remove the noise
			max_value = filter_volatge_monitor(temp_sensor_outputs[i]);
    1ad4:	4b29      	ldr	r3, [pc, #164]	; (1b7c <read_all_sensors+0xb4>)
    1ad6:	4798      	blx	r3
			if(overall_max_value <= max_value)
    1ad8:	4b29      	ldr	r3, [pc, #164]	; (1b80 <read_all_sensors+0xb8>)
    1ada:	781b      	ldrb	r3, [r3, #0]
    1adc:	4298      	cmp	r0, r3
    1ade:	d304      	bcc.n	1aea <read_all_sensors+0x22>
			{
				if(overall_max_value == max_value)
    1ae0:	d120      	bne.n	1b24 <read_all_sensors+0x5c>
				{
					count_max_value++;
    1ae2:	4a28      	ldr	r2, [pc, #160]	; (1b84 <read_all_sensors+0xbc>)
    1ae4:	7813      	ldrb	r3, [r2, #0]
    1ae6:	3301      	adds	r3, #1
    1ae8:	7013      	strb	r3, [r2, #0]
					count_max_value = 0;
					overall_max_value = max_value;
				}
			}
			
			if(init == false)
    1aea:	4b27      	ldr	r3, [pc, #156]	; (1b88 <read_all_sensors+0xc0>)
    1aec:	781b      	ldrb	r3, [r3, #0]
    1aee:	2b00      	cmp	r3, #0
    1af0:	d003      	beq.n	1afa <read_all_sensors+0x32>
			{
				temp_sensor_outputs[i] = temp_sensor_outputs[i] ;
			}
			else
			{
				temp_sensor_outputs[i] = battery_voltage ;
    1af2:	4b26      	ldr	r3, [pc, #152]	; (1b8c <read_all_sensors+0xc4>)
    1af4:	781a      	ldrb	r2, [r3, #0]
    1af6:	ab01      	add	r3, sp, #4
    1af8:	70da      	strb	r2, [r3, #3]
			}				
		}
		//To make sure firmware version is sent uncorrupted during the start when micro::bit asks for it 
		if(firmware_check == false)
    1afa:	4b25      	ldr	r3, [pc, #148]	; (1b90 <read_all_sensors+0xc8>)
    1afc:	781b      	ldrb	r3, [r3, #0]
    1afe:	2b00      	cmp	r3, #0
    1b00:	d026      	beq.n	1b50 <read_all_sensors+0x88>
		{
			sensor_outputs[i]      = temp_sensor_outputs[i] ;
		}
		
	}
	sensor_outputs[4] = temp_sensor_outputs[0];
    1b02:	aa01      	add	r2, sp, #4
    1b04:	7811      	ldrb	r1, [r2, #0]
    1b06:	4b23      	ldr	r3, [pc, #140]	; (1b94 <read_all_sensors+0xcc>)
    1b08:	7119      	strb	r1, [r3, #4]
	sensor_outputs[5] = temp_sensor_outputs[1];
    1b0a:	7852      	ldrb	r2, [r2, #1]
    1b0c:	715a      	strb	r2, [r3, #5]
	//make sure we have enough values we update the battery value
	test_count++;
    1b0e:	4a22      	ldr	r2, [pc, #136]	; (1b98 <read_all_sensors+0xd0>)
    1b10:	8813      	ldrh	r3, [r2, #0]
    1b12:	3301      	adds	r3, #1
    1b14:	b29b      	uxth	r3, r3
    1b16:	8013      	strh	r3, [r2, #0]
	if(test_count == 1000)
    1b18:	22fa      	movs	r2, #250	; 0xfa
    1b1a:	0092      	lsls	r2, r2, #2
    1b1c:	4293      	cmp	r3, r2
    1b1e:	d01c      	beq.n	1b5a <read_all_sensors+0x92>
		battery_voltage = overall_max_value;
		test_count		=	0;
		overall_max_value = 0;
	}
	
}
    1b20:	b003      	add	sp, #12
    1b22:	bdf0      	pop	{r4, r5, r6, r7, pc}
					count_max_value = 0;
    1b24:	2200      	movs	r2, #0
    1b26:	4b17      	ldr	r3, [pc, #92]	; (1b84 <read_all_sensors+0xbc>)
    1b28:	701a      	strb	r2, [r3, #0]
					overall_max_value = max_value;
    1b2a:	4b15      	ldr	r3, [pc, #84]	; (1b80 <read_all_sensors+0xb8>)
    1b2c:	7018      	strb	r0, [r3, #0]
    1b2e:	e7dc      	b.n	1aea <read_all_sensors+0x22>
    1b30:	3401      	adds	r4, #1
	for(i= 0; i< NO_SENSORS; i++)
    1b32:	2c04      	cmp	r4, #4
    1b34:	d0e5      	beq.n	1b02 <read_all_sensors+0x3a>
		temp_sensor_outputs[i] = adc_start_read_result(sensor_analog_inputs[i]);
    1b36:	0025      	movs	r5, r4
    1b38:	5da0      	ldrb	r0, [r4, r6]
    1b3a:	47b8      	blx	r7
    1b3c:	b2c0      	uxtb	r0, r0
    1b3e:	ab01      	add	r3, sp, #4
    1b40:	54e0      	strb	r0, [r4, r3]
		if(i==BATTERY_MONITOR_SENSOR_VALUE)
    1b42:	b2e3      	uxtb	r3, r4
    1b44:	2b03      	cmp	r3, #3
    1b46:	d0c5      	beq.n	1ad4 <read_all_sensors+0xc>
		if(firmware_check == false)
    1b48:	4b11      	ldr	r3, [pc, #68]	; (1b90 <read_all_sensors+0xc8>)
    1b4a:	781b      	ldrb	r3, [r3, #0]
    1b4c:	2b00      	cmp	r3, #0
    1b4e:	d1ef      	bne.n	1b30 <read_all_sensors+0x68>
			sensor_outputs[i]      = temp_sensor_outputs[i] ;
    1b50:	ab01      	add	r3, sp, #4
    1b52:	5ce3      	ldrb	r3, [r4, r3]
    1b54:	4a0f      	ldr	r2, [pc, #60]	; (1b94 <read_all_sensors+0xcc>)
    1b56:	5553      	strb	r3, [r2, r5]
    1b58:	e7ea      	b.n	1b30 <read_all_sensors+0x68>
		init			=	true ;
    1b5a:	2201      	movs	r2, #1
    1b5c:	4b0a      	ldr	r3, [pc, #40]	; (1b88 <read_all_sensors+0xc0>)
    1b5e:	701a      	strb	r2, [r3, #0]
		battery_voltage = overall_max_value;
    1b60:	4b07      	ldr	r3, [pc, #28]	; (1b80 <read_all_sensors+0xb8>)
    1b62:	7819      	ldrb	r1, [r3, #0]
    1b64:	4a09      	ldr	r2, [pc, #36]	; (1b8c <read_all_sensors+0xc4>)
    1b66:	7011      	strb	r1, [r2, #0]
		test_count		=	0;
    1b68:	2100      	movs	r1, #0
    1b6a:	4a0b      	ldr	r2, [pc, #44]	; (1b98 <read_all_sensors+0xd0>)
    1b6c:	8011      	strh	r1, [r2, #0]
		overall_max_value = 0;
    1b6e:	2200      	movs	r2, #0
    1b70:	701a      	strb	r2, [r3, #0]
}
    1b72:	e7d5      	b.n	1b20 <read_all_sensors+0x58>
    1b74:	00003c64 	.word	0x00003c64
    1b78:	00001c29 	.word	0x00001c29
    1b7c:	00001a55 	.word	0x00001a55
    1b80:	2000009a 	.word	0x2000009a
    1b84:	20000096 	.word	0x20000096
    1b88:	20000098 	.word	0x20000098
    1b8c:	200000f0 	.word	0x200000f0
    1b90:	200000f1 	.word	0x200000f1
    1b94:	200002f8 	.word	0x200002f8
    1b98:	2000009c 	.word	0x2000009c

00001b9c <configure_adc>:
Sampling time -- 8Mhz/16
Max value of ADC -- 255 
For HUmmingBird Bit board 3.3V/1.48 = 2.29
/********************************************************************************************/
void configure_adc()
{
    1b9c:	b510      	push	{r4, lr}
    1b9e:	b08c      	sub	sp, #48	; 0x30
	struct adc_config conf_adc;
	adc_get_config_defaults(&conf_adc);
    1ba0:	4668      	mov	r0, sp
    1ba2:	4b1a      	ldr	r3, [pc, #104]	; (1c0c <configure_adc+0x70>)
    1ba4:	4798      	blx	r3
	adc_result = malloc(sizeof(uint16_t));
    1ba6:	2002      	movs	r0, #2
    1ba8:	4b19      	ldr	r3, [pc, #100]	; (1c10 <configure_adc+0x74>)
    1baa:	4798      	blx	r3
    1bac:	4b19      	ldr	r3, [pc, #100]	; (1c14 <configure_adc+0x78>)
    1bae:	6018      	str	r0, [r3, #0]

	conf_adc.reference			= ADC_REFCTRL_REFSEL_INTVCC0;
    1bb0:	2301      	movs	r3, #1
    1bb2:	466a      	mov	r2, sp
    1bb4:	7053      	strb	r3, [r2, #1]
	conf_adc.clock_prescaler	= ADC_CLOCK_PRESCALER_DIV16;
    1bb6:	2280      	movs	r2, #128	; 0x80
    1bb8:	0092      	lsls	r2, r2, #2
    1bba:	4669      	mov	r1, sp
    1bbc:	804a      	strh	r2, [r1, #2]
	conf_adc.positive_input		= 6;
    1bbe:	3afb      	subs	r2, #251	; 0xfb
    1bc0:	3aff      	subs	r2, #255	; 0xff
    1bc2:	730a      	strb	r2, [r1, #12]
	conf_adc.negative_input		= ADC_NEGATIVE_INPUT_GND;
    1bc4:	22c0      	movs	r2, #192	; 0xc0
    1bc6:	0152      	lsls	r2, r2, #5
    1bc8:	81ca      	strh	r2, [r1, #14]
	conf_adc.resolution			= ADC_RESOLUTION_8BIT;
    1bca:	2230      	movs	r2, #48	; 0x30
    1bcc:	710a      	strb	r2, [r1, #4]
	conf_adc.left_adjust		= true;
    1bce:	466a      	mov	r2, sp
    1bd0:	748b      	strb	r3, [r1, #18]

	adc_init(&adc_instance, ADC, &conf_adc);
    1bd2:	4c11      	ldr	r4, [pc, #68]	; (1c18 <configure_adc+0x7c>)
    1bd4:	4911      	ldr	r1, [pc, #68]	; (1c1c <configure_adc+0x80>)
    1bd6:	0020      	movs	r0, r4
    1bd8:	4b11      	ldr	r3, [pc, #68]	; (1c20 <configure_adc+0x84>)
    1bda:	4798      	blx	r3
		struct adc_module *const module_inst)
{
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
    1bdc:	6822      	ldr	r2, [r4, #0]
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;

	if (adc_module->STATUS.reg & ADC_STATUS_SYNCBUSY) {
    1bde:	7e53      	ldrb	r3, [r2, #25]

	while (adc_is_syncing(module_inst)) {
    1be0:	b25b      	sxtb	r3, r3
    1be2:	2b00      	cmp	r3, #0
    1be4:	dbfb      	blt.n	1bde <configure_adc+0x42>
    1be6:	2180      	movs	r1, #128	; 0x80
    1be8:	0209      	lsls	r1, r1, #8
    1bea:	4b0e      	ldr	r3, [pc, #56]	; (1c24 <configure_adc+0x88>)
    1bec:	6019      	str	r1, [r3, #0]
		system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_ADC);
#   endif
#endif

	/* Disbale interrupt */
	adc_module->INTENCLR.reg = ADC_INTENCLR_MASK;
    1bee:	230f      	movs	r3, #15
    1bf0:	7593      	strb	r3, [r2, #22]
	/* Clear interrupt flag */
	adc_module->INTFLAG.reg = ADC_INTFLAG_MASK;
    1bf2:	7613      	strb	r3, [r2, #24]

	adc_module->CTRLA.reg |= ADC_CTRLA_ENABLE;
    1bf4:	7813      	ldrb	r3, [r2, #0]
    1bf6:	2102      	movs	r1, #2
    1bf8:	430b      	orrs	r3, r1
    1bfa:	7013      	strb	r3, [r2, #0]
	Adc *const adc_module = module_inst->hw;
    1bfc:	4b06      	ldr	r3, [pc, #24]	; (1c18 <configure_adc+0x7c>)
    1bfe:	681a      	ldr	r2, [r3, #0]
	if (adc_module->STATUS.reg & ADC_STATUS_SYNCBUSY) {
    1c00:	7e53      	ldrb	r3, [r2, #25]

	while (adc_is_syncing(module_inst)) {
    1c02:	b25b      	sxtb	r3, r3
    1c04:	2b00      	cmp	r3, #0
    1c06:	dbfb      	blt.n	1c00 <configure_adc+0x64>
	adc_enable(&adc_instance);
}
    1c08:	b00c      	add	sp, #48	; 0x30
    1c0a:	bd10      	pop	{r4, pc}
    1c0c:	000011dd 	.word	0x000011dd
    1c10:	000039e9 	.word	0x000039e9
    1c14:	200000a0 	.word	0x200000a0
    1c18:	2000024c 	.word	0x2000024c
    1c1c:	42002000 	.word	0x42002000
    1c20:	00001225 	.word	0x00001225
    1c24:	e000e100 	.word	0xe000e100

00001c28 <adc_start_read_result>:


uint16_t adc_start_read_result(const enum adc_positive_input analogPin)
{	
    1c28:	b530      	push	{r4, r5, lr}
{
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
    1c2a:	4b2d      	ldr	r3, [pc, #180]	; (1ce0 <adc_start_read_result+0xb8>)
    1c2c:	6819      	ldr	r1, [r3, #0]
    1c2e:	7e4b      	ldrb	r3, [r1, #25]

	while (adc_is_syncing(module_inst)) {
    1c30:	b25b      	sxtb	r3, r3
    1c32:	2b00      	cmp	r3, #0
    1c34:	dbfb      	blt.n	1c2e <adc_start_read_result+0x6>
		/* Wait for synchronization */
	}

	/* Set positive input pin */
	adc_module->INPUTCTRL.reg =
			(adc_module->INPUTCTRL.reg & ~ADC_INPUTCTRL_MUXPOS_Msk) |
    1c36:	690b      	ldr	r3, [r1, #16]
    1c38:	221f      	movs	r2, #31
    1c3a:	4393      	bics	r3, r2
    1c3c:	4318      	orrs	r0, r3
	adc_module->INPUTCTRL.reg =
    1c3e:	6108      	str	r0, [r1, #16]
    1c40:	7e4b      	ldrb	r3, [r1, #25]
			(positive_input);

	while (adc_is_syncing(module_inst)) {
    1c42:	b25b      	sxtb	r3, r3
    1c44:	2b00      	cmp	r3, #0
    1c46:	dbfb      	blt.n	1c40 <adc_start_read_result+0x18>
    1c48:	7e4b      	ldrb	r3, [r1, #25]
	while (adc_is_syncing(module_inst)) {
    1c4a:	b25b      	sxtb	r3, r3
    1c4c:	2b00      	cmp	r3, #0
    1c4e:	dbfb      	blt.n	1c48 <adc_start_read_result+0x20>
	adc_module->SWTRIG.reg |= ADC_SWTRIG_START;
    1c50:	7b0b      	ldrb	r3, [r1, #12]
    1c52:	2202      	movs	r2, #2
    1c54:	4313      	orrs	r3, r2
    1c56:	730b      	strb	r3, [r1, #12]
    1c58:	7e4b      	ldrb	r3, [r1, #25]
	while (adc_is_syncing(module_inst)) {
    1c5a:	b25b      	sxtb	r3, r3
    1c5c:	2b00      	cmp	r3, #0
    1c5e:	dbfb      	blt.n	1c58 <adc_start_read_result+0x30>
	if (int_flags & ADC_INTFLAG_RESRDY) {
    1c60:	2001      	movs	r0, #1
	if (int_flags & ADC_INTFLAG_WINMON) {
    1c62:	2504      	movs	r5, #4
		status_flags |= ADC_STATUS_WINDOW;
    1c64:	2402      	movs	r4, #2
    1c66:	e001      	b.n	1c6c <adc_start_read_result+0x44>
	uint16_t temp = 0;
	adc_set_positive_input(&adc_instance, analogPin );
	adc_start_conversion(&adc_instance);
	while((adc_get_status(&adc_instance) & ADC_STATUS_RESULT_READY) != 1);
    1c68:	4210      	tst	r0, r2
    1c6a:	d10a      	bne.n	1c82 <adc_start_read_result+0x5a>
	uint32_t int_flags = adc_module->INTFLAG.reg;
    1c6c:	7e0b      	ldrb	r3, [r1, #24]
    1c6e:	b2db      	uxtb	r3, r3
	if (int_flags & ADC_INTFLAG_RESRDY) {
    1c70:	0002      	movs	r2, r0
    1c72:	401a      	ands	r2, r3
	if (int_flags & ADC_INTFLAG_WINMON) {
    1c74:	421d      	tst	r5, r3
    1c76:	d000      	beq.n	1c7a <adc_start_read_result+0x52>
		status_flags |= ADC_STATUS_WINDOW;
    1c78:	4322      	orrs	r2, r4
	if (int_flags & ADC_INTFLAG_OVERRUN) {
    1c7a:	421c      	tst	r4, r3
    1c7c:	d0f4      	beq.n	1c68 <adc_start_read_result+0x40>
		status_flags |= ADC_STATUS_OVERRUN;
    1c7e:	432a      	orrs	r2, r5
    1c80:	e7f2      	b.n	1c68 <adc_start_read_result+0x40>
	uint32_t int_flags = adc_module->INTFLAG.reg;
    1c82:	7e0a      	ldrb	r2, [r1, #24]
    1c84:	b2d2      	uxtb	r2, r2
	if (int_flags & ADC_INTFLAG_RESRDY) {
    1c86:	2301      	movs	r3, #1
    1c88:	4013      	ands	r3, r2
	if (int_flags & ADC_INTFLAG_WINMON) {
    1c8a:	0750      	lsls	r0, r2, #29
    1c8c:	d501      	bpl.n	1c92 <adc_start_read_result+0x6a>
		status_flags |= ADC_STATUS_WINDOW;
    1c8e:	2002      	movs	r0, #2
    1c90:	4303      	orrs	r3, r0
	if (int_flags & ADC_INTFLAG_OVERRUN) {
    1c92:	0792      	lsls	r2, r2, #30
    1c94:	d501      	bpl.n	1c9a <adc_start_read_result+0x72>
		status_flags |= ADC_STATUS_OVERRUN;
    1c96:	2204      	movs	r2, #4
    1c98:	4313      	orrs	r3, r2
	if (!(adc_get_status(module_inst) & ADC_STATUS_RESULT_READY)) {
    1c9a:	07db      	lsls	r3, r3, #31
    1c9c:	d403      	bmi.n	1ca6 <adc_start_read_result+0x7e>
	adc_read(&adc_instance, adc_result);
	temp = *adc_result;
    1c9e:	4b11      	ldr	r3, [pc, #68]	; (1ce4 <adc_start_read_result+0xbc>)
    1ca0:	681b      	ldr	r3, [r3, #0]
 	return temp;
    1ca2:	8818      	ldrh	r0, [r3, #0]
}
    1ca4:	bd30      	pop	{r4, r5, pc}
    1ca6:	7e4b      	ldrb	r3, [r1, #25]
	while (adc_is_syncing(module_inst)) {
    1ca8:	b25b      	sxtb	r3, r3
    1caa:	2b00      	cmp	r3, #0
    1cac:	dbfb      	blt.n	1ca6 <adc_start_read_result+0x7e>
	adc_read(&adc_instance, adc_result);
    1cae:	4b0d      	ldr	r3, [pc, #52]	; (1ce4 <adc_start_read_result+0xbc>)
    1cb0:	681b      	ldr	r3, [r3, #0]
	*result = adc_module->RESULT.reg;
    1cb2:	8b4a      	ldrh	r2, [r1, #26]
    1cb4:	801a      	strh	r2, [r3, #0]
	Adc *const adc_module = module_inst->hw;
    1cb6:	4b0a      	ldr	r3, [pc, #40]	; (1ce0 <adc_start_read_result+0xb8>)
    1cb8:	6819      	ldr	r1, [r3, #0]
	adc_module->INTFLAG.reg = int_flags;
    1cba:	2301      	movs	r3, #1
    1cbc:	760b      	strb	r3, [r1, #24]
	uint32_t int_flags = adc_module->INTFLAG.reg;
    1cbe:	7e0a      	ldrb	r2, [r1, #24]
    1cc0:	b2d2      	uxtb	r2, r2
	if (int_flags & ADC_INTFLAG_RESRDY) {
    1cc2:	4013      	ands	r3, r2
	if (int_flags & ADC_INTFLAG_WINMON) {
    1cc4:	0750      	lsls	r0, r2, #29
    1cc6:	d501      	bpl.n	1ccc <adc_start_read_result+0xa4>
		status_flags |= ADC_STATUS_WINDOW;
    1cc8:	2002      	movs	r0, #2
    1cca:	4303      	orrs	r3, r0
	if (int_flags & ADC_INTFLAG_OVERRUN) {
    1ccc:	0792      	lsls	r2, r2, #30
    1cce:	d501      	bpl.n	1cd4 <adc_start_read_result+0xac>
		status_flags |= ADC_STATUS_OVERRUN;
    1cd0:	2204      	movs	r2, #4
    1cd2:	4313      	orrs	r3, r2
	if (adc_get_status(module_inst) & ADC_STATUS_OVERRUN) {
    1cd4:	075b      	lsls	r3, r3, #29
    1cd6:	d5e2      	bpl.n	1c9e <adc_start_read_result+0x76>
	adc_module->INTFLAG.reg = int_flags;
    1cd8:	2302      	movs	r3, #2
    1cda:	760b      	strb	r3, [r1, #24]
    1cdc:	e7df      	b.n	1c9e <adc_start_read_result+0x76>
    1cde:	46c0      	nop			; (mov r8, r8)
    1ce0:	2000024c 	.word	0x2000024c
    1ce4:	200000a0 	.word	0x200000a0

00001ce8 <sensor_init>:
	port_pin_set_config(SENSOR3, &config_port_pin);	

}

void sensor_init()
{
    1ce8:	b510      	push	{r4, lr}
	configure_adc();
    1cea:	4b01      	ldr	r3, [pc, #4]	; (1cf0 <sensor_init+0x8>)
    1cec:	4798      	blx	r3
    1cee:	bd10      	pop	{r4, pc}
    1cf0:	00001b9d 	.word	0x00001b9d

00001cf4 <enable_super_servo>:
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	Tcc *const tcc_module = module_inst->hw;
    1cf4:	4b05      	ldr	r3, [pc, #20]	; (1d0c <enable_super_servo+0x18>)
    1cf6:	681a      	ldr	r2, [r3, #0]

	while (tcc_module->SYNCBUSY.reg & TCC_SYNCBUSY_ENABLE) {
    1cf8:	2102      	movs	r1, #2
    1cfa:	6893      	ldr	r3, [r2, #8]
    1cfc:	4219      	tst	r1, r3
    1cfe:	d1fc      	bne.n	1cfa <enable_super_servo+0x6>
		/* Wait for sync */
	}

	/* Enable the TCC module */
	tcc_module->CTRLA.reg |= TCC_CTRLA_ENABLE;
    1d00:	6813      	ldr	r3, [r2, #0]
    1d02:	2102      	movs	r1, #2
    1d04:	430b      	orrs	r3, r1
    1d06:	6013      	str	r3, [r2, #0]

/********************************************************************************************/
void enable_super_servo()
{
	tcc_enable(&tcc_ss_instance0); //Enable the TCC module
}
    1d08:	4770      	bx	lr
    1d0a:	46c0      	nop			; (mov r8, r8)
    1d0c:	2000026c 	.word	0x2000026c

00001d10 <super_servo_tcc_init>:
			 |   \|   \
TCC0 module
Four channels are used
********************************************************************************************/
void super_servo_tcc_init()
{
    1d10:	b530      	push	{r4, r5, lr}
    1d12:	b0ab      	sub	sp, #172	; 0xac
	struct tcc_config config_tcc_ss;
	tcc_get_config_defaults(&config_tcc_ss, TCC0);
    1d14:	4d1a      	ldr	r5, [pc, #104]	; (1d80 <super_servo_tcc_init+0x70>)
    1d16:	ac01      	add	r4, sp, #4
    1d18:	0029      	movs	r1, r5
    1d1a:	0020      	movs	r0, r4
    1d1c:	4b19      	ldr	r3, [pc, #100]	; (1d84 <super_servo_tcc_init+0x74>)
    1d1e:	4798      	blx	r3
	
	
	config_tcc_ss.counter.clock_prescaler = TCC_CLOCK_PRESCALER_DIV4;
    1d20:	2302      	movs	r3, #2
    1d22:	72e3      	strb	r3, [r4, #11]
	config_tcc_ss.counter.period = 0x9C40; //40000
    1d24:	4a18      	ldr	r2, [pc, #96]	; (1d88 <super_servo_tcc_init+0x78>)
    1d26:	6062      	str	r2, [r4, #4]
	config_tcc_ss.compare.wave_generation = TCC_WAVE_GENERATION_SINGLE_SLOPE_PWM;
    1d28:	7623      	strb	r3, [r4, #24]
	
	config_tcc_ss.compare.wave_polarity[SERVO_1_CH] = TCC_WAVE_POLARITY_0;
    1d2a:	2300      	movs	r3, #0
    1d2c:	7523      	strb	r3, [r4, #20]
	config_tcc_ss.compare.wave_polarity[SERVO_2_CH] = TCC_WAVE_POLARITY_0;
    1d2e:	7563      	strb	r3, [r4, #21]
	config_tcc_ss.compare.wave_polarity[SERVO_3_CH] = TCC_WAVE_POLARITY_0;
    1d30:	75a3      	strb	r3, [r4, #22]
	config_tcc_ss.compare.wave_polarity[SERVO_4_CH] = TCC_WAVE_POLARITY_0;
    1d32:	75e3      	strb	r3, [r4, #23]
	
	
	config_tcc_ss.compare.match[SERVO_1_CH] = 0;
    1d34:	61e3      	str	r3, [r4, #28]
	config_tcc_ss.pins.enable_wave_out_pin[SERVO_1_WO] = true;
    1d36:	2201      	movs	r2, #1
    1d38:	2198      	movs	r1, #152	; 0x98
    1d3a:	5462      	strb	r2, [r4, r1]
	config_tcc_ss.pins.wave_out_pin[SERVO_1_WO]        = PIN_PA04F_TCC0_WO0; 
    1d3c:	3994      	subs	r1, #148	; 0x94
    1d3e:	65a1      	str	r1, [r4, #88]	; 0x58
	config_tcc_ss.pins.wave_out_pin_mux[SERVO_1_WO]    = PINMUX_PA04F_TCC0_WO0; 
    1d40:	4912      	ldr	r1, [pc, #72]	; (1d8c <super_servo_tcc_init+0x7c>)
    1d42:	67a1      	str	r1, [r4, #120]	; 0x78
	
	
	config_tcc_ss.compare.match[SERVO_2_CH] = 0;
    1d44:	6223      	str	r3, [r4, #32]
	config_tcc_ss.pins.enable_wave_out_pin[SERVO_2_WO] = true;
    1d46:	2199      	movs	r1, #153	; 0x99
    1d48:	5462      	strb	r2, [r4, r1]
	config_tcc_ss.pins.wave_out_pin[SERVO_2_WO]        = PIN_PA05F_TCC0_WO1; 
    1d4a:	3994      	subs	r1, #148	; 0x94
    1d4c:	65e1      	str	r1, [r4, #92]	; 0x5c
	config_tcc_ss.pins.wave_out_pin_mux[SERVO_2_WO]    = PINMUX_PA05F_TCC0_WO1; 
    1d4e:	4910      	ldr	r1, [pc, #64]	; (1d90 <super_servo_tcc_init+0x80>)
    1d50:	67e1      	str	r1, [r4, #124]	; 0x7c
	
	
	config_tcc_ss.compare.match[SERVO_3_CH] = 0;
    1d52:	6263      	str	r3, [r4, #36]	; 0x24
	config_tcc_ss.pins.enable_wave_out_pin[SERVO_3_WO] = true;
    1d54:	219a      	movs	r1, #154	; 0x9a
    1d56:	5462      	strb	r2, [r4, r1]
	config_tcc_ss.pins.wave_out_pin[SERVO_3_WO]        = PIN_PA06F_TCC0_WO2; 
    1d58:	3994      	subs	r1, #148	; 0x94
    1d5a:	6621      	str	r1, [r4, #96]	; 0x60
	config_tcc_ss.pins.wave_out_pin_mux[SERVO_3_WO]    = PINMUX_PA06F_TCC0_WO2; 
    1d5c:	480d      	ldr	r0, [pc, #52]	; (1d94 <super_servo_tcc_init+0x84>)
    1d5e:	317a      	adds	r1, #122	; 0x7a
    1d60:	5060      	str	r0, [r4, r1]
	
	
	config_tcc_ss.compare.match[SERVO_4_CH] = 0;
    1d62:	62a3      	str	r3, [r4, #40]	; 0x28
	config_tcc_ss.pins.enable_wave_out_pin[SERVO_4_WO] = true;
    1d64:	339b      	adds	r3, #155	; 0x9b
    1d66:	54e2      	strb	r2, [r4, r3]
	config_tcc_ss.pins.wave_out_pin[SERVO_4_WO]        = PIN_PA07F_TCC0_WO3; 
    1d68:	3b94      	subs	r3, #148	; 0x94
    1d6a:	6663      	str	r3, [r4, #100]	; 0x64
	config_tcc_ss.pins.wave_out_pin_mux[SERVO_4_WO]    = PINMUX_PA07F_TCC0_WO3; 
    1d6c:	4a0a      	ldr	r2, [pc, #40]	; (1d98 <super_servo_tcc_init+0x88>)
    1d6e:	337d      	adds	r3, #125	; 0x7d
    1d70:	50e2      	str	r2, [r4, r3]
	
	tcc_init(&tcc_ss_instance0, TCC0, &config_tcc_ss);
    1d72:	0022      	movs	r2, r4
    1d74:	0029      	movs	r1, r5
    1d76:	4809      	ldr	r0, [pc, #36]	; (1d9c <super_servo_tcc_init+0x8c>)
    1d78:	4b09      	ldr	r3, [pc, #36]	; (1da0 <super_servo_tcc_init+0x90>)
    1d7a:	4798      	blx	r3
	
}
    1d7c:	b02b      	add	sp, #172	; 0xac
    1d7e:	bd30      	pop	{r4, r5, pc}
    1d80:	42001400 	.word	0x42001400
    1d84:	00002031 	.word	0x00002031
    1d88:	00009c40 	.word	0x00009c40
    1d8c:	00040005 	.word	0x00040005
    1d90:	00050005 	.word	0x00050005
    1d94:	00060005 	.word	0x00060005
    1d98:	00070005 	.word	0x00070005
    1d9c:	2000026c 	.word	0x2000026c
    1da0:	0000216d 	.word	0x0000216d

00001da4 <super_servo_init>:

void super_servo_init()
{
    1da4:	b510      	push	{r4, lr}
	super_servo_tcc_init();
    1da6:	4b01      	ldr	r3, [pc, #4]	; (1dac <super_servo_init+0x8>)
    1da8:	4798      	blx	r3
}
    1daa:	bd10      	pop	{r4, pc}
    1dac:	00001d11 	.word	0x00001d11

00001db0 <update_super_servo>:
/***************************************************************************************
255 is considered as off state 
Servo should work only using battery
****************************************************************************************/
void update_super_servo(uint8_t servo1 , uint8_t servo2 , uint8_t servo3, uint8_t servo4)
{
    1db0:	b570      	push	{r4, r5, r6, lr}
    1db2:	000e      	movs	r6, r1
    1db4:	0015      	movs	r5, r2
    1db6:	001c      	movs	r4, r3
	if(battery_voltage > SERVO_THRESHOLD)
    1db8:	4b39      	ldr	r3, [pc, #228]	; (1ea0 <update_super_servo+0xf0>)
    1dba:	781b      	ldrb	r3, [r3, #0]
    1dbc:	b2db      	uxtb	r3, r3
    1dbe:	2b5f      	cmp	r3, #95	; 0x5f
    1dc0:	d957      	bls.n	1e72 <update_super_servo+0xc2>
	{
		servo_started = true;
    1dc2:	2201      	movs	r2, #1
    1dc4:	4b37      	ldr	r3, [pc, #220]	; (1ea4 <update_super_servo+0xf4>)
    1dc6:	701a      	strb	r2, [r3, #0]
		//Servo--1
		if(servo1 != 255)
    1dc8:	28ff      	cmp	r0, #255	; 0xff
    1dca:	d03a      	beq.n	1e42 <update_super_servo+0x92>
		{
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_1_CH, (((3520*servo1)/254) + 1280));
    1dcc:	23dc      	movs	r3, #220	; 0xdc
    1dce:	011b      	lsls	r3, r3, #4
    1dd0:	4358      	muls	r0, r3
    1dd2:	21fe      	movs	r1, #254	; 0xfe
    1dd4:	4b34      	ldr	r3, [pc, #208]	; (1ea8 <update_super_servo+0xf8>)
    1dd6:	4798      	blx	r3
    1dd8:	23a0      	movs	r3, #160	; 0xa0
    1dda:	00db      	lsls	r3, r3, #3
    1ddc:	18c2      	adds	r2, r0, r3
    1dde:	2100      	movs	r1, #0
    1de0:	4832      	ldr	r0, [pc, #200]	; (1eac <update_super_servo+0xfc>)
    1de2:	4b33      	ldr	r3, [pc, #204]	; (1eb0 <update_super_servo+0x100>)
    1de4:	4798      	blx	r3
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_1_CH, 0);
		}
		
	
		//Servo--2
		if(servo2 != 255)
    1de6:	2eff      	cmp	r6, #255	; 0xff
    1de8:	d031      	beq.n	1e4e <update_super_servo+0x9e>
		{
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_2_CH, (((3520*servo2)/254) + 1280));
    1dea:	20dc      	movs	r0, #220	; 0xdc
    1dec:	0100      	lsls	r0, r0, #4
    1dee:	4370      	muls	r0, r6
    1df0:	21fe      	movs	r1, #254	; 0xfe
    1df2:	4b2d      	ldr	r3, [pc, #180]	; (1ea8 <update_super_servo+0xf8>)
    1df4:	4798      	blx	r3
    1df6:	23a0      	movs	r3, #160	; 0xa0
    1df8:	00db      	lsls	r3, r3, #3
    1dfa:	18c2      	adds	r2, r0, r3
    1dfc:	2101      	movs	r1, #1
    1dfe:	482b      	ldr	r0, [pc, #172]	; (1eac <update_super_servo+0xfc>)
    1e00:	4b2b      	ldr	r3, [pc, #172]	; (1eb0 <update_super_servo+0x100>)
    1e02:	4798      	blx	r3
		{
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_2_CH, 0);
		}
	
		//Servo--3
		if(servo3 != 255)
    1e04:	2dff      	cmp	r5, #255	; 0xff
    1e06:	d028      	beq.n	1e5a <update_super_servo+0xaa>
		{
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_3_CH, (((3520*servo3)/254) + 1280));
    1e08:	20dc      	movs	r0, #220	; 0xdc
    1e0a:	0100      	lsls	r0, r0, #4
    1e0c:	4368      	muls	r0, r5
    1e0e:	21fe      	movs	r1, #254	; 0xfe
    1e10:	4b25      	ldr	r3, [pc, #148]	; (1ea8 <update_super_servo+0xf8>)
    1e12:	4798      	blx	r3
    1e14:	23a0      	movs	r3, #160	; 0xa0
    1e16:	00db      	lsls	r3, r3, #3
    1e18:	18c2      	adds	r2, r0, r3
    1e1a:	2102      	movs	r1, #2
    1e1c:	4823      	ldr	r0, [pc, #140]	; (1eac <update_super_servo+0xfc>)
    1e1e:	4b24      	ldr	r3, [pc, #144]	; (1eb0 <update_super_servo+0x100>)
    1e20:	4798      	blx	r3
		{
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_3_CH, 0);
		}
	
		//Servo--4
		if(servo4 != 255)
    1e22:	2cff      	cmp	r4, #255	; 0xff
    1e24:	d01f      	beq.n	1e66 <update_super_servo+0xb6>
		{
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_4_CH, (((3520*servo4)/254) + 1280));
    1e26:	20dc      	movs	r0, #220	; 0xdc
    1e28:	0100      	lsls	r0, r0, #4
    1e2a:	4360      	muls	r0, r4
    1e2c:	21fe      	movs	r1, #254	; 0xfe
    1e2e:	4b1e      	ldr	r3, [pc, #120]	; (1ea8 <update_super_servo+0xf8>)
    1e30:	4798      	blx	r3
    1e32:	23a0      	movs	r3, #160	; 0xa0
    1e34:	00db      	lsls	r3, r3, #3
    1e36:	18c2      	adds	r2, r0, r3
    1e38:	2103      	movs	r1, #3
    1e3a:	481c      	ldr	r0, [pc, #112]	; (1eac <update_super_servo+0xfc>)
    1e3c:	4b1c      	ldr	r3, [pc, #112]	; (1eb0 <update_super_servo+0x100>)
    1e3e:	4798      	blx	r3
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_4_CH, 0);
		}
		
	}
	
}
    1e40:	bd70      	pop	{r4, r5, r6, pc}
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_1_CH, 0);
    1e42:	2200      	movs	r2, #0
    1e44:	2100      	movs	r1, #0
    1e46:	4819      	ldr	r0, [pc, #100]	; (1eac <update_super_servo+0xfc>)
    1e48:	4b19      	ldr	r3, [pc, #100]	; (1eb0 <update_super_servo+0x100>)
    1e4a:	4798      	blx	r3
    1e4c:	e7cb      	b.n	1de6 <update_super_servo+0x36>
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_2_CH, 0);
    1e4e:	2200      	movs	r2, #0
    1e50:	2101      	movs	r1, #1
    1e52:	4816      	ldr	r0, [pc, #88]	; (1eac <update_super_servo+0xfc>)
    1e54:	4b16      	ldr	r3, [pc, #88]	; (1eb0 <update_super_servo+0x100>)
    1e56:	4798      	blx	r3
    1e58:	e7d4      	b.n	1e04 <update_super_servo+0x54>
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_3_CH, 0);
    1e5a:	2200      	movs	r2, #0
    1e5c:	2102      	movs	r1, #2
    1e5e:	4813      	ldr	r0, [pc, #76]	; (1eac <update_super_servo+0xfc>)
    1e60:	4b13      	ldr	r3, [pc, #76]	; (1eb0 <update_super_servo+0x100>)
    1e62:	4798      	blx	r3
    1e64:	e7dd      	b.n	1e22 <update_super_servo+0x72>
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_4_CH, 0);
    1e66:	2200      	movs	r2, #0
    1e68:	2103      	movs	r1, #3
    1e6a:	4810      	ldr	r0, [pc, #64]	; (1eac <update_super_servo+0xfc>)
    1e6c:	4b10      	ldr	r3, [pc, #64]	; (1eb0 <update_super_servo+0x100>)
    1e6e:	4798      	blx	r3
    1e70:	e7e6      	b.n	1e40 <update_super_servo+0x90>
		if(servo_started == true)
    1e72:	4b0c      	ldr	r3, [pc, #48]	; (1ea4 <update_super_servo+0xf4>)
    1e74:	781b      	ldrb	r3, [r3, #0]
    1e76:	2b00      	cmp	r3, #0
    1e78:	d0e2      	beq.n	1e40 <update_super_servo+0x90>
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_1_CH, 0);
    1e7a:	4d0c      	ldr	r5, [pc, #48]	; (1eac <update_super_servo+0xfc>)
    1e7c:	2200      	movs	r2, #0
    1e7e:	2100      	movs	r1, #0
    1e80:	0028      	movs	r0, r5
    1e82:	4c0b      	ldr	r4, [pc, #44]	; (1eb0 <update_super_servo+0x100>)
    1e84:	47a0      	blx	r4
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_2_CH, 0);
    1e86:	2200      	movs	r2, #0
    1e88:	2101      	movs	r1, #1
    1e8a:	0028      	movs	r0, r5
    1e8c:	47a0      	blx	r4
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_3_CH, 0);
    1e8e:	2200      	movs	r2, #0
    1e90:	2102      	movs	r1, #2
    1e92:	0028      	movs	r0, r5
    1e94:	47a0      	blx	r4
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_4_CH, 0);
    1e96:	2200      	movs	r2, #0
    1e98:	2103      	movs	r1, #3
    1e9a:	0028      	movs	r0, r5
    1e9c:	47a0      	blx	r4
}
    1e9e:	e7cf      	b.n	1e40 <update_super_servo+0x90>
    1ea0:	200000f0 	.word	0x200000f0
    1ea4:	200000a4 	.word	0x200000a4
    1ea8:	000037c9 	.word	0x000037c9
    1eac:	2000026c 	.word	0x2000026c
    1eb0:	000024f5 	.word	0x000024f5

00001eb4 <switch_off_servos>:
{
    1eb4:	b510      	push	{r4, lr}
	update_super_servo(SERVO_OFF_VALUE,SERVO_OFF_VALUE,SERVO_OFF_VALUE,SERVO_OFF_VALUE);
    1eb6:	23ff      	movs	r3, #255	; 0xff
    1eb8:	22ff      	movs	r2, #255	; 0xff
    1eba:	21ff      	movs	r1, #255	; 0xff
    1ebc:	20ff      	movs	r0, #255	; 0xff
    1ebe:	4c01      	ldr	r4, [pc, #4]	; (1ec4 <switch_off_servos+0x10>)
    1ec0:	47a0      	blx	r4
}
    1ec2:	bd10      	pop	{r4, pc}
    1ec4:	00001db1 	.word	0x00001db1

00001ec8 <update_super_servo_single>:

void update_super_servo_single(uint8_t port_no ,uint8_t super_servo)
{
    1ec8:	b570      	push	{r4, r5, r6, lr}
	if(battery_voltage > SERVO_THRESHOLD)
    1eca:	4b40      	ldr	r3, [pc, #256]	; (1fcc <update_super_servo_single+0x104>)
    1ecc:	781b      	ldrb	r3, [r3, #0]
    1ece:	b2db      	uxtb	r3, r3
    1ed0:	2b5f      	cmp	r3, #95	; 0x5f
    1ed2:	d963      	bls.n	1f9c <update_super_servo_single+0xd4>
	{
		servo_started = true;
    1ed4:	2201      	movs	r2, #1
    1ed6:	4b3e      	ldr	r3, [pc, #248]	; (1fd0 <update_super_servo_single+0x108>)
    1ed8:	701a      	strb	r2, [r3, #0]
		switch (port_no)
    1eda:	2832      	cmp	r0, #50	; 0x32
    1edc:	d02c      	beq.n	1f38 <update_super_servo_single+0x70>
    1ede:	d913      	bls.n	1f08 <update_super_servo_single+0x40>
    1ee0:	2833      	cmp	r0, #51	; 0x33
    1ee2:	d03f      	beq.n	1f64 <update_super_servo_single+0x9c>
    1ee4:	2834      	cmp	r0, #52	; 0x34
    1ee6:	d15d      	bne.n	1fa4 <update_super_servo_single+0xdc>
					{
						tcc_set_compare_value(&tcc_ss_instance0, SERVO_3_CH, 0);
					}
					break;
			case '4':
					if(super_servo != 255)
    1ee8:	29ff      	cmp	r1, #255	; 0xff
    1eea:	d051      	beq.n	1f90 <update_super_servo_single+0xc8>
					{
						tcc_set_compare_value(&tcc_ss_instance0, SERVO_4_CH, (((3520*super_servo)/254) + 1280));
    1eec:	20dc      	movs	r0, #220	; 0xdc
    1eee:	0100      	lsls	r0, r0, #4
    1ef0:	4348      	muls	r0, r1
    1ef2:	21fe      	movs	r1, #254	; 0xfe
    1ef4:	4b37      	ldr	r3, [pc, #220]	; (1fd4 <update_super_servo_single+0x10c>)
    1ef6:	4798      	blx	r3
    1ef8:	23a0      	movs	r3, #160	; 0xa0
    1efa:	00db      	lsls	r3, r3, #3
    1efc:	18c2      	adds	r2, r0, r3
    1efe:	2103      	movs	r1, #3
    1f00:	4835      	ldr	r0, [pc, #212]	; (1fd8 <update_super_servo_single+0x110>)
    1f02:	4b36      	ldr	r3, [pc, #216]	; (1fdc <update_super_servo_single+0x114>)
    1f04:	4798      	blx	r3
    1f06:	e04d      	b.n	1fa4 <update_super_servo_single+0xdc>
		switch (port_no)
    1f08:	2831      	cmp	r0, #49	; 0x31
    1f0a:	d14b      	bne.n	1fa4 <update_super_servo_single+0xdc>
					if(super_servo != 255)
    1f0c:	29ff      	cmp	r1, #255	; 0xff
    1f0e:	d00d      	beq.n	1f2c <update_super_servo_single+0x64>
						tcc_set_compare_value(&tcc_ss_instance0, SERVO_1_CH, (((3520*super_servo)/254) + 1280));
    1f10:	20dc      	movs	r0, #220	; 0xdc
    1f12:	0100      	lsls	r0, r0, #4
    1f14:	4348      	muls	r0, r1
    1f16:	21fe      	movs	r1, #254	; 0xfe
    1f18:	4b2e      	ldr	r3, [pc, #184]	; (1fd4 <update_super_servo_single+0x10c>)
    1f1a:	4798      	blx	r3
    1f1c:	23a0      	movs	r3, #160	; 0xa0
    1f1e:	00db      	lsls	r3, r3, #3
    1f20:	18c2      	adds	r2, r0, r3
    1f22:	2100      	movs	r1, #0
    1f24:	482c      	ldr	r0, [pc, #176]	; (1fd8 <update_super_servo_single+0x110>)
    1f26:	4b2d      	ldr	r3, [pc, #180]	; (1fdc <update_super_servo_single+0x114>)
    1f28:	4798      	blx	r3
    1f2a:	e03b      	b.n	1fa4 <update_super_servo_single+0xdc>
						tcc_set_compare_value(&tcc_ss_instance0, SERVO_1_CH, 0);
    1f2c:	2200      	movs	r2, #0
    1f2e:	2100      	movs	r1, #0
    1f30:	4829      	ldr	r0, [pc, #164]	; (1fd8 <update_super_servo_single+0x110>)
    1f32:	4b2a      	ldr	r3, [pc, #168]	; (1fdc <update_super_servo_single+0x114>)
    1f34:	4798      	blx	r3
    1f36:	e035      	b.n	1fa4 <update_super_servo_single+0xdc>
					if(super_servo != 255)
    1f38:	29ff      	cmp	r1, #255	; 0xff
    1f3a:	d00d      	beq.n	1f58 <update_super_servo_single+0x90>
						tcc_set_compare_value(&tcc_ss_instance0, SERVO_2_CH, (((3520*super_servo)/254) + 1280));
    1f3c:	20dc      	movs	r0, #220	; 0xdc
    1f3e:	0100      	lsls	r0, r0, #4
    1f40:	4348      	muls	r0, r1
    1f42:	21fe      	movs	r1, #254	; 0xfe
    1f44:	4b23      	ldr	r3, [pc, #140]	; (1fd4 <update_super_servo_single+0x10c>)
    1f46:	4798      	blx	r3
    1f48:	23a0      	movs	r3, #160	; 0xa0
    1f4a:	00db      	lsls	r3, r3, #3
    1f4c:	18c2      	adds	r2, r0, r3
    1f4e:	2101      	movs	r1, #1
    1f50:	4821      	ldr	r0, [pc, #132]	; (1fd8 <update_super_servo_single+0x110>)
    1f52:	4b22      	ldr	r3, [pc, #136]	; (1fdc <update_super_servo_single+0x114>)
    1f54:	4798      	blx	r3
    1f56:	e025      	b.n	1fa4 <update_super_servo_single+0xdc>
						tcc_set_compare_value(&tcc_ss_instance0, SERVO_2_CH, 0);
    1f58:	2200      	movs	r2, #0
    1f5a:	2101      	movs	r1, #1
    1f5c:	481e      	ldr	r0, [pc, #120]	; (1fd8 <update_super_servo_single+0x110>)
    1f5e:	4b1f      	ldr	r3, [pc, #124]	; (1fdc <update_super_servo_single+0x114>)
    1f60:	4798      	blx	r3
    1f62:	e01f      	b.n	1fa4 <update_super_servo_single+0xdc>
					if(super_servo != 255)
    1f64:	29ff      	cmp	r1, #255	; 0xff
    1f66:	d00d      	beq.n	1f84 <update_super_servo_single+0xbc>
						tcc_set_compare_value(&tcc_ss_instance0, SERVO_3_CH, (((3520*super_servo)/254) + 1280));
    1f68:	20dc      	movs	r0, #220	; 0xdc
    1f6a:	0100      	lsls	r0, r0, #4
    1f6c:	4348      	muls	r0, r1
    1f6e:	21fe      	movs	r1, #254	; 0xfe
    1f70:	4b18      	ldr	r3, [pc, #96]	; (1fd4 <update_super_servo_single+0x10c>)
    1f72:	4798      	blx	r3
    1f74:	23a0      	movs	r3, #160	; 0xa0
    1f76:	00db      	lsls	r3, r3, #3
    1f78:	18c2      	adds	r2, r0, r3
    1f7a:	2102      	movs	r1, #2
    1f7c:	4816      	ldr	r0, [pc, #88]	; (1fd8 <update_super_servo_single+0x110>)
    1f7e:	4b17      	ldr	r3, [pc, #92]	; (1fdc <update_super_servo_single+0x114>)
    1f80:	4798      	blx	r3
    1f82:	e00f      	b.n	1fa4 <update_super_servo_single+0xdc>
						tcc_set_compare_value(&tcc_ss_instance0, SERVO_3_CH, 0);
    1f84:	2200      	movs	r2, #0
    1f86:	2102      	movs	r1, #2
    1f88:	4813      	ldr	r0, [pc, #76]	; (1fd8 <update_super_servo_single+0x110>)
    1f8a:	4b14      	ldr	r3, [pc, #80]	; (1fdc <update_super_servo_single+0x114>)
    1f8c:	4798      	blx	r3
    1f8e:	e009      	b.n	1fa4 <update_super_servo_single+0xdc>
					}
					else
					{
						tcc_set_compare_value(&tcc_ss_instance0, SERVO_4_CH, 0);
    1f90:	2200      	movs	r2, #0
    1f92:	2103      	movs	r1, #3
    1f94:	4810      	ldr	r0, [pc, #64]	; (1fd8 <update_super_servo_single+0x110>)
    1f96:	4b11      	ldr	r3, [pc, #68]	; (1fdc <update_super_servo_single+0x114>)
    1f98:	4798      	blx	r3
    1f9a:	e003      	b.n	1fa4 <update_super_servo_single+0xdc>
					break;
		}
	}
	else
	{
		if(servo_started == true)
    1f9c:	4b0c      	ldr	r3, [pc, #48]	; (1fd0 <update_super_servo_single+0x108>)
    1f9e:	781b      	ldrb	r3, [r3, #0]
    1fa0:	2b00      	cmp	r3, #0
    1fa2:	d100      	bne.n	1fa6 <update_super_servo_single+0xde>
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_3_CH, 0);
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_4_CH, 0);
		}
	}
	
    1fa4:	bd70      	pop	{r4, r5, r6, pc}
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_1_CH, 0);
    1fa6:	4d0c      	ldr	r5, [pc, #48]	; (1fd8 <update_super_servo_single+0x110>)
    1fa8:	2200      	movs	r2, #0
    1faa:	2100      	movs	r1, #0
    1fac:	0028      	movs	r0, r5
    1fae:	4c0b      	ldr	r4, [pc, #44]	; (1fdc <update_super_servo_single+0x114>)
    1fb0:	47a0      	blx	r4
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_2_CH, 0);
    1fb2:	2200      	movs	r2, #0
    1fb4:	2101      	movs	r1, #1
    1fb6:	0028      	movs	r0, r5
    1fb8:	47a0      	blx	r4
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_3_CH, 0);
    1fba:	2200      	movs	r2, #0
    1fbc:	2102      	movs	r1, #2
    1fbe:	0028      	movs	r0, r5
    1fc0:	47a0      	blx	r4
			tcc_set_compare_value(&tcc_ss_instance0, SERVO_4_CH, 0);
    1fc2:	2200      	movs	r2, #0
    1fc4:	2103      	movs	r1, #3
    1fc6:	0028      	movs	r0, r5
    1fc8:	47a0      	blx	r4
    1fca:	e7eb      	b.n	1fa4 <update_super_servo_single+0xdc>
    1fcc:	200000f0 	.word	0x200000f0
    1fd0:	200000a4 	.word	0x200000a4
    1fd4:	000037c9 	.word	0x000037c9
    1fd8:	2000026c 	.word	0x2000026c
    1fdc:	000024f5 	.word	0x000024f5

00001fe0 <_tcc_get_inst_index>:
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
}
    1fe0:	2000      	movs	r0, #0
    1fe2:	4770      	bx	lr

00001fe4 <_tcc_set_compare_value>:

#define PORT_CLEAR_REGISTER_ADD     0x41004414UL
#define PORT_SET_REGISTER_ADD		0x41004418UL
static enum status_code _tcc_set_compare_value(
		const struct tcc_module *const module_inst,
		const enum tcc_match_capture_channel channel_index,
    1fe4:	b530      	push	{r4, r5, lr}
    1fe6:	0004      	movs	r4, r0
	Assert(module_inst->hw);
	uint32_t B2_RGB = 0x08000000;
	uint32_t G2_RGB = 0x00000200;
	volatile uint32_t* const  PORT_SET		      = PORT_SET_REGISTER_ADD;
	volatile uint32_t* const PORT_CLEAR_REGISTER  = PORT_CLEAR_REGISTER_ADD;
	
    1fe8:	2017      	movs	r0, #23
	volatile uint32_t* const PORT_CLEAR_REGISTER  = PORT_CLEAR_REGISTER_ADD;
    1fea:	2903      	cmp	r1, #3
    1fec:	d900      	bls.n	1ff0 <_tcc_set_compare_value+0xc>
		}
		*/
		*PORT_SET            = B2_RGB;
		while(tcc_module->SYNCBUSY.reg  &
				(TCC_SYNCBUSY_CCB0 << channel_index)) {
			/* Sync wait */
    1fee:	bd30      	pop	{r4, r5, pc}
	/* Check index */
    1ff0:	4d0e      	ldr	r5, [pc, #56]	; (202c <_tcc_set_compare_value+0x48>)
    1ff2:	42aa      	cmp	r2, r5
    1ff4:	d8fb      	bhi.n	1fee <_tcc_set_compare_value+0xa>
	Assert(module_inst);
    1ff6:	6820      	ldr	r0, [r4, #0]

    1ff8:	2b00      	cmp	r3, #0
    1ffa:	d00a      	beq.n	2012 <_tcc_set_compare_value+0x2e>
		tcc_module->CCBUF[channel_index].reg = compare;
    1ffc:	2480      	movs	r4, #128	; 0x80
    1ffe:	0324      	lsls	r4, r4, #12
    2000:	408c      	lsls	r4, r1
#if (SAML21) || (SAMC20) || (SAMC21) || (SAML22) || (SAMR30)
    2002:	6883      	ldr	r3, [r0, #8]
    2004:	421c      	tst	r4, r3
    2006:	d1fc      	bne.n	2002 <_tcc_set_compare_value+0x1e>
		/*
    2008:	311c      	adds	r1, #28
    200a:	0089      	lsls	r1, r1, #2
    200c:	500a      	str	r2, [r1, r0]
				(TCC_SYNCBUSY_CCB0 << channel_index)) {
    200e:	2000      	movs	r0, #0
    2010:	e7ed      	b.n	1fee <_tcc_set_compare_value+0xa>
			
    2012:	2480      	movs	r4, #128	; 0x80
    2014:	0064      	lsls	r4, r4, #1
    2016:	408c      	lsls	r4, r1
    2018:	6883      	ldr	r3, [r0, #8]
    201a:	421c      	tst	r4, r3
    201c:	d1fc      	bne.n	2018 <_tcc_set_compare_value+0x34>
		*PORT_SET            = B2_RGB;
    201e:	3110      	adds	r1, #16
    2020:	0089      	lsls	r1, r1, #2
    2022:	1841      	adds	r1, r0, r1
    2024:	604a      	str	r2, [r1, #4]
				(TCC_SYNCBUSY_CCB0 << channel_index)) {
    2026:	2000      	movs	r0, #0
    2028:	e7e1      	b.n	1fee <_tcc_set_compare_value+0xa>
    202a:	46c0      	nop			; (mov r8, r8)
    202c:	00ffffff 	.word	0x00ffffff

00002030 <tcc_get_config_defaults>:
	config->counter.count                  = 0;
    2030:	2300      	movs	r3, #0
    2032:	6003      	str	r3, [r0, #0]
	config->counter.period                 = _tcc_maxs[module_index];
    2034:	4a4c      	ldr	r2, [pc, #304]	; (2168 <tcc_get_config_defaults+0x138>)
    2036:	6042      	str	r2, [r0, #4]
	config->counter.clock_source           = GCLK_GENERATOR_0;
    2038:	7283      	strb	r3, [r0, #10]
	config->counter.clock_prescaler        = TCC_CLOCK_PRESCALER_DIV1;
    203a:	72c3      	strb	r3, [r0, #11]
	config->counter.reload_action          = TCC_RELOAD_ACTION_GCLK;
    203c:	7303      	strb	r3, [r0, #12]
	config->counter.direction              = TCC_COUNT_DIRECTION_UP;
    203e:	7243      	strb	r3, [r0, #9]
	config->counter.oneshot                = false;
    2040:	7203      	strb	r3, [r0, #8]
	MREPEAT(TCC_NUM_CHANNELS,
    2042:	61c3      	str	r3, [r0, #28]
    2044:	6203      	str	r3, [r0, #32]
    2046:	6243      	str	r3, [r0, #36]	; 0x24
    2048:	6283      	str	r3, [r0, #40]	; 0x28
	MREPEAT(TCC_NUM_CHANNELS,
    204a:	7503      	strb	r3, [r0, #20]
    204c:	7543      	strb	r3, [r0, #21]
    204e:	7583      	strb	r3, [r0, #22]
    2050:	75c3      	strb	r3, [r0, #23]
	config->compare.wave_generation = TCC_WAVE_GENERATION_NORMAL_FREQ;
    2052:	7603      	strb	r3, [r0, #24]
	config->compare.wave_ramp       = TCC_RAMP_RAMP1;
    2054:	7643      	strb	r3, [r0, #25]
	MREPEAT(TCC_NUM_CHANNELS,
    2056:	7403      	strb	r3, [r0, #16]
    2058:	7443      	strb	r3, [r0, #17]
    205a:	7483      	strb	r3, [r0, #18]
    205c:	74c3      	strb	r3, [r0, #19]
	MREPEAT(TCC_NUM_FAULTS, _TCC_FAULT_FUNCTION_INIT, 0)
    205e:	222c      	movs	r2, #44	; 0x2c
    2060:	5483      	strb	r3, [r0, r2]
    2062:	3201      	adds	r2, #1
    2064:	5483      	strb	r3, [r0, r2]
    2066:	3201      	adds	r2, #1
    2068:	5483      	strb	r3, [r0, r2]
    206a:	3201      	adds	r2, #1
    206c:	5483      	strb	r3, [r0, r2]
    206e:	3201      	adds	r2, #1
    2070:	5483      	strb	r3, [r0, r2]
    2072:	3201      	adds	r2, #1
    2074:	5483      	strb	r3, [r0, r2]
    2076:	3201      	adds	r2, #1
    2078:	5483      	strb	r3, [r0, r2]
    207a:	3201      	adds	r2, #1
    207c:	5483      	strb	r3, [r0, r2]
    207e:	3201      	adds	r2, #1
    2080:	5483      	strb	r3, [r0, r2]
    2082:	3201      	adds	r2, #1
    2084:	5483      	strb	r3, [r0, r2]
    2086:	3201      	adds	r2, #1
    2088:	5483      	strb	r3, [r0, r2]
    208a:	3201      	adds	r2, #1
    208c:	5483      	strb	r3, [r0, r2]
    208e:	3201      	adds	r2, #1
    2090:	5483      	strb	r3, [r0, r2]
    2092:	3201      	adds	r2, #1
    2094:	5483      	strb	r3, [r0, r2]
    2096:	3201      	adds	r2, #1
    2098:	5483      	strb	r3, [r0, r2]
    209a:	3201      	adds	r2, #1
    209c:	5483      	strb	r3, [r0, r2]
    209e:	3201      	adds	r2, #1
    20a0:	5483      	strb	r3, [r0, r2]
    20a2:	3201      	adds	r2, #1
    20a4:	5483      	strb	r3, [r0, r2]
    20a6:	3201      	adds	r2, #1
    20a8:	5483      	strb	r3, [r0, r2]
    20aa:	3201      	adds	r2, #1
    20ac:	5483      	strb	r3, [r0, r2]
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_NRF_FUNCTION_INIT, 0)
    20ae:	3201      	adds	r2, #1
    20b0:	5483      	strb	r3, [r0, r2]
    20b2:	3201      	adds	r2, #1
    20b4:	5483      	strb	r3, [r0, r2]
    20b6:	3201      	adds	r2, #1
    20b8:	5483      	strb	r3, [r0, r2]
    20ba:	3201      	adds	r2, #1
    20bc:	5483      	strb	r3, [r0, r2]
    20be:	3201      	adds	r2, #1
    20c0:	5483      	strb	r3, [r0, r2]
    20c2:	3201      	adds	r2, #1
    20c4:	5483      	strb	r3, [r0, r2]
    20c6:	3201      	adds	r2, #1
    20c8:	5483      	strb	r3, [r0, r2]
    20ca:	3201      	adds	r2, #1
    20cc:	5483      	strb	r3, [r0, r2]
    20ce:	3201      	adds	r2, #1
    20d0:	5483      	strb	r3, [r0, r2]
    20d2:	3201      	adds	r2, #1
    20d4:	5483      	strb	r3, [r0, r2]
    20d6:	3201      	adds	r2, #1
    20d8:	5483      	strb	r3, [r0, r2]
    20da:	3201      	adds	r2, #1
    20dc:	5483      	strb	r3, [r0, r2]
    20de:	3201      	adds	r2, #1
    20e0:	5483      	strb	r3, [r0, r2]
    20e2:	3201      	adds	r2, #1
    20e4:	5483      	strb	r3, [r0, r2]
    20e6:	3201      	adds	r2, #1
    20e8:	5483      	strb	r3, [r0, r2]
    20ea:	3201      	adds	r2, #1
    20ec:	5483      	strb	r3, [r0, r2]
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_OUT_INVERT_INIT, false)
    20ee:	3201      	adds	r2, #1
    20f0:	5483      	strb	r3, [r0, r2]
    20f2:	3201      	adds	r2, #1
    20f4:	5483      	strb	r3, [r0, r2]
    20f6:	3201      	adds	r2, #1
    20f8:	5483      	strb	r3, [r0, r2]
    20fa:	3201      	adds	r2, #1
    20fc:	5483      	strb	r3, [r0, r2]
    20fe:	3201      	adds	r2, #1
    2100:	5483      	strb	r3, [r0, r2]
    2102:	3201      	adds	r2, #1
    2104:	5483      	strb	r3, [r0, r2]
    2106:	3201      	adds	r2, #1
    2108:	5483      	strb	r3, [r0, r2]
    210a:	3201      	adds	r2, #1
    210c:	5483      	strb	r3, [r0, r2]
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_CHANNEL_OUT_PIN_INIT, 0)
    210e:	3241      	adds	r2, #65	; 0x41
    2110:	5483      	strb	r3, [r0, r2]
    2112:	6583      	str	r3, [r0, #88]	; 0x58
    2114:	6783      	str	r3, [r0, #120]	; 0x78
    2116:	3201      	adds	r2, #1
    2118:	5483      	strb	r3, [r0, r2]
    211a:	65c3      	str	r3, [r0, #92]	; 0x5c
    211c:	67c3      	str	r3, [r0, #124]	; 0x7c
    211e:	3201      	adds	r2, #1
    2120:	5483      	strb	r3, [r0, r2]
    2122:	6603      	str	r3, [r0, #96]	; 0x60
    2124:	3a1a      	subs	r2, #26
    2126:	5083      	str	r3, [r0, r2]
    2128:	321b      	adds	r2, #27
    212a:	5483      	strb	r3, [r0, r2]
    212c:	6643      	str	r3, [r0, #100]	; 0x64
    212e:	3a17      	subs	r2, #23
    2130:	5083      	str	r3, [r0, r2]
    2132:	3218      	adds	r2, #24
    2134:	5483      	strb	r3, [r0, r2]
    2136:	6683      	str	r3, [r0, #104]	; 0x68
    2138:	3a14      	subs	r2, #20
    213a:	5083      	str	r3, [r0, r2]
    213c:	3215      	adds	r2, #21
    213e:	5483      	strb	r3, [r0, r2]
    2140:	66c3      	str	r3, [r0, #108]	; 0x6c
    2142:	3a11      	subs	r2, #17
    2144:	5083      	str	r3, [r0, r2]
    2146:	3212      	adds	r2, #18
    2148:	5483      	strb	r3, [r0, r2]
    214a:	6703      	str	r3, [r0, #112]	; 0x70
    214c:	3a0e      	subs	r2, #14
    214e:	5083      	str	r3, [r0, r2]
    2150:	320f      	adds	r2, #15
    2152:	5483      	strb	r3, [r0, r2]
    2154:	6743      	str	r3, [r0, #116]	; 0x74
    2156:	3a0b      	subs	r2, #11
    2158:	5083      	str	r3, [r0, r2]
	config->double_buffering_enabled  = true;
    215a:	2101      	movs	r1, #1
    215c:	320c      	adds	r2, #12
    215e:	5481      	strb	r1, [r0, r2]
	config->run_in_standby            = false;
    2160:	3201      	adds	r2, #1
    2162:	5483      	strb	r3, [r0, r2]
}
    2164:	4770      	bx	lr
    2166:	46c0      	nop			; (mov r8, r8)
    2168:	00ffffff 	.word	0x00ffffff

0000216c <tcc_init>:
{
    216c:	b5f0      	push	{r4, r5, r6, r7, lr}
    216e:	46de      	mov	lr, fp
    2170:	4657      	mov	r7, sl
    2172:	464e      	mov	r6, r9
    2174:	4645      	mov	r5, r8
    2176:	b5e0      	push	{r5, r6, r7, lr}
    2178:	b08d      	sub	sp, #52	; 0x34
    217a:	0006      	movs	r6, r0
    217c:	000c      	movs	r4, r1
    217e:	0015      	movs	r5, r2
	uint8_t module_index = _tcc_get_inst_index(hw);
    2180:	0008      	movs	r0, r1
    2182:	4bcd      	ldr	r3, [pc, #820]	; (24b8 <tcc_init+0x34c>)
    2184:	4798      	blx	r3
    2186:	0003      	movs	r3, r0
			PM->APBCMASK.reg |= mask;
    2188:	49cc      	ldr	r1, [pc, #816]	; (24bc <tcc_init+0x350>)
    218a:	6a0a      	ldr	r2, [r1, #32]
    218c:	2020      	movs	r0, #32
    218e:	4302      	orrs	r2, r0
    2190:	620a      	str	r2, [r1, #32]
	if (hw->CTRLA.reg & TCC_CTRLA_ENABLE) {
    2192:	6822      	ldr	r2, [r4, #0]
		return STATUS_ERR_DENIED;
    2194:	3804      	subs	r0, #4
	if (hw->CTRLA.reg & TCC_CTRLA_ENABLE) {
    2196:	0792      	lsls	r2, r2, #30
    2198:	d506      	bpl.n	21a8 <tcc_init+0x3c>
}
    219a:	b00d      	add	sp, #52	; 0x34
    219c:	bc3c      	pop	{r2, r3, r4, r5}
    219e:	4690      	mov	r8, r2
    21a0:	4699      	mov	r9, r3
    21a2:	46a2      	mov	sl, r4
    21a4:	46ab      	mov	fp, r5
    21a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (hw->CTRLA.reg & TCC_CTRLA_SWRST) {
    21a8:	6822      	ldr	r2, [r4, #0]
    21aa:	2701      	movs	r7, #1
    21ac:	4017      	ands	r7, r2
    21ae:	d1f4      	bne.n	219a <tcc_init+0x2e>
	if ((config->counter.count > count_max)
    21b0:	4ac3      	ldr	r2, [pc, #780]	; (24c0 <tcc_init+0x354>)
		return STATUS_ERR_INVALID_ARG;
    21b2:	3805      	subs	r0, #5
	if ((config->counter.count > count_max)
    21b4:	6829      	ldr	r1, [r5, #0]
    21b6:	4291      	cmp	r1, r2
    21b8:	d8ef      	bhi.n	219a <tcc_init+0x2e>
		|| (config->counter.period > count_max)
    21ba:	6869      	ldr	r1, [r5, #4]
    21bc:	4291      	cmp	r1, r2
    21be:	d8ec      	bhi.n	219a <tcc_init+0x2e>
		if ((config->compare.match[i] > count_max)
    21c0:	69e9      	ldr	r1, [r5, #28]
    21c2:	4291      	cmp	r1, r2
    21c4:	d900      	bls.n	21c8 <tcc_init+0x5c>
    21c6:	e18b      	b.n	24e0 <tcc_init+0x374>
    21c8:	6a29      	ldr	r1, [r5, #32]
    21ca:	4291      	cmp	r1, r2
    21cc:	d900      	bls.n	21d0 <tcc_init+0x64>
    21ce:	e189      	b.n	24e4 <tcc_init+0x378>
    21d0:	6a69      	ldr	r1, [r5, #36]	; 0x24
    21d2:	4291      	cmp	r1, r2
    21d4:	d900      	bls.n	21d8 <tcc_init+0x6c>
    21d6:	e187      	b.n	24e8 <tcc_init+0x37c>
    21d8:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    21da:	4291      	cmp	r1, r2
    21dc:	d900      	bls.n	21e0 <tcc_init+0x74>
    21de:	e185      	b.n	24ec <tcc_init+0x380>
		if (config->capture.channel_function[i] ==
    21e0:	7c2a      	ldrb	r2, [r5, #16]
    21e2:	3a01      	subs	r2, #1
    21e4:	4250      	negs	r0, r2
    21e6:	4150      	adcs	r0, r2
    21e8:	0602      	lsls	r2, r0, #24
    21ea:	9201      	str	r2, [sp, #4]
    21ec:	7c6a      	ldrb	r2, [r5, #17]
    21ee:	2a01      	cmp	r2, #1
    21f0:	d031      	beq.n	2256 <tcc_init+0xea>
    21f2:	7caa      	ldrb	r2, [r5, #18]
    21f4:	2a01      	cmp	r2, #1
    21f6:	d034      	beq.n	2262 <tcc_init+0xf6>
    21f8:	7cea      	ldrb	r2, [r5, #19]
    21fa:	2a01      	cmp	r2, #1
    21fc:	d037      	beq.n	226e <tcc_init+0x102>
	if (config->run_in_standby) {
    21fe:	22a1      	movs	r2, #161	; 0xa1
    2200:	5caa      	ldrb	r2, [r5, r2]
    2202:	2a00      	cmp	r2, #0
    2204:	d004      	beq.n	2210 <tcc_init+0xa4>
		ctrla |= TCC_CTRLA_RUNSTDBY;
    2206:	2280      	movs	r2, #128	; 0x80
    2208:	0112      	lsls	r2, r2, #4
    220a:	9901      	ldr	r1, [sp, #4]
    220c:	4311      	orrs	r1, r2
    220e:	9101      	str	r1, [sp, #4]
	if (config->counter.oneshot) {
    2210:	7a2a      	ldrb	r2, [r5, #8]
		ctrlb |= TCC_CTRLBSET_ONESHOT;
    2212:	1e51      	subs	r1, r2, #1
    2214:	418a      	sbcs	r2, r1
    2216:	0092      	lsls	r2, r2, #2
    2218:	9203      	str	r2, [sp, #12]
	if (config->counter.direction == TCC_COUNT_DIRECTION_DOWN) {
    221a:	7a6a      	ldrb	r2, [r5, #9]
    221c:	2a01      	cmp	r2, #1
    221e:	d02c      	beq.n	227a <tcc_init+0x10e>
		if (cfg->capture_channel >= cc_num) {
    2220:	2235      	movs	r2, #53	; 0x35
    2222:	5caa      	ldrb	r2, [r5, r2]
    2224:	2a03      	cmp	r2, #3
    2226:	d900      	bls.n	222a <tcc_init+0xbe>
    2228:	e162      	b.n	24f0 <tcc_init+0x384>
		if (cfg->filter_value > 0xF) {
    222a:	212c      	movs	r1, #44	; 0x2c
    222c:	5c69      	ldrb	r1, [r5, r1]
    222e:	290f      	cmp	r1, #15
    2230:	d900      	bls.n	2234 <tcc_init+0xc8>
    2232:	e15d      	b.n	24f0 <tcc_init+0x384>
	ctrla |= config->counter.reload_action << TCC_CTRLA_PRESCSYNC_Pos;
    2234:	7b28      	ldrb	r0, [r5, #12]
    2236:	9004      	str	r0, [sp, #16]
	ctrla |= config->counter.clock_prescaler << TCC_CTRLA_PRESCALER_Pos;
    2238:	7ae8      	ldrb	r0, [r5, #11]
    223a:	9005      	str	r0, [sp, #20]
    223c:	202d      	movs	r0, #45	; 0x2d
    223e:	4682      	mov	sl, r0
    2240:	44aa      	add	sl, r5
    2242:	2000      	movs	r0, #0
				| (cfg->restart ? TCC_FCTRLA_RESTART : 0)
    2244:	9702      	str	r7, [sp, #8]
    2246:	4684      	mov	ip, r0
    2248:	9606      	str	r6, [sp, #24]
    224a:	000e      	movs	r6, r1
    224c:	46a0      	mov	r8, r4
    224e:	4654      	mov	r4, sl
    2250:	46a9      	mov	r9, r5
    2252:	9307      	str	r3, [sp, #28]
    2254:	e047      	b.n	22e6 <tcc_init+0x17a>
			ctrla |= (TCC_CTRLA_CPTEN0 << i);
    2256:	2280      	movs	r2, #128	; 0x80
    2258:	0492      	lsls	r2, r2, #18
    225a:	9901      	ldr	r1, [sp, #4]
    225c:	4311      	orrs	r1, r2
    225e:	9101      	str	r1, [sp, #4]
    2260:	e7c7      	b.n	21f2 <tcc_init+0x86>
    2262:	2280      	movs	r2, #128	; 0x80
    2264:	04d2      	lsls	r2, r2, #19
    2266:	9901      	ldr	r1, [sp, #4]
    2268:	4311      	orrs	r1, r2
    226a:	9101      	str	r1, [sp, #4]
    226c:	e7c4      	b.n	21f8 <tcc_init+0x8c>
    226e:	2280      	movs	r2, #128	; 0x80
    2270:	0512      	lsls	r2, r2, #20
    2272:	9901      	ldr	r1, [sp, #4]
    2274:	4311      	orrs	r1, r2
    2276:	9101      	str	r1, [sp, #4]
    2278:	e7c1      	b.n	21fe <tcc_init+0x92>
		ctrlb |= TCC_CTRLBSET_DIR;
    227a:	9903      	ldr	r1, [sp, #12]
    227c:	4311      	orrs	r1, r2
    227e:	9103      	str	r1, [sp, #12]
    2280:	e7ce      	b.n	2220 <tcc_init+0xb4>
				| TCC_FCTRLA_CHSEL(cfg->capture_channel);
    2282:	0292      	lsls	r2, r2, #10
    2284:	25c0      	movs	r5, #192	; 0xc0
    2286:	012d      	lsls	r5, r5, #4
    2288:	402a      	ands	r2, r5
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
    228a:	4332      	orrs	r2, r6
				| TCC_FCTRLA_SRC(cfg->source)
    228c:	790d      	ldrb	r5, [r1, #4]
    228e:	2603      	movs	r6, #3
    2290:	402e      	ands	r6, r5
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
    2292:	4332      	orrs	r2, r6
    2294:	4655      	mov	r5, sl
    2296:	432a      	orrs	r2, r5
				| TCC_FCTRLA_BLANK(cfg->blanking)
    2298:	794e      	ldrb	r6, [r1, #5]
    229a:	0176      	lsls	r6, r6, #5
    229c:	2560      	movs	r5, #96	; 0x60
    229e:	4035      	ands	r5, r6
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
    22a0:	432a      	orrs	r2, r5
				| TCC_FCTRLA_HALT(cfg->halt_action)
    22a2:	798d      	ldrb	r5, [r1, #6]
    22a4:	022d      	lsls	r5, r5, #8
    22a6:	26c0      	movs	r6, #192	; 0xc0
    22a8:	00b6      	lsls	r6, r6, #2
    22aa:	4035      	ands	r5, r6
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
    22ac:	432a      	orrs	r2, r5
				| TCC_FCTRLA_CAPTURE(cfg->capture_action)
    22ae:	79cd      	ldrb	r5, [r1, #7]
    22b0:	032d      	lsls	r5, r5, #12
    22b2:	26e0      	movs	r6, #224	; 0xe0
    22b4:	01f6      	lsls	r6, r6, #7
    22b6:	4035      	ands	r5, r6
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
    22b8:	432a      	orrs	r2, r5
    22ba:	4310      	orrs	r0, r2
    22bc:	4303      	orrs	r3, r0
    22be:	431f      	orrs	r7, r3
		value_buffer[i] = fault;
    22c0:	ab08      	add	r3, sp, #32
    22c2:	4662      	mov	r2, ip
    22c4:	2008      	movs	r0, #8
    22c6:	181b      	adds	r3, r3, r0
    22c8:	509f      	str	r7, [r3, r2]
	for (i = 0; i < TCC_NUM_FAULTS; i ++) {
    22ca:	2a04      	cmp	r2, #4
    22cc:	d028      	beq.n	2320 <tcc_init+0x1b4>
		if (cfg->capture_channel >= cc_num) {
    22ce:	7c8a      	ldrb	r2, [r1, #18]
    22d0:	2a03      	cmp	r2, #3
    22d2:	d900      	bls.n	22d6 <tcc_init+0x16a>
    22d4:	e10c      	b.n	24f0 <tcc_init+0x384>
		if (cfg->filter_value > 0xF) {
    22d6:	7a4e      	ldrb	r6, [r1, #9]
    22d8:	340a      	adds	r4, #10
    22da:	2304      	movs	r3, #4
    22dc:	469a      	mov	sl, r3
    22de:	44d4      	add	ip, sl
    22e0:	2e0f      	cmp	r6, #15
    22e2:	d900      	bls.n	22e6 <tcc_init+0x17a>
    22e4:	e104      	b.n	24f0 <tcc_init+0x384>
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
    22e6:	0636      	lsls	r6, r6, #24
    22e8:	23f0      	movs	r3, #240	; 0xf0
    22ea:	051b      	lsls	r3, r3, #20
    22ec:	401e      	ands	r6, r3
    22ee:	0021      	movs	r1, r4
				| TCC_FCTRLA_BLANKVAL(cfg->blanking_cycles)
    22f0:	7825      	ldrb	r5, [r4, #0]
    22f2:	042d      	lsls	r5, r5, #16
    22f4:	23ff      	movs	r3, #255	; 0xff
    22f6:	041b      	lsls	r3, r3, #16
    22f8:	401d      	ands	r5, r3
    22fa:	46aa      	mov	sl, r5
				| (cfg->restart ? TCC_FCTRLA_RESTART : 0)
    22fc:	7863      	ldrb	r3, [r4, #1]
    22fe:	2080      	movs	r0, #128	; 0x80
    2300:	2b00      	cmp	r3, #0
    2302:	d100      	bne.n	2306 <tcc_init+0x19a>
    2304:	9802      	ldr	r0, [sp, #8]
				| (cfg->keep ? TCC_FCTRLA_KEEP : 0)
    2306:	788f      	ldrb	r7, [r1, #2]
    2308:	2308      	movs	r3, #8
    230a:	2f00      	cmp	r7, #0
    230c:	d100      	bne.n	2310 <tcc_init+0x1a4>
    230e:	9b02      	ldr	r3, [sp, #8]
				| (cfg->qualification ? TCC_FCTRLA_QUAL : 0)
    2310:	78cf      	ldrb	r7, [r1, #3]
    2312:	46bb      	mov	fp, r7
    2314:	2710      	movs	r7, #16
    2316:	465d      	mov	r5, fp
    2318:	2d00      	cmp	r5, #0
    231a:	d1b2      	bne.n	2282 <tcc_init+0x116>
    231c:	9f02      	ldr	r7, [sp, #8]
    231e:	e7b0      	b.n	2282 <tcc_init+0x116>
    2320:	9e06      	ldr	r6, [sp, #24]
    2322:	4644      	mov	r4, r8
    2324:	464d      	mov	r5, r9
    2326:	9b07      	ldr	r3, [sp, #28]
    2328:	4648      	mov	r0, r9
    232a:	3050      	adds	r0, #80	; 0x50
    232c:	4649      	mov	r1, r9
    232e:	3141      	adds	r1, #65	; 0x41
	for (i = 0; i < TCC_NUM_FAULTS; i ++) {
    2330:	2200      	movs	r2, #0
			drvctrl |= (TCC_DRVCTRL_INVEN0 << i);
    2332:	2780      	movs	r7, #128	; 0x80
    2334:	027f      	lsls	r7, r7, #9
    2336:	46bc      	mov	ip, r7
				drvctrl |= (TCC_DRVCTRL_NRE0) << i;
    2338:	2701      	movs	r7, #1
    233a:	46b9      	mov	r9, r7
				drvctrl |= (TCC_DRVCTRL_NRE0 | TCC_DRVCTRL_NRV0) << i;
    233c:	2702      	movs	r7, #2
    233e:	37ff      	adds	r7, #255	; 0xff
    2340:	46ba      	mov	sl, r7
    2342:	001f      	movs	r7, r3
    2344:	0013      	movs	r3, r2
    2346:	46a0      	mov	r8, r4
    2348:	003c      	movs	r4, r7
    234a:	e007      	b.n	235c <tcc_init+0x1f0>
    234c:	4657      	mov	r7, sl
    234e:	4097      	lsls	r7, r2
    2350:	433b      	orrs	r3, r7
	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
    2352:	3201      	adds	r2, #1
    2354:	3001      	adds	r0, #1
    2356:	3102      	adds	r1, #2
    2358:	2a08      	cmp	r2, #8
    235a:	d00e      	beq.n	237a <tcc_init+0x20e>
		if (config->wave_ext.invert[i]) {
    235c:	7807      	ldrb	r7, [r0, #0]
    235e:	2f00      	cmp	r7, #0
    2360:	d002      	beq.n	2368 <tcc_init+0x1fc>
			drvctrl |= (TCC_DRVCTRL_INVEN0 << i);
    2362:	4667      	mov	r7, ip
    2364:	4097      	lsls	r7, r2
    2366:	433b      	orrs	r3, r7
		if (config->wave_ext.non_recoverable_fault[i].output !=
    2368:	780f      	ldrb	r7, [r1, #0]
    236a:	2f00      	cmp	r7, #0
    236c:	d0f1      	beq.n	2352 <tcc_init+0x1e6>
			if (config->wave_ext.non_recoverable_fault[i].output ==
    236e:	2f02      	cmp	r7, #2
    2370:	d0ec      	beq.n	234c <tcc_init+0x1e0>
				drvctrl |= (TCC_DRVCTRL_NRE0) << i;
    2372:	464f      	mov	r7, r9
    2374:	4097      	lsls	r7, r2
    2376:	433b      	orrs	r3, r7
    2378:	e7eb      	b.n	2352 <tcc_init+0x1e6>
    237a:	0022      	movs	r2, r4
    237c:	4644      	mov	r4, r8
    237e:	4698      	mov	r8, r3
    2380:	0013      	movs	r3, r2
	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
    2382:	7e6a      	ldrb	r2, [r5, #25]
    2384:	0112      	lsls	r2, r2, #4
    2386:	2130      	movs	r1, #48	; 0x30
    2388:	4011      	ands	r1, r2
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);
    238a:	7e28      	ldrb	r0, [r5, #24]
    238c:	2207      	movs	r2, #7
    238e:	4002      	ands	r2, r0
	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
    2390:	4311      	orrs	r1, r2
	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
    2392:	2200      	movs	r2, #0
			wave |= (TCC_WAVE_POL0 << n);
    2394:	2080      	movs	r0, #128	; 0x80
    2396:	0240      	lsls	r0, r0, #9
    2398:	000f      	movs	r7, r1
    239a:	e002      	b.n	23a2 <tcc_init+0x236>
	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
    239c:	3201      	adds	r2, #1
    239e:	2a04      	cmp	r2, #4
    23a0:	d007      	beq.n	23b2 <tcc_init+0x246>
		if (wav_cfg->wave_polarity[n]) {
    23a2:	18a9      	adds	r1, r5, r2
    23a4:	7d09      	ldrb	r1, [r1, #20]
    23a6:	2900      	cmp	r1, #0
    23a8:	d0f8      	beq.n	239c <tcc_init+0x230>
			wave |= (TCC_WAVE_POL0 << n);
    23aa:	0001      	movs	r1, r0
    23ac:	4091      	lsls	r1, r2
    23ae:	430f      	orrs	r7, r1
    23b0:	e7f4      	b.n	239c <tcc_init+0x230>
    23b2:	46b9      	mov	r9, r7
    23b4:	1d32      	adds	r2, r6, #4
    23b6:	0030      	movs	r0, r6
    23b8:	3034      	adds	r0, #52	; 0x34
		module_inst->callback[i] = NULL;
    23ba:	2100      	movs	r1, #0
    23bc:	c202      	stmia	r2!, {r1}
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
    23be:	4290      	cmp	r0, r2
    23c0:	d1fc      	bne.n	23bc <tcc_init+0x250>
	module_inst->register_callback_mask = 0;
    23c2:	2200      	movs	r2, #0
    23c4:	6372      	str	r2, [r6, #52]	; 0x34
	module_inst->enable_callback_mask = 0;
    23c6:	63b2      	str	r2, [r6, #56]	; 0x38
	_tcc_instances[module_index] = module_inst;
    23c8:	009b      	lsls	r3, r3, #2
    23ca:	4a3e      	ldr	r2, [pc, #248]	; (24c4 <tcc_init+0x358>)
    23cc:	509e      	str	r6, [r3, r2]
	module_inst->hw = hw;
    23ce:	6034      	str	r4, [r6, #0]
	module_inst->double_buffering_enabled = config->double_buffering_enabled;
    23d0:	23a0      	movs	r3, #160	; 0xa0
    23d2:	5cea      	ldrb	r2, [r5, r3]
    23d4:	3b64      	subs	r3, #100	; 0x64
    23d6:	54f2      	strb	r2, [r6, r3]
	gclk_chan_config.source_generator = config->counter.clock_source;
    23d8:	a909      	add	r1, sp, #36	; 0x24
    23da:	7aab      	ldrb	r3, [r5, #10]
    23dc:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(_tcc_gclk_ids[module_index], &gclk_chan_config);
    23de:	2011      	movs	r0, #17
    23e0:	4b39      	ldr	r3, [pc, #228]	; (24c8 <tcc_init+0x35c>)
    23e2:	4798      	blx	r3
	system_gclk_chan_enable(_tcc_gclk_ids[module_index]);
    23e4:	2011      	movs	r0, #17
    23e6:	4b39      	ldr	r3, [pc, #228]	; (24cc <tcc_init+0x360>)
    23e8:	4798      	blx	r3
    23ea:	002f      	movs	r7, r5
    23ec:	3798      	adds	r7, #152	; 0x98
    23ee:	002e      	movs	r6, r5
    23f0:	3658      	adds	r6, #88	; 0x58
    23f2:	2378      	movs	r3, #120	; 0x78
    23f4:	469a      	mov	sl, r3
    23f6:	44aa      	add	sl, r5
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    23f8:	3b77      	subs	r3, #119	; 0x77
    23fa:	469b      	mov	fp, r3
		system_pinmux_pin_set_config(
    23fc:	0023      	movs	r3, r4
    23fe:	4654      	mov	r4, sl
    2400:	469a      	mov	sl, r3
    2402:	e003      	b.n	240c <tcc_init+0x2a0>
    2404:	3701      	adds	r7, #1
    2406:	3604      	adds	r6, #4
	for (i = 0; i <  _tcc_ow_nums[module_index]; i ++) {
    2408:	42b4      	cmp	r4, r6
    240a:	d014      	beq.n	2436 <tcc_init+0x2ca>
		if (!config->pins.enable_wave_out_pin[i]) {
    240c:	783b      	ldrb	r3, [r7, #0]
    240e:	2b00      	cmp	r3, #0
    2410:	d0f8      	beq.n	2404 <tcc_init+0x298>
    2412:	ab08      	add	r3, sp, #32
    2414:	465a      	mov	r2, fp
    2416:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    2418:	2300      	movs	r3, #0
    241a:	aa08      	add	r2, sp, #32
    241c:	70d3      	strb	r3, [r2, #3]
		pin_config.mux_position = config->pins.wave_out_pin_mux[i];
    241e:	0013      	movs	r3, r2
    2420:	2220      	movs	r2, #32
    2422:	18b2      	adds	r2, r6, r2
    2424:	7812      	ldrb	r2, [r2, #0]
    2426:	701a      	strb	r2, [r3, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    2428:	465a      	mov	r2, fp
    242a:	705a      	strb	r2, [r3, #1]
		system_pinmux_pin_set_config(
    242c:	7830      	ldrb	r0, [r6, #0]
    242e:	0019      	movs	r1, r3
    2430:	4b27      	ldr	r3, [pc, #156]	; (24d0 <tcc_init+0x364>)
    2432:	4798      	blx	r3
    2434:	e7e6      	b.n	2404 <tcc_init+0x298>
    2436:	4654      	mov	r4, sl
	ctrla |= config->counter.reload_action << TCC_CTRLA_PRESCSYNC_Pos;
    2438:	9b04      	ldr	r3, [sp, #16]
    243a:	031b      	lsls	r3, r3, #12
	ctrla |= config->counter.clock_prescaler << TCC_CTRLA_PRESCALER_Pos;
    243c:	9a05      	ldr	r2, [sp, #20]
    243e:	0212      	lsls	r2, r2, #8
    2440:	4313      	orrs	r3, r2
    2442:	9a01      	ldr	r2, [sp, #4]
    2444:	4313      	orrs	r3, r2
	hw->CTRLA.reg = ctrla;
    2446:	6023      	str	r3, [r4, #0]
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_CTRLB) {
    2448:	2204      	movs	r2, #4
    244a:	68a3      	ldr	r3, [r4, #8]
    244c:	421a      	tst	r2, r3
    244e:	d1fc      	bne.n	244a <tcc_init+0x2de>
	hw->CTRLBCLR.reg = 0xFF;
    2450:	23ff      	movs	r3, #255	; 0xff
    2452:	7123      	strb	r3, [r4, #4]
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_CTRLB) {
    2454:	2204      	movs	r2, #4
    2456:	68a3      	ldr	r3, [r4, #8]
    2458:	421a      	tst	r2, r3
    245a:	d1fc      	bne.n	2456 <tcc_init+0x2ea>
	hw->CTRLBSET.reg = ctrlb;
    245c:	466b      	mov	r3, sp
    245e:	7b1b      	ldrb	r3, [r3, #12]
    2460:	7163      	strb	r3, [r4, #5]
	hw->FCTRLA.reg = faults[0];
    2462:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2464:	60e3      	str	r3, [r4, #12]
	hw->FCTRLB.reg = faults[1];
    2466:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2468:	6123      	str	r3, [r4, #16]
	hw->DRVCTRL.reg = drvctrl;
    246a:	4643      	mov	r3, r8
    246c:	61a3      	str	r3, [r4, #24]
	while (hw->SYNCBUSY.reg & (TCC_SYNCBUSY_WAVE | TCC_SYNCBUSY_WAVEB)) {
    246e:	4a19      	ldr	r2, [pc, #100]	; (24d4 <tcc_init+0x368>)
    2470:	68a3      	ldr	r3, [r4, #8]
    2472:	4213      	tst	r3, r2
    2474:	d1fc      	bne.n	2470 <tcc_init+0x304>
	hw->WAVE.reg = waves[0];
    2476:	464b      	mov	r3, r9
    2478:	63e3      	str	r3, [r4, #60]	; 0x3c
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_COUNT) {
    247a:	2210      	movs	r2, #16
    247c:	68a3      	ldr	r3, [r4, #8]
    247e:	421a      	tst	r2, r3
    2480:	d1fc      	bne.n	247c <tcc_init+0x310>
	hw->COUNT.reg = config->counter.count;
    2482:	682b      	ldr	r3, [r5, #0]
    2484:	6363      	str	r3, [r4, #52]	; 0x34
	while (hw->SYNCBUSY.reg & (TCC_SYNCBUSY_PER | TCC_SYNCBUSY_PERB)) {
    2486:	4a14      	ldr	r2, [pc, #80]	; (24d8 <tcc_init+0x36c>)
    2488:	68a3      	ldr	r3, [r4, #8]
    248a:	4213      	tst	r3, r2
    248c:	d1fc      	bne.n	2488 <tcc_init+0x31c>
	hw->PER.reg = (config->counter.period);
    248e:	686b      	ldr	r3, [r5, #4]
    2490:	6423      	str	r3, [r4, #64]	; 0x40
    2492:	351c      	adds	r5, #28
	for (i = 0; i <  _tcc_cc_nums[module_index]; i ++) {
    2494:	2100      	movs	r1, #0
			(TCC_SYNCBUSY_CC0 | TCC_SYNCBUSY_CCB0) << i)) {
    2496:	4811      	ldr	r0, [pc, #68]	; (24dc <tcc_init+0x370>)
    2498:	0002      	movs	r2, r0
    249a:	408a      	lsls	r2, r1
		while (hw->SYNCBUSY.reg & (
    249c:	68a3      	ldr	r3, [r4, #8]
    249e:	421a      	tst	r2, r3
    24a0:	d1fc      	bne.n	249c <tcc_init+0x330>
		hw->CC[i].reg = (config->compare.match[i]);
    24a2:	cd04      	ldmia	r5!, {r2}
    24a4:	000b      	movs	r3, r1
    24a6:	3310      	adds	r3, #16
    24a8:	009b      	lsls	r3, r3, #2
    24aa:	18e3      	adds	r3, r4, r3
    24ac:	605a      	str	r2, [r3, #4]
	for (i = 0; i <  _tcc_cc_nums[module_index]; i ++) {
    24ae:	3101      	adds	r1, #1
    24b0:	2904      	cmp	r1, #4
    24b2:	d1f1      	bne.n	2498 <tcc_init+0x32c>
	return STATUS_OK;
    24b4:	2000      	movs	r0, #0
    24b6:	e670      	b.n	219a <tcc_init+0x2e>
    24b8:	00001fe1 	.word	0x00001fe1
    24bc:	40000400 	.word	0x40000400
    24c0:	00ffffff 	.word	0x00ffffff
    24c4:	200002ac 	.word	0x200002ac
    24c8:	000033cd 	.word	0x000033cd
    24cc:	00003341 	.word	0x00003341
    24d0:	000034c5 	.word	0x000034c5
    24d4:	00020040 	.word	0x00020040
    24d8:	00040080 	.word	0x00040080
    24dc:	00080100 	.word	0x00080100
			return STATUS_ERR_INVALID_ARG;
    24e0:	2017      	movs	r0, #23
    24e2:	e65a      	b.n	219a <tcc_init+0x2e>
    24e4:	2017      	movs	r0, #23
    24e6:	e658      	b.n	219a <tcc_init+0x2e>
    24e8:	2017      	movs	r0, #23
    24ea:	e656      	b.n	219a <tcc_init+0x2e>
    24ec:	2017      	movs	r0, #23
    24ee:	e654      	b.n	219a <tcc_init+0x2e>
    24f0:	2017      	movs	r0, #23
    24f2:	e652      	b.n	219a <tcc_init+0x2e>

000024f4 <tcc_set_compare_value>:
 * \brief Sets a TCC module compare value.
 *
 * Writes a compare value to the given TCC module compare/capture channel.
 *
 * If double buffering is enabled it always write to the buffer
 * register. The value will then be updated immediately by calling
    24f4:	b510      	push	{r4, lr}
 * \ref tcc_force_double_buffer_update(), or be updated when the lock update bit
 * is cleared and the UPDATE condition happen.
 *
 * \param[in]  module_inst    Pointer to the software module instance struct
    24f6:	233c      	movs	r3, #60	; 0x3c
    24f8:	5cc3      	ldrb	r3, [r0, r3]
    24fa:	4c01      	ldr	r4, [pc, #4]	; (2500 <tcc_set_compare_value+0xc>)
    24fc:	47a0      	blx	r4
 * \param[in]  channel_index  Index of the compare channel to write to
 * \param[in]  compare        New compare value to set
    24fe:	bd10      	pop	{r4, pc}
    2500:	00001fe5 	.word	0x00001fe5

00002504 <_tcc_interrupt_handler>:
 * \param[in]  module_index  ID of the TCC instance calling the interrupt
 *                           handler
 */
void _tcc_interrupt_handler(
		uint8_t module_index)
{
    2504:	b5f0      	push	{r4, r5, r6, r7, lr}
    2506:	46c6      	mov	lr, r8
    2508:	b500      	push	{lr}
	int i;

	uint32_t interrupt_and_callback_status_mask;

	struct tcc_module *module =
    250a:	0080      	lsls	r0, r0, #2
    250c:	4b0e      	ldr	r3, [pc, #56]	; (2548 <_tcc_interrupt_handler+0x44>)
    250e:	58c7      	ldr	r7, [r0, r3]
			(struct tcc_module *)_tcc_instances[module_index];

	interrupt_and_callback_status_mask = (module->hw->INTFLAG.reg &
    2510:	683b      	ldr	r3, [r7, #0]
    2512:	6ade      	ldr	r6, [r3, #44]	; 0x2c
    2514:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    2516:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    2518:	4013      	ands	r3, r2
    251a:	401e      	ands	r6, r3
    251c:	2400      	movs	r4, #0
			module->register_callback_mask &
			module->enable_callback_mask);

	/* Check if callback interrupt has occured */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
		if (interrupt_and_callback_status_mask & _tcc_intflag[i]) {
    251e:	4b0b      	ldr	r3, [pc, #44]	; (254c <_tcc_interrupt_handler+0x48>)
    2520:	4698      	mov	r8, r3
    2522:	e002      	b.n	252a <_tcc_interrupt_handler+0x26>
    2524:	3404      	adds	r4, #4
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
    2526:	2c30      	cmp	r4, #48	; 0x30
    2528:	d00a      	beq.n	2540 <_tcc_interrupt_handler+0x3c>
		if (interrupt_and_callback_status_mask & _tcc_intflag[i]) {
    252a:	4643      	mov	r3, r8
    252c:	58e5      	ldr	r5, [r4, r3]
    252e:	4235      	tst	r5, r6
    2530:	d0f8      	beq.n	2524 <_tcc_interrupt_handler+0x20>
			/* Invoke the registered and enabled callback function */
			(module->callback[i])(module);
    2532:	193b      	adds	r3, r7, r4
    2534:	685b      	ldr	r3, [r3, #4]
    2536:	0038      	movs	r0, r7
    2538:	4798      	blx	r3
			/* Clear interrupt flag */
			module->hw->INTFLAG.reg = _tcc_intflag[i];
    253a:	683b      	ldr	r3, [r7, #0]
    253c:	62dd      	str	r5, [r3, #44]	; 0x2c
    253e:	e7f1      	b.n	2524 <_tcc_interrupt_handler+0x20>
		}
	}
}
    2540:	bc04      	pop	{r2}
    2542:	4690      	mov	r8, r2
    2544:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2546:	46c0      	nop			; (mov r8, r8)
    2548:	200002ac 	.word	0x200002ac
    254c:	00003c68 	.word	0x00003c68

00002550 <TCC0_Handler>:
MREPEAT(TCC_INST_NUM, _TCC_INTERRUPT_HANDLER, 0)
    2550:	b510      	push	{r4, lr}
    2552:	2000      	movs	r0, #0
    2554:	4b01      	ldr	r3, [pc, #4]	; (255c <TCC0_Handler+0xc>)
    2556:	4798      	blx	r3
    2558:	bd10      	pop	{r4, pc}
    255a:	46c0      	nop			; (mov r8, r8)
    255c:	00002505 	.word	0x00002505

00002560 <_tc_get_inst_index>:
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if (hw == tc_modules[i]) {
    2560:	4b06      	ldr	r3, [pc, #24]	; (257c <_tc_get_inst_index+0x1c>)
    2562:	4298      	cmp	r0, r3
    2564:	d008      	beq.n	2578 <_tc_get_inst_index+0x18>
    2566:	4a06      	ldr	r2, [pc, #24]	; (2580 <_tc_get_inst_index+0x20>)
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
    2568:	2300      	movs	r3, #0
		if (hw == tc_modules[i]) {
    256a:	4290      	cmp	r0, r2
    256c:	d001      	beq.n	2572 <_tc_get_inst_index+0x12>
}
    256e:	0018      	movs	r0, r3
    2570:	4770      	bx	lr
    2572:	3301      	adds	r3, #1
			return i;
    2574:	b2db      	uxtb	r3, r3
    2576:	e7fa      	b.n	256e <_tc_get_inst_index+0xe>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    2578:	2300      	movs	r3, #0
    257a:	e7fb      	b.n	2574 <_tc_get_inst_index+0x14>
    257c:	42001800 	.word	0x42001800
    2580:	42001c00 	.word	0x42001c00

00002584 <tc_init>:
 */
enum status_code tc_init(
		struct tc_module *const module_inst,
		Tc *const hw,
		const struct tc_config *const config)
{
    2584:	b5f0      	push	{r4, r5, r6, r7, lr}
    2586:	b085      	sub	sp, #20
    2588:	0004      	movs	r4, r0
    258a:	000d      	movs	r5, r1
    258c:	0016      	movs	r6, r2
	uint8_t ctrlbset_tmp = 0;
	/* Temporary variable to hold all updates to the CTRLC
	 * register before they are written to it */
	uint8_t ctrlc_tmp = 0;
	/* Temporary variable to hold TC instance number */
	uint8_t instance = _tc_get_inst_index(hw);
    258e:	0008      	movs	r0, r1
    2590:	4b82      	ldr	r3, [pc, #520]	; (279c <tc_init+0x218>)
    2592:	4798      	blx	r3
    2594:	0007      	movs	r7, r0

	/* Array of GLCK ID for different TC instances */
	uint8_t inst_gclk_id[] = TC_INST_GCLK_ID;
    2596:	ab03      	add	r3, sp, #12
    2598:	2212      	movs	r2, #18
    259a:	701a      	strb	r2, [r3, #0]
    259c:	705a      	strb	r2, [r3, #1]
	/* Array of PM APBC mask bit position for different TC instances */
	uint16_t inst_pm_apbmask[] = TC_INST_PM_APBCMASK;
    259e:	ab02      	add	r3, sp, #8
    25a0:	322e      	adds	r2, #46	; 0x2e
    25a2:	801a      	strh	r2, [r3, #0]
    25a4:	3240      	adds	r2, #64	; 0x40
    25a6:	805a      	strh	r2, [r3, #2]
	struct system_gclk_chan_config gclk_chan_config;

#if TC_ASYNC == true
	/* Initialize parameters */
	for (uint8_t i = 0; i < TC_CALLBACK_N; i++) {
		module_inst->callback[i]        = NULL;
    25a8:	2300      	movs	r3, #0
    25aa:	60a3      	str	r3, [r4, #8]
    25ac:	60e3      	str	r3, [r4, #12]
    25ae:	6123      	str	r3, [r4, #16]
    25b0:	6163      	str	r3, [r4, #20]
	}
	module_inst->register_callback_mask     = 0x00;
    25b2:	7623      	strb	r3, [r4, #24]
	module_inst->enable_callback_mask       = 0x00;
    25b4:	7663      	strb	r3, [r4, #25]

	/* Register this instance for callbacks*/
	_tc_instances[instance] = module_inst;
    25b6:	0082      	lsls	r2, r0, #2
    25b8:	4b79      	ldr	r3, [pc, #484]	; (27a0 <tc_init+0x21c>)
    25ba:	50d4      	str	r4, [r2, r3]
#endif

	/* Associate the given device instance with the hardware module */
	module_inst->hw = hw;
    25bc:	6025      	str	r5, [r4, #0]
#if SAMD09 || SAMD10 || SAMD11 || SAMHA1
	/* Check if even numbered TC modules are being configured in 32-bit
	 * counter size. Only odd numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    25be:	78b3      	ldrb	r3, [r6, #2]
    25c0:	2b08      	cmp	r3, #8
    25c2:	d006      	beq.n	25d2 <tc_init+0x4e>
#endif

	/* Make the counter size variable in the module_inst struct reflect
	 * the counter size in the module
	 */
	module_inst->counter_size = config->counter_size;
    25c4:	7123      	strb	r3, [r4, #4]

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    25c6:	882b      	ldrh	r3, [r5, #0]
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
    25c8:	2005      	movs	r0, #5
	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    25ca:	07db      	lsls	r3, r3, #31
    25cc:	d505      	bpl.n	25da <tc_init+0x56>
			return STATUS_OK;
	}

	Assert(false);
	return STATUS_ERR_INVALID_ARG;
}
    25ce:	b005      	add	sp, #20
    25d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return STATUS_ERR_INVALID_ARG;
    25d2:	2017      	movs	r0, #23
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    25d4:	07fa      	lsls	r2, r7, #31
    25d6:	d4fa      	bmi.n	25ce <tc_init+0x4a>
    25d8:	e7f4      	b.n	25c4 <tc_init+0x40>
	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
    25da:	7beb      	ldrb	r3, [r5, #15]
		return STATUS_ERR_DENIED;
    25dc:	3017      	adds	r0, #23
	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
    25de:	06db      	lsls	r3, r3, #27
    25e0:	d4f5      	bmi.n	25ce <tc_init+0x4a>
	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_ENABLE) {
    25e2:	882b      	ldrh	r3, [r5, #0]
    25e4:	079b      	lsls	r3, r3, #30
    25e6:	d4f2      	bmi.n	25ce <tc_init+0x4a>
	if (config->pwm_channel[0].enabled) {
    25e8:	7c33      	ldrb	r3, [r6, #16]
    25ea:	2b00      	cmp	r3, #0
    25ec:	d000      	beq.n	25f0 <tc_init+0x6c>
    25ee:	e07a      	b.n	26e6 <tc_init+0x162>
	if (config->pwm_channel[1].enabled) {
    25f0:	7f33      	ldrb	r3, [r6, #28]
    25f2:	2b00      	cmp	r3, #0
    25f4:	d000      	beq.n	25f8 <tc_init+0x74>
    25f6:	e082      	b.n	26fe <tc_init+0x17a>
    25f8:	496a      	ldr	r1, [pc, #424]	; (27a4 <tc_init+0x220>)
    25fa:	6a08      	ldr	r0, [r1, #32]
			inst_pm_apbmask[instance]);
    25fc:	007a      	lsls	r2, r7, #1
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
    25fe:	ab02      	add	r3, sp, #8
    2600:	5ad3      	ldrh	r3, [r2, r3]
    2602:	4303      	orrs	r3, r0
    2604:	620b      	str	r3, [r1, #32]
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT))
    2606:	78b3      	ldrb	r3, [r6, #2]
    2608:	2b08      	cmp	r3, #8
    260a:	d100      	bne.n	260e <tc_init+0x8a>
    260c:	e087      	b.n	271e <tc_init+0x19a>
	gclk_chan_config.source_generator = config->clock_source;
    260e:	7833      	ldrb	r3, [r6, #0]
    2610:	466a      	mov	r2, sp
    2612:	7013      	strb	r3, [r2, #0]
	system_gclk_chan_set_config(inst_gclk_id[instance], &gclk_chan_config);
    2614:	ab03      	add	r3, sp, #12
    2616:	5ddf      	ldrb	r7, [r3, r7]
    2618:	4669      	mov	r1, sp
    261a:	0038      	movs	r0, r7
    261c:	4b62      	ldr	r3, [pc, #392]	; (27a8 <tc_init+0x224>)
    261e:	4798      	blx	r3
	system_gclk_chan_enable(inst_gclk_id[instance]);
    2620:	0038      	movs	r0, r7
    2622:	4b62      	ldr	r3, [pc, #392]	; (27ac <tc_init+0x228>)
    2624:	4798      	blx	r3
	ctrla_tmp =
    2626:	8931      	ldrh	r1, [r6, #8]
    2628:	88b3      	ldrh	r3, [r6, #4]
    262a:	430b      	orrs	r3, r1
			(uint32_t)config->wave_generation |
    262c:	78b1      	ldrb	r1, [r6, #2]
    262e:	79b2      	ldrb	r2, [r6, #6]
    2630:	4311      	orrs	r1, r2
	ctrla_tmp =
    2632:	4319      	orrs	r1, r3
	if (config->run_in_standby) {
    2634:	7873      	ldrb	r3, [r6, #1]
    2636:	2b00      	cmp	r3, #0
    2638:	d002      	beq.n	2640 <tc_init+0xbc>
		ctrla_tmp |= TC_CTRLA_RUNSTDBY;
    263a:	2380      	movs	r3, #128	; 0x80
    263c:	011b      	lsls	r3, r3, #4
    263e:	4319      	orrs	r1, r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    2640:	6822      	ldr	r2, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21) || (SAMR30)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    2642:	7bd3      	ldrb	r3, [r2, #15]
	while (tc_is_syncing(module_inst)) {
    2644:	b25b      	sxtb	r3, r3
    2646:	2b00      	cmp	r3, #0
    2648:	dbfb      	blt.n	2642 <tc_init+0xbe>
	hw->COUNT8.CTRLA.reg = ctrla_tmp;
    264a:	8029      	strh	r1, [r5, #0]
	if (config->oneshot) {
    264c:	7b71      	ldrb	r1, [r6, #13]
		ctrlbset_tmp = TC_CTRLBSET_ONESHOT;
    264e:	1e4b      	subs	r3, r1, #1
    2650:	4199      	sbcs	r1, r3
    2652:	0089      	lsls	r1, r1, #2
	if (config->count_direction) {
    2654:	7bb3      	ldrb	r3, [r6, #14]
    2656:	2b00      	cmp	r3, #0
    2658:	d001      	beq.n	265e <tc_init+0xda>
		ctrlbset_tmp |= TC_CTRLBSET_DIR;
    265a:	2301      	movs	r3, #1
    265c:	4319      	orrs	r1, r3
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    265e:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    2660:	7bd3      	ldrb	r3, [r2, #15]
	while (tc_is_syncing(module_inst)) {
    2662:	b25b      	sxtb	r3, r3
    2664:	2b00      	cmp	r3, #0
    2666:	dbfb      	blt.n	2660 <tc_init+0xdc>
	hw->COUNT8.CTRLBCLR.reg = 0xFF;
    2668:	23ff      	movs	r3, #255	; 0xff
    266a:	712b      	strb	r3, [r5, #4]
	if (ctrlbset_tmp) {
    266c:	2900      	cmp	r1, #0
    266e:	d005      	beq.n	267c <tc_init+0xf8>
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    2670:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    2672:	7bd3      	ldrb	r3, [r2, #15]
		while (tc_is_syncing(module_inst)) {
    2674:	b25b      	sxtb	r3, r3
    2676:	2b00      	cmp	r3, #0
    2678:	dbfb      	blt.n	2672 <tc_init+0xee>
		hw->COUNT8.CTRLBSET.reg = ctrlbset_tmp;
    267a:	7169      	strb	r1, [r5, #5]
	ctrlc_tmp = config->waveform_invert_output;
    267c:	7ab1      	ldrb	r1, [r6, #10]
		if (config->enable_capture_on_channel[i] == true) {
    267e:	7af3      	ldrb	r3, [r6, #11]
    2680:	2b00      	cmp	r3, #0
    2682:	d001      	beq.n	2688 <tc_init+0x104>
			ctrlc_tmp |= (TC_CTRLC_CPTEN(1) << i);
    2684:	2310      	movs	r3, #16
    2686:	4319      	orrs	r1, r3
		if (config->enable_capture_on_channel[i] == true) {
    2688:	7b33      	ldrb	r3, [r6, #12]
    268a:	2b00      	cmp	r3, #0
    268c:	d001      	beq.n	2692 <tc_init+0x10e>
			ctrlc_tmp |= (TC_CTRLC_CPTEN(1) << i);
    268e:	2320      	movs	r3, #32
    2690:	4319      	orrs	r1, r3
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    2692:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    2694:	7bd3      	ldrb	r3, [r2, #15]
	while (tc_is_syncing(module_inst)) {
    2696:	b25b      	sxtb	r3, r3
    2698:	2b00      	cmp	r3, #0
    269a:	dbfb      	blt.n	2694 <tc_init+0x110>
	hw->COUNT8.CTRLC.reg = ctrlc_tmp;
    269c:	71a9      	strb	r1, [r5, #6]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    269e:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    26a0:	7bd3      	ldrb	r3, [r2, #15]
	while (tc_is_syncing(module_inst)) {
    26a2:	b25b      	sxtb	r3, r3
    26a4:	2b00      	cmp	r3, #0
    26a6:	dbfb      	blt.n	26a0 <tc_init+0x11c>
	switch (module_inst->counter_size) {
    26a8:	7923      	ldrb	r3, [r4, #4]
    26aa:	2b04      	cmp	r3, #4
    26ac:	d03f      	beq.n	272e <tc_init+0x1aa>
    26ae:	2b08      	cmp	r3, #8
    26b0:	d05e      	beq.n	2770 <tc_init+0x1ec>
	return STATUS_ERR_INVALID_ARG;
    26b2:	2017      	movs	r0, #23
	switch (module_inst->counter_size) {
    26b4:	2b00      	cmp	r3, #0
    26b6:	d000      	beq.n	26ba <tc_init+0x136>
    26b8:	e789      	b.n	25ce <tc_init+0x4a>
    26ba:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    26bc:	b25b      	sxtb	r3, r3
    26be:	2b00      	cmp	r3, #0
    26c0:	dbfb      	blt.n	26ba <tc_init+0x136>
				= config->counter_16_bit.value;
    26c2:	8d33      	ldrh	r3, [r6, #40]	; 0x28
    26c4:	822b      	strh	r3, [r5, #16]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    26c6:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    26c8:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    26ca:	b25b      	sxtb	r3, r3
    26cc:	2b00      	cmp	r3, #0
    26ce:	dbfb      	blt.n	26c8 <tc_init+0x144>
					config->counter_16_bit.compare_capture_channel[0];
    26d0:	8d73      	ldrh	r3, [r6, #42]	; 0x2a
			hw->COUNT16.CC[0].reg =
    26d2:	832b      	strh	r3, [r5, #24]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    26d4:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    26d6:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    26d8:	b25b      	sxtb	r3, r3
    26da:	2b00      	cmp	r3, #0
    26dc:	dbfb      	blt.n	26d6 <tc_init+0x152>
					config->counter_16_bit.compare_capture_channel[1];
    26de:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
			hw->COUNT16.CC[1].reg =
    26e0:	836b      	strh	r3, [r5, #26]
			return STATUS_OK;
    26e2:	2000      	movs	r0, #0
    26e4:	e773      	b.n	25ce <tc_init+0x4a>
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    26e6:	a901      	add	r1, sp, #4
    26e8:	2301      	movs	r3, #1
    26ea:	708b      	strb	r3, [r1, #2]
	config->powersave    = false;
    26ec:	2200      	movs	r2, #0
    26ee:	70ca      	strb	r2, [r1, #3]
		pin_config.mux_position = config->pwm_channel[0].pin_mux;
    26f0:	7e32      	ldrb	r2, [r6, #24]
    26f2:	700a      	strb	r2, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    26f4:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
    26f6:	7d30      	ldrb	r0, [r6, #20]
    26f8:	4b2d      	ldr	r3, [pc, #180]	; (27b0 <tc_init+0x22c>)
    26fa:	4798      	blx	r3
    26fc:	e778      	b.n	25f0 <tc_init+0x6c>
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    26fe:	a901      	add	r1, sp, #4
    2700:	2301      	movs	r3, #1
    2702:	708b      	strb	r3, [r1, #2]
	config->powersave    = false;
    2704:	2200      	movs	r2, #0
    2706:	70ca      	strb	r2, [r1, #3]
		pin_config.mux_position = config->pwm_channel[1].pin_mux;
    2708:	3224      	adds	r2, #36	; 0x24
    270a:	18b2      	adds	r2, r6, r2
    270c:	7812      	ldrb	r2, [r2, #0]
    270e:	700a      	strb	r2, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    2710:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
    2712:	331f      	adds	r3, #31
    2714:	18f3      	adds	r3, r6, r3
    2716:	7818      	ldrb	r0, [r3, #0]
    2718:	4b25      	ldr	r3, [pc, #148]	; (27b0 <tc_init+0x22c>)
    271a:	4798      	blx	r3
    271c:	e76c      	b.n	25f8 <tc_init+0x74>
    271e:	6a08      	ldr	r0, [r1, #32]
				inst_pm_apbmask[instance + 1]);
    2720:	1c7a      	adds	r2, r7, #1
    2722:	0052      	lsls	r2, r2, #1
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
    2724:	ab02      	add	r3, sp, #8
    2726:	5ad3      	ldrh	r3, [r2, r3]
    2728:	4303      	orrs	r3, r0
    272a:	620b      	str	r3, [r1, #32]
    272c:	e76f      	b.n	260e <tc_init+0x8a>
    272e:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    2730:	b25b      	sxtb	r3, r3
    2732:	2b00      	cmp	r3, #0
    2734:	dbfb      	blt.n	272e <tc_init+0x1aa>
					config->counter_8_bit.value;
    2736:	2328      	movs	r3, #40	; 0x28
    2738:	5cf3      	ldrb	r3, [r6, r3]
			hw->COUNT8.COUNT.reg =
    273a:	742b      	strb	r3, [r5, #16]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    273c:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    273e:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    2740:	b25b      	sxtb	r3, r3
    2742:	2b00      	cmp	r3, #0
    2744:	dbfb      	blt.n	273e <tc_init+0x1ba>
					config->counter_8_bit.period;
    2746:	2329      	movs	r3, #41	; 0x29
    2748:	5cf3      	ldrb	r3, [r6, r3]
			hw->COUNT8.PER.reg =
    274a:	752b      	strb	r3, [r5, #20]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    274c:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    274e:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    2750:	b25b      	sxtb	r3, r3
    2752:	2b00      	cmp	r3, #0
    2754:	dbfb      	blt.n	274e <tc_init+0x1ca>
					config->counter_8_bit.compare_capture_channel[0];
    2756:	232a      	movs	r3, #42	; 0x2a
    2758:	5cf3      	ldrb	r3, [r6, r3]
			hw->COUNT8.CC[0].reg =
    275a:	762b      	strb	r3, [r5, #24]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    275c:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    275e:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    2760:	b25b      	sxtb	r3, r3
    2762:	2b00      	cmp	r3, #0
    2764:	dbfb      	blt.n	275e <tc_init+0x1da>
					config->counter_8_bit.compare_capture_channel[1];
    2766:	232b      	movs	r3, #43	; 0x2b
    2768:	5cf3      	ldrb	r3, [r6, r3]
			hw->COUNT8.CC[1].reg =
    276a:	766b      	strb	r3, [r5, #25]
			return STATUS_OK;
    276c:	2000      	movs	r0, #0
    276e:	e72e      	b.n	25ce <tc_init+0x4a>
    2770:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    2772:	b25b      	sxtb	r3, r3
    2774:	2b00      	cmp	r3, #0
    2776:	dbfb      	blt.n	2770 <tc_init+0x1ec>
				= config->counter_32_bit.value;
    2778:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    277a:	612b      	str	r3, [r5, #16]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    277c:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    277e:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    2780:	b25b      	sxtb	r3, r3
    2782:	2b00      	cmp	r3, #0
    2784:	dbfb      	blt.n	277e <tc_init+0x1fa>
			hw->COUNT32.CC[0].reg =
    2786:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    2788:	61ab      	str	r3, [r5, #24]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    278a:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    278c:	7bd3      	ldrb	r3, [r2, #15]
			while (tc_is_syncing(module_inst)) {
    278e:	b25b      	sxtb	r3, r3
    2790:	2b00      	cmp	r3, #0
    2792:	dbfb      	blt.n	278c <tc_init+0x208>
					config->counter_32_bit.compare_capture_channel[1];
    2794:	6b33      	ldr	r3, [r6, #48]	; 0x30
			hw->COUNT32.CC[1].reg =
    2796:	61eb      	str	r3, [r5, #28]
			return STATUS_OK;
    2798:	2000      	movs	r0, #0
    279a:	e718      	b.n	25ce <tc_init+0x4a>
    279c:	00002561 	.word	0x00002561
    27a0:	200002b0 	.word	0x200002b0
    27a4:	40000400 	.word	0x40000400
    27a8:	000033cd 	.word	0x000033cd
    27ac:	00003341 	.word	0x00003341
    27b0:	000034c5 	.word	0x000034c5

000027b4 <tc_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    27b4:	1c93      	adds	r3, r2, #2
    27b6:	009b      	lsls	r3, r3, #2
    27b8:	5019      	str	r1, [r3, r0]

	/* Set the bit corresponding to the callback_type */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
    27ba:	2a02      	cmp	r2, #2
    27bc:	d009      	beq.n	27d2 <tc_register_callback+0x1e>
		module->register_callback_mask |= TC_INTFLAG_MC(1);
	}
	else if (callback_type == TC_CALLBACK_CC_CHANNEL1) {
    27be:	2a03      	cmp	r2, #3
    27c0:	d00c      	beq.n	27dc <tc_register_callback+0x28>
		module->register_callback_mask |= TC_INTFLAG_MC(2);
	}
	else {
		module->register_callback_mask |= (1 << callback_type);
    27c2:	2301      	movs	r3, #1
    27c4:	4093      	lsls	r3, r2
    27c6:	001a      	movs	r2, r3
    27c8:	7e03      	ldrb	r3, [r0, #24]
    27ca:	4313      	orrs	r3, r2
    27cc:	7603      	strb	r3, [r0, #24]
	}
	return STATUS_OK;
}
    27ce:	2000      	movs	r0, #0
    27d0:	4770      	bx	lr
		module->register_callback_mask |= TC_INTFLAG_MC(1);
    27d2:	7e03      	ldrb	r3, [r0, #24]
    27d4:	2210      	movs	r2, #16
    27d6:	4313      	orrs	r3, r2
    27d8:	7603      	strb	r3, [r0, #24]
    27da:	e7f8      	b.n	27ce <tc_register_callback+0x1a>
		module->register_callback_mask |= TC_INTFLAG_MC(2);
    27dc:	7e03      	ldrb	r3, [r0, #24]
    27de:	2220      	movs	r2, #32
    27e0:	4313      	orrs	r3, r2
    27e2:	7603      	strb	r3, [r0, #24]
    27e4:	e7f3      	b.n	27ce <tc_register_callback+0x1a>
	...

000027e8 <_tc_interrupt_handler>:
 * \param[in]  instance  ID of the TC instance calling the interrupt
 *                       handler
 */
void _tc_interrupt_handler(
		uint8_t instance)
{
    27e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    27ea:	46de      	mov	lr, fp
    27ec:	4657      	mov	r7, sl
    27ee:	464e      	mov	r6, r9
    27f0:	4645      	mov	r5, r8
    27f2:	b5e0      	push	{r5, r6, r7, lr}
 



	/* Get device instance from the look-up table */
	struct tc_module *module = (struct tc_module *)_tc_instances[instance];
    27f4:	0080      	lsls	r0, r0, #2
    27f6:	4bb2      	ldr	r3, [pc, #712]	; (2ac0 <_tc_interrupt_handler+0x2d8>)
    27f8:	58c4      	ldr	r4, [r0, r3]

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg & module->register_callback_mask & module->enable_callback_mask;
    27fa:	6823      	ldr	r3, [r4, #0]
    27fc:	7b9b      	ldrb	r3, [r3, #14]
    27fe:	7e22      	ldrb	r2, [r4, #24]
    2800:	7e61      	ldrb	r1, [r4, #25]
    2802:	4011      	ands	r1, r2
    2804:	4019      	ands	r1, r3
			
	/* Check if an Match/Capture Channel 0 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(1)) {
    2806:	06cb      	lsls	r3, r1, #27
    2808:	d400      	bmi.n	280c <_tc_interrupt_handler+0x24>
    280a:	e086      	b.n	291a <_tc_interrupt_handler+0x132>
		
		if(first_time == false)
    280c:	4bad      	ldr	r3, [pc, #692]	; (2ac4 <_tc_interrupt_handler+0x2dc>)
    280e:	781b      	ldrb	r3, [r3, #0]
    2810:	2b00      	cmp	r3, #0
    2812:	d17c      	bne.n	290e <_tc_interrupt_handler+0x126>
		{
			if(compare_array_ID != N_valid_compares)
    2814:	4bac      	ldr	r3, [pc, #688]	; (2ac8 <_tc_interrupt_handler+0x2e0>)
    2816:	781b      	ldrb	r3, [r3, #0]
    2818:	4aac      	ldr	r2, [pc, #688]	; (2acc <_tc_interrupt_handler+0x2e4>)
    281a:	7812      	ldrb	r2, [r2, #0]
    281c:	b2db      	uxtb	r3, r3
    281e:	4293      	cmp	r3, r2
    2820:	d011      	beq.n	2846 <_tc_interrupt_handler+0x5e>
			{
				
				*PORT_SET		 = (1UL << pin_array[pin_array_ID++] ) ;
    2822:	48ab      	ldr	r0, [pc, #684]	; (2ad0 <_tc_interrupt_handler+0x2e8>)
    2824:	7803      	ldrb	r3, [r0, #0]
    2826:	b2db      	uxtb	r3, r3
    2828:	1c5a      	adds	r2, r3, #1
    282a:	b2d2      	uxtb	r2, r2
    282c:	7002      	strb	r2, [r0, #0]
    282e:	4aa9      	ldr	r2, [pc, #676]	; (2ad4 <_tc_interrupt_handler+0x2ec>)
    2830:	5cd2      	ldrb	r2, [r2, r3]
    2832:	b2d2      	uxtb	r2, r2
    2834:	2301      	movs	r3, #1
    2836:	4093      	lsls	r3, r2
    2838:	4aa7      	ldr	r2, [pc, #668]	; (2ad8 <_tc_interrupt_handler+0x2f0>)
    283a:	6013      	str	r3, [r2, #0]
				compare_array_ID = compare_array_ID + 1;
    283c:	4aa2      	ldr	r2, [pc, #648]	; (2ac8 <_tc_interrupt_handler+0x2e0>)
    283e:	7813      	ldrb	r3, [r2, #0]
    2840:	3301      	adds	r3, #1
    2842:	b2db      	uxtb	r3, r3
    2844:	7013      	strb	r3, [r2, #0]
			}
			
			if(compare_array_ID < N_valid_compares )
    2846:	4ba0      	ldr	r3, [pc, #640]	; (2ac8 <_tc_interrupt_handler+0x2e0>)
    2848:	781b      	ldrb	r3, [r3, #0]
    284a:	4aa0      	ldr	r2, [pc, #640]	; (2acc <_tc_interrupt_handler+0x2e4>)
    284c:	7812      	ldrb	r2, [r2, #0]
    284e:	b2db      	uxtb	r3, r3
    2850:	4293      	cmp	r3, r2
    2852:	d25f      	bcs.n	2914 <_tc_interrupt_handler+0x12c>
			{
				compare_value_last    = compare_array[compare_array_ID - 1];
    2854:	4d9c      	ldr	r5, [pc, #624]	; (2ac8 <_tc_interrupt_handler+0x2e0>)
    2856:	782b      	ldrb	r3, [r5, #0]
    2858:	3b01      	subs	r3, #1
    285a:	48a0      	ldr	r0, [pc, #640]	; (2adc <_tc_interrupt_handler+0x2f4>)
    285c:	5cc2      	ldrb	r2, [r0, r3]
    285e:	b2d2      	uxtb	r2, r2
    2860:	4b9f      	ldr	r3, [pc, #636]	; (2ae0 <_tc_interrupt_handler+0x2f8>)
    2862:	701a      	strb	r2, [r3, #0]
				compare_value_current = compare_array[compare_array_ID];
    2864:	782b      	ldrb	r3, [r5, #0]
    2866:	b2db      	uxtb	r3, r3
    2868:	5cc3      	ldrb	r3, [r0, r3]
    286a:	b2db      	uxtb	r3, r3
    286c:	489d      	ldr	r0, [pc, #628]	; (2ae4 <_tc_interrupt_handler+0x2fc>)
    286e:	7003      	strb	r3, [r0, #0]
				while((compare_value_last == compare_value_current) && (compare_array_ID <= N_valid_compares - 1))
    2870:	429a      	cmp	r2, r3
    2872:	d136      	bne.n	28e2 <_tc_interrupt_handler+0xfa>
    2874:	7828      	ldrb	r0, [r5, #0]
    2876:	b2c0      	uxtb	r0, r0
    2878:	4b94      	ldr	r3, [pc, #592]	; (2acc <_tc_interrupt_handler+0x2e4>)
    287a:	781b      	ldrb	r3, [r3, #0]
    287c:	3b01      	subs	r3, #1
    287e:	4298      	cmp	r0, r3
    2880:	dc3c      	bgt.n	28fc <_tc_interrupt_handler+0x114>
				{
			
					*PORT_SET		 = (1UL << pin_array[pin_array_ID++] ) ;
    2882:	4e93      	ldr	r6, [pc, #588]	; (2ad0 <_tc_interrupt_handler+0x2e8>)
    2884:	4b93      	ldr	r3, [pc, #588]	; (2ad4 <_tc_interrupt_handler+0x2ec>)
    2886:	4698      	mov	r8, r3
					compare_value_last	  = compare_array[compare_array_ID];
    2888:	0028      	movs	r0, r5
    288a:	4d94      	ldr	r5, [pc, #592]	; (2adc <_tc_interrupt_handler+0x2f4>)
    288c:	4b94      	ldr	r3, [pc, #592]	; (2ae0 <_tc_interrupt_handler+0x2f8>)
    288e:	469c      	mov	ip, r3
					compare_value_current = compare_array[++compare_array_ID];
    2890:	4f94      	ldr	r7, [pc, #592]	; (2ae4 <_tc_interrupt_handler+0x2fc>)
				while((compare_value_last == compare_value_current) && (compare_array_ID <= N_valid_compares - 1))
    2892:	4682      	mov	sl, r0
    2894:	4b8d      	ldr	r3, [pc, #564]	; (2acc <_tc_interrupt_handler+0x2e4>)
    2896:	4699      	mov	r9, r3
					*PORT_SET		 = (1UL << pin_array[pin_array_ID++] ) ;
    2898:	7833      	ldrb	r3, [r6, #0]
    289a:	b2db      	uxtb	r3, r3
    289c:	1c5a      	adds	r2, r3, #1
    289e:	b2d2      	uxtb	r2, r2
    28a0:	7032      	strb	r2, [r6, #0]
    28a2:	4642      	mov	r2, r8
    28a4:	5cd2      	ldrb	r2, [r2, r3]
    28a6:	b2d2      	uxtb	r2, r2
    28a8:	2301      	movs	r3, #1
    28aa:	4093      	lsls	r3, r2
    28ac:	4a8a      	ldr	r2, [pc, #552]	; (2ad8 <_tc_interrupt_handler+0x2f0>)
    28ae:	6013      	str	r3, [r2, #0]
					compare_value_last	  = compare_array[compare_array_ID];
    28b0:	7803      	ldrb	r3, [r0, #0]
    28b2:	b2db      	uxtb	r3, r3
    28b4:	5cea      	ldrb	r2, [r5, r3]
    28b6:	b2d2      	uxtb	r2, r2
    28b8:	4663      	mov	r3, ip
    28ba:	701a      	strb	r2, [r3, #0]
					compare_value_current = compare_array[++compare_array_ID];
    28bc:	7803      	ldrb	r3, [r0, #0]
    28be:	3301      	adds	r3, #1
    28c0:	b2db      	uxtb	r3, r3
    28c2:	7003      	strb	r3, [r0, #0]
    28c4:	5ceb      	ldrb	r3, [r5, r3]
    28c6:	b2db      	uxtb	r3, r3
    28c8:	703b      	strb	r3, [r7, #0]
				while((compare_value_last == compare_value_current) && (compare_array_ID <= N_valid_compares - 1))
    28ca:	429a      	cmp	r2, r3
    28cc:	d109      	bne.n	28e2 <_tc_interrupt_handler+0xfa>
    28ce:	4652      	mov	r2, sl
    28d0:	7812      	ldrb	r2, [r2, #0]
    28d2:	b2d2      	uxtb	r2, r2
    28d4:	4693      	mov	fp, r2
    28d6:	464a      	mov	r2, r9
    28d8:	7812      	ldrb	r2, [r2, #0]
    28da:	3a01      	subs	r2, #1
    28dc:	4593      	cmp	fp, r2
    28de:	dddb      	ble.n	2898 <_tc_interrupt_handler+0xb0>
					compare_value_current = compare_array[++compare_array_ID];
    28e0:	001a      	movs	r2, r3
				}
				if(compare_value_current != 255)
    28e2:	2bff      	cmp	r3, #255	; 0xff
    28e4:	d00c      	beq.n	2900 <_tc_interrupt_handler+0x118>
				{
					//check sync
					while((*STATUS_REGISTER && MASK_SYNC) == true);
    28e6:	4880      	ldr	r0, [pc, #512]	; (2ae8 <_tc_interrupt_handler+0x300>)
    28e8:	7802      	ldrb	r2, [r0, #0]
    28ea:	2a00      	cmp	r2, #0
    28ec:	d1fc      	bne.n	28e8 <_tc_interrupt_handler+0x100>
					*COMPARE_REGISTER         =	compare_value_current;
    28ee:	4a7f      	ldr	r2, [pc, #508]	; (2aec <_tc_interrupt_handler+0x304>)
    28f0:	7013      	strb	r3, [r2, #0]
					*COUNT_REGISTER           =	compare_value_last;			
    28f2:	4b7b      	ldr	r3, [pc, #492]	; (2ae0 <_tc_interrupt_handler+0x2f8>)
    28f4:	781a      	ldrb	r2, [r3, #0]
    28f6:	4b7e      	ldr	r3, [pc, #504]	; (2af0 <_tc_interrupt_handler+0x308>)
    28f8:	701a      	strb	r2, [r3, #0]
    28fa:	e00b      	b.n	2914 <_tc_interrupt_handler+0x12c>
				while((compare_value_last == compare_value_current) && (compare_array_ID <= N_valid_compares - 1))
    28fc:	0013      	movs	r3, r2
    28fe:	e7f0      	b.n	28e2 <_tc_interrupt_handler+0xfa>
					
				}
				else
				{
					while((*STATUS_REGISTER && MASK_SYNC) == true);
    2900:	4879      	ldr	r0, [pc, #484]	; (2ae8 <_tc_interrupt_handler+0x300>)
    2902:	7803      	ldrb	r3, [r0, #0]
    2904:	2b00      	cmp	r3, #0
    2906:	d1fc      	bne.n	2902 <_tc_interrupt_handler+0x11a>
					*COUNT_REGISTER         =	compare_value_last;
    2908:	4b79      	ldr	r3, [pc, #484]	; (2af0 <_tc_interrupt_handler+0x308>)
    290a:	701a      	strb	r2, [r3, #0]
    290c:	e002      	b.n	2914 <_tc_interrupt_handler+0x12c>
			
			
		}
		else
		{
			first_time = false;
    290e:	2200      	movs	r2, #0
    2910:	4b6c      	ldr	r3, [pc, #432]	; (2ac4 <_tc_interrupt_handler+0x2dc>)
    2912:	701a      	strb	r2, [r3, #0]
			
		}
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(1);
    2914:	2310      	movs	r3, #16
    2916:	6822      	ldr	r2, [r4, #0]
    2918:	7393      	strb	r3, [r2, #14]
	}
	
	/* Check if an Overflow interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_OVF) {
    291a:	07cb      	lsls	r3, r1, #31
    291c:	d400      	bmi.n	2920 <_tc_interrupt_handler+0x138>
    291e:	e0bf      	b.n	2aa0 <_tc_interrupt_handler+0x2b8>
		
		/* Clear interrupt flag */
		serial_timeout_count++;
    2920:	4a74      	ldr	r2, [pc, #464]	; (2af4 <_tc_interrupt_handler+0x30c>)
    2922:	7813      	ldrb	r3, [r2, #0]
    2924:	3301      	adds	r3, #1
    2926:	b2db      	uxtb	r3, r3
    2928:	7013      	strb	r3, [r2, #0]
		
		if(status_battery == true)
    292a:	4b73      	ldr	r3, [pc, #460]	; (2af8 <_tc_interrupt_handler+0x310>)
    292c:	781b      	ldrb	r3, [r3, #0]
    292e:	2b00      	cmp	r3, #0
    2930:	d03b      	beq.n	29aa <_tc_interrupt_handler+0x1c2>
		{
			status_update_count++;
    2932:	4a72      	ldr	r2, [pc, #456]	; (2afc <_tc_interrupt_handler+0x314>)
    2934:	7813      	ldrb	r3, [r2, #0]
    2936:	3301      	adds	r3, #1
    2938:	b2db      	uxtb	r3, r3
    293a:	7013      	strb	r3, [r2, #0]
			if(status_update_count > flexible_count)
    293c:	4a70      	ldr	r2, [pc, #448]	; (2b00 <_tc_interrupt_handler+0x318>)
    293e:	7812      	ldrb	r2, [r2, #0]
    2940:	429a      	cmp	r2, r3
    2942:	d232      	bcs.n	29aa <_tc_interrupt_handler+0x1c2>
			{
				status_update_count = 0;
    2944:	2200      	movs	r2, #0
    2946:	4b6d      	ldr	r3, [pc, #436]	; (2afc <_tc_interrupt_handler+0x314>)
    2948:	701a      	strb	r2, [r3, #0]
				if((battery_voltage < threshold_blink) && (battery_voltage > threshold_off))
    294a:	4b6e      	ldr	r3, [pc, #440]	; (2b04 <_tc_interrupt_handler+0x31c>)
    294c:	781b      	ldrb	r3, [r3, #0]
    294e:	b2db      	uxtb	r3, r3
    2950:	4a6d      	ldr	r2, [pc, #436]	; (2b08 <_tc_interrupt_handler+0x320>)
    2952:	7812      	ldrb	r2, [r2, #0]
    2954:	4293      	cmp	r3, r2
    2956:	d21a      	bcs.n	298e <_tc_interrupt_handler+0x1a6>
    2958:	4b6a      	ldr	r3, [pc, #424]	; (2b04 <_tc_interrupt_handler+0x31c>)
    295a:	781b      	ldrb	r3, [r3, #0]
    295c:	b2db      	uxtb	r3, r3
    295e:	496b      	ldr	r1, [pc, #428]	; (2b0c <_tc_interrupt_handler+0x324>)
    2960:	7809      	ldrb	r1, [r1, #0]
    2962:	4299      	cmp	r1, r3
    2964:	d213      	bcs.n	298e <_tc_interrupt_handler+0x1a6>
				{
					flexible_count       =  MAX_STATUS_BLINK - ((threshold_blink- battery_voltage)*60/(80));
    2966:	4b67      	ldr	r3, [pc, #412]	; (2b04 <_tc_interrupt_handler+0x31c>)
    2968:	781b      	ldrb	r3, [r3, #0]
    296a:	1ad2      	subs	r2, r2, r3
    296c:	0110      	lsls	r0, r2, #4
    296e:	1a10      	subs	r0, r2, r0
    2970:	0080      	lsls	r0, r0, #2
    2972:	2150      	movs	r1, #80	; 0x50
    2974:	4b66      	ldr	r3, [pc, #408]	; (2b10 <_tc_interrupt_handler+0x328>)
    2976:	4798      	blx	r3
    2978:	3041      	adds	r0, #65	; 0x41
    297a:	4b61      	ldr	r3, [pc, #388]	; (2b00 <_tc_interrupt_handler+0x318>)
    297c:	7018      	strb	r0, [r3, #0]
					threshold_blink      =   MIN_BLINK_START - 2;//decrease the threshold
    297e:	2273      	movs	r2, #115	; 0x73
    2980:	4b61      	ldr	r3, [pc, #388]	; (2b08 <_tc_interrupt_handler+0x320>)
    2982:	701a      	strb	r2, [r3, #0]
					*PORT_TOGGLE          =  STATUS_LED_PIN;
    2984:	2280      	movs	r2, #128	; 0x80
    2986:	05d2      	lsls	r2, r2, #23
    2988:	4b62      	ldr	r3, [pc, #392]	; (2b14 <_tc_interrupt_handler+0x32c>)
    298a:	601a      	str	r2, [r3, #0]
    298c:	e00d      	b.n	29aa <_tc_interrupt_handler+0x1c2>
					//Toggle Status LED
				}
				else if( battery_voltage < threshold_off)
    298e:	4b5d      	ldr	r3, [pc, #372]	; (2b04 <_tc_interrupt_handler+0x31c>)
    2990:	781b      	ldrb	r3, [r3, #0]
    2992:	b2db      	uxtb	r3, r3
    2994:	4a5d      	ldr	r2, [pc, #372]	; (2b0c <_tc_interrupt_handler+0x324>)
    2996:	7812      	ldrb	r2, [r2, #0]
    2998:	429a      	cmp	r2, r3
    299a:	d928      	bls.n	29ee <_tc_interrupt_handler+0x206>
				{
					*PORT_CLEAR			 =  STATUS_LED_PIN;
    299c:	2280      	movs	r2, #128	; 0x80
    299e:	05d2      	lsls	r2, r2, #23
    29a0:	4b5d      	ldr	r3, [pc, #372]	; (2b18 <_tc_interrupt_handler+0x330>)
    29a2:	601a      	str	r2, [r3, #0]
					threshold_off        =   MIN_LED_OFF -2;
    29a4:	2270      	movs	r2, #112	; 0x70
    29a6:	4b59      	ldr	r3, [pc, #356]	; (2b0c <_tc_interrupt_handler+0x324>)
    29a8:	701a      	strb	r2, [r3, #0]
				}
			}
		}
		
		
		if(serial_timeout_count > MAX_SERIAL_TIMEOUT)
    29aa:	4b52      	ldr	r3, [pc, #328]	; (2af4 <_tc_interrupt_handler+0x30c>)
    29ac:	781b      	ldrb	r3, [r3, #0]
    29ae:	b2db      	uxtb	r3, r3
    29b0:	2b01      	cmp	r3, #1
    29b2:	d905      	bls.n	29c0 <_tc_interrupt_handler+0x1d8>
		{
			serial_timeout = true;
    29b4:	2201      	movs	r2, #1
    29b6:	4b59      	ldr	r3, [pc, #356]	; (2b1c <_tc_interrupt_handler+0x334>)
    29b8:	701a      	strb	r2, [r3, #0]
			serial_timeout_count = 0;
    29ba:	2200      	movs	r2, #0
    29bc:	4b4d      	ldr	r3, [pc, #308]	; (2af4 <_tc_interrupt_handler+0x30c>)
    29be:	701a      	strb	r2, [r3, #0]
		}
		
		*PORT_CLEAR						  = CLEAR_ORB_LEDS;
    29c0:	4a57      	ldr	r2, [pc, #348]	; (2b20 <_tc_interrupt_handler+0x338>)
    29c2:	4b55      	ldr	r3, [pc, #340]	; (2b18 <_tc_interrupt_handler+0x330>)
    29c4:	601a      	str	r2, [r3, #0]
		if(update_compare_array == true)
    29c6:	4b57      	ldr	r3, [pc, #348]	; (2b24 <_tc_interrupt_handler+0x33c>)
    29c8:	781b      	ldrb	r3, [r3, #0]
    29ca:	2b00      	cmp	r3, #0
    29cc:	d04e      	beq.n	2a6c <_tc_interrupt_handler+0x284>
		{
			if(int_enable == true)
    29ce:	4b56      	ldr	r3, [pc, #344]	; (2b28 <_tc_interrupt_handler+0x340>)
    29d0:	781b      	ldrb	r3, [r3, #0]
    29d2:	2b00      	cmp	r3, #0
    29d4:	d119      	bne.n	2a0a <_tc_interrupt_handler+0x222>
			{
				int_enable = false;
				tc_enable_callback(module, TC_CALLBACK_CC_CHANNEL0);
				tc_clear_status(module,0x00000011);
			}
				N_valid_compares = 0;
    29d6:	2200      	movs	r2, #0
    29d8:	4b3c      	ldr	r3, [pc, #240]	; (2acc <_tc_interrupt_handler+0x2e4>)
    29da:	701a      	strb	r2, [r3, #0]
    29dc:	2300      	movs	r3, #0
			
				for(i=0;i<NO_OF_LEDS;i++)
				{
					if(temp_compare_array[i] != 255)
    29de:	4a53      	ldr	r2, [pc, #332]	; (2b2c <_tc_interrupt_handler+0x344>)
    29e0:	4690      	mov	r8, r2
					{
						N_valid_compares++;
    29e2:	483a      	ldr	r0, [pc, #232]	; (2acc <_tc_interrupt_handler+0x2e4>)
					}
				
					compare_array[i] = temp_compare_array[i] ;
    29e4:	4694      	mov	ip, r2
    29e6:	4f3d      	ldr	r7, [pc, #244]	; (2adc <_tc_interrupt_handler+0x2f4>)
					pin_array[i]	 = temp_pin_array[i];
    29e8:	4e51      	ldr	r6, [pc, #324]	; (2b30 <_tc_interrupt_handler+0x348>)
    29ea:	4d3a      	ldr	r5, [pc, #232]	; (2ad4 <_tc_interrupt_handler+0x2ec>)
    29ec:	e030      	b.n	2a50 <_tc_interrupt_handler+0x268>
					threshold_blink      =  MIN_BLINK_START;
    29ee:	2275      	movs	r2, #117	; 0x75
    29f0:	4b45      	ldr	r3, [pc, #276]	; (2b08 <_tc_interrupt_handler+0x320>)
    29f2:	701a      	strb	r2, [r3, #0]
					threshold_off        =   MIN_LED_OFF;
    29f4:	3a03      	subs	r2, #3
    29f6:	4b45      	ldr	r3, [pc, #276]	; (2b0c <_tc_interrupt_handler+0x324>)
    29f8:	701a      	strb	r2, [r3, #0]
					flexible_count       =  MAX_STATUS_BLINK;//
    29fa:	3a31      	subs	r2, #49	; 0x31
    29fc:	4b40      	ldr	r3, [pc, #256]	; (2b00 <_tc_interrupt_handler+0x318>)
    29fe:	701a      	strb	r2, [r3, #0]
					*PORT_SET			 =  STATUS_LED_PIN;
    2a00:	2280      	movs	r2, #128	; 0x80
    2a02:	05d2      	lsls	r2, r2, #23
    2a04:	4b34      	ldr	r3, [pc, #208]	; (2ad8 <_tc_interrupt_handler+0x2f0>)
    2a06:	601a      	str	r2, [r3, #0]
    2a08:	e7cf      	b.n	29aa <_tc_interrupt_handler+0x1c2>
				int_enable = false;
    2a0a:	2200      	movs	r2, #0
    2a0c:	4b46      	ldr	r3, [pc, #280]	; (2b28 <_tc_interrupt_handler+0x340>)
    2a0e:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);


	/* Enable interrupts for this TC module */
	system_interrupt_enable(_tc_interrupt_get_interrupt_vector(_tc_get_inst_index(module->hw)));
    2a10:	6820      	ldr	r0, [r4, #0]
    2a12:	4b48      	ldr	r3, [pc, #288]	; (2b34 <_tc_interrupt_handler+0x34c>)
    2a14:	4798      	blx	r3
	return (enum system_interrupt_vector)tc_interrupt_vectors[inst_num];
    2a16:	4b48      	ldr	r3, [pc, #288]	; (2b38 <_tc_interrupt_handler+0x350>)
    2a18:	5c1b      	ldrb	r3, [r3, r0]
    2a1a:	221f      	movs	r2, #31
    2a1c:	401a      	ands	r2, r3
    2a1e:	2301      	movs	r3, #1
    2a20:	4093      	lsls	r3, r2
    2a22:	4a46      	ldr	r2, [pc, #280]	; (2b3c <_tc_interrupt_handler+0x354>)
    2a24:	6013      	str	r3, [r2, #0]

	/* Enable callback */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
		module->enable_callback_mask |= TC_INTFLAG_MC(1);
    2a26:	7e63      	ldrb	r3, [r4, #25]
    2a28:	2210      	movs	r2, #16
    2a2a:	4313      	orrs	r3, r2
    2a2c:	7663      	strb	r3, [r4, #25]
		module->hw->COUNT8.INTENSET.reg = TC_INTFLAG_MC(1);
    2a2e:	2310      	movs	r3, #16
    2a30:	6822      	ldr	r2, [r4, #0]
    2a32:	7353      	strb	r3, [r2, #13]
	if (status_flags & TC_STATUS_COUNT_OVERFLOW) {
		int_flags |= TC_INTFLAG_OVF;
	}

	/* Clear interrupt flag */
	tc_module->INTFLAG.reg = int_flags;
    2a34:	3301      	adds	r3, #1
    2a36:	6822      	ldr	r2, [r4, #0]
    2a38:	7393      	strb	r3, [r2, #14]
    2a3a:	e7cc      	b.n	29d6 <_tc_interrupt_handler+0x1ee>
					compare_array[i] = temp_compare_array[i] ;
    2a3c:	4661      	mov	r1, ip
    2a3e:	5c89      	ldrb	r1, [r1, r2]
    2a40:	b2c9      	uxtb	r1, r1
    2a42:	54b9      	strb	r1, [r7, r2]
					pin_array[i]	 = temp_pin_array[i];
    2a44:	5cb1      	ldrb	r1, [r6, r2]
    2a46:	b2c9      	uxtb	r1, r1
    2a48:	54a9      	strb	r1, [r5, r2]
    2a4a:	3301      	adds	r3, #1
				for(i=0;i<NO_OF_LEDS;i++)
    2a4c:	2b08      	cmp	r3, #8
    2a4e:	d00a      	beq.n	2a66 <_tc_interrupt_handler+0x27e>
					if(temp_compare_array[i] != 255)
    2a50:	001a      	movs	r2, r3
    2a52:	4641      	mov	r1, r8
    2a54:	5cc9      	ldrb	r1, [r1, r3]
    2a56:	b2c9      	uxtb	r1, r1
    2a58:	29ff      	cmp	r1, #255	; 0xff
    2a5a:	d0ef      	beq.n	2a3c <_tc_interrupt_handler+0x254>
						N_valid_compares++;
    2a5c:	7801      	ldrb	r1, [r0, #0]
    2a5e:	3101      	adds	r1, #1
    2a60:	b2c9      	uxtb	r1, r1
    2a62:	7001      	strb	r1, [r0, #0]
    2a64:	e7ea      	b.n	2a3c <_tc_interrupt_handler+0x254>
				}
				
			update_compare_array = false;
    2a66:	2200      	movs	r2, #0
    2a68:	4b2e      	ldr	r3, [pc, #184]	; (2b24 <_tc_interrupt_handler+0x33c>)
    2a6a:	701a      	strb	r2, [r3, #0]

		}
		compare_array_ID = 0;
    2a6c:	2300      	movs	r3, #0
    2a6e:	4a16      	ldr	r2, [pc, #88]	; (2ac8 <_tc_interrupt_handler+0x2e0>)
    2a70:	7013      	strb	r3, [r2, #0]
		pin_array_ID  = 0;
    2a72:	4a17      	ldr	r2, [pc, #92]	; (2ad0 <_tc_interrupt_handler+0x2e8>)
    2a74:	7013      	strb	r3, [r2, #0]
		
		compare_value = compare_array[0];
    2a76:	4b19      	ldr	r3, [pc, #100]	; (2adc <_tc_interrupt_handler+0x2f4>)
    2a78:	7819      	ldrb	r1, [r3, #0]
    2a7a:	b2c9      	uxtb	r1, r1
		if(compare_value != 255)
    2a7c:	29ff      	cmp	r1, #255	; 0xff
    2a7e:	d015      	beq.n	2aac <_tc_interrupt_handler+0x2c4>
		{
			
			//led_disable_flag = true;
			//Check sync busy
			while((*STATUS_REGISTER && MASK_SYNC) == true);
    2a80:	4a19      	ldr	r2, [pc, #100]	; (2ae8 <_tc_interrupt_handler+0x300>)
    2a82:	7813      	ldrb	r3, [r2, #0]
    2a84:	2b00      	cmp	r3, #0
    2a86:	d1fc      	bne.n	2a82 <_tc_interrupt_handler+0x29a>
			//Update the compare value
			*COMPARE_REGISTER  = compare_value;
    2a88:	4b18      	ldr	r3, [pc, #96]	; (2aec <_tc_interrupt_handler+0x304>)
    2a8a:	7019      	strb	r1, [r3, #0]
		else
		{
			int_enable = true;
			tc_disable_callback(module, TC_CALLBACK_CC_CHANNEL0);
		}
		while((*STATUS_REGISTER && MASK_SYNC) == true);
    2a8c:	4a16      	ldr	r2, [pc, #88]	; (2ae8 <_tc_interrupt_handler+0x300>)
    2a8e:	7813      	ldrb	r3, [r2, #0]
    2a90:	2b00      	cmp	r3, #0
    2a92:	d1fc      	bne.n	2a8e <_tc_interrupt_handler+0x2a6>
		*COUNT_REGISTER           =	0;
    2a94:	2200      	movs	r2, #0
    2a96:	4b16      	ldr	r3, [pc, #88]	; (2af0 <_tc_interrupt_handler+0x308>)
    2a98:	701a      	strb	r2, [r3, #0]
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_OVF;
    2a9a:	6823      	ldr	r3, [r4, #0]
    2a9c:	3201      	adds	r2, #1
    2a9e:	739a      	strb	r2, [r3, #14]
	}

}
    2aa0:	bc3c      	pop	{r2, r3, r4, r5}
    2aa2:	4690      	mov	r8, r2
    2aa4:	4699      	mov	r9, r3
    2aa6:	46a2      	mov	sl, r4
    2aa8:	46ab      	mov	fp, r5
    2aaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			int_enable = true;
    2aac:	2201      	movs	r2, #1
    2aae:	4b1e      	ldr	r3, [pc, #120]	; (2b28 <_tc_interrupt_handler+0x340>)
    2ab0:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);

	/* Disable callback */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
		module->hw->COUNT8.INTENCLR.reg = TC_INTFLAG_MC(1);
    2ab2:	320f      	adds	r2, #15
    2ab4:	6823      	ldr	r3, [r4, #0]
    2ab6:	731a      	strb	r2, [r3, #12]
		module->enable_callback_mask &= ~TC_INTFLAG_MC(1);
    2ab8:	7e63      	ldrb	r3, [r4, #25]
    2aba:	4393      	bics	r3, r2
    2abc:	7663      	strb	r3, [r4, #25]
    2abe:	e7e5      	b.n	2a8c <_tc_interrupt_handler+0x2a4>
    2ac0:	200002b0 	.word	0x200002b0
    2ac4:	20000009 	.word	0x20000009
    2ac8:	200000b0 	.word	0x200000b0
    2acc:	20000008 	.word	0x20000008
    2ad0:	200000bc 	.word	0x200000bc
    2ad4:	200000b4 	.word	0x200000b4
    2ad8:	41004418 	.word	0x41004418
    2adc:	200000a8 	.word	0x200000a8
    2ae0:	200000b2 	.word	0x200000b2
    2ae4:	200000b1 	.word	0x200000b1
    2ae8:	4200180f 	.word	0x4200180f
    2aec:	42001818 	.word	0x42001818
    2af0:	42001810 	.word	0x42001810
    2af4:	200000f4 	.word	0x200000f4
    2af8:	2000000e 	.word	0x2000000e
    2afc:	200000bd 	.word	0x200000bd
    2b00:	2000000a 	.word	0x2000000a
    2b04:	200000f0 	.word	0x200000f0
    2b08:	2000000b 	.word	0x2000000b
    2b0c:	2000000c 	.word	0x2000000c
    2b10:	000037c9 	.word	0x000037c9
    2b14:	4100441c 	.word	0x4100441c
    2b18:	41004414 	.word	0x41004414
    2b1c:	200000f3 	.word	0x200000f3
    2b20:	88038300 	.word	0x88038300
    2b24:	200000f8 	.word	0x200000f8
    2b28:	200000b3 	.word	0x200000b3
    2b2c:	2000030c 	.word	0x2000030c
    2b30:	20000330 	.word	0x20000330
    2b34:	00002561 	.word	0x00002561
    2b38:	00003c98 	.word	0x00003c98
    2b3c:	e000e100 	.word	0xe000e100

00002b40 <TC1_Handler>:
	MRECURSION(TC_INST_NUM, _TC_INTERRUPT_HANDLER, TC_INST_MAX_ID)
    2b40:	b510      	push	{r4, lr}
    2b42:	2000      	movs	r0, #0
    2b44:	4b01      	ldr	r3, [pc, #4]	; (2b4c <TC1_Handler+0xc>)
    2b46:	4798      	blx	r3
    2b48:	bd10      	pop	{r4, pc}
    2b4a:	46c0      	nop			; (mov r8, r8)
    2b4c:	000027e9 	.word	0x000027e9

00002b50 <TC2_Handler>:
    2b50:	b510      	push	{r4, lr}
    2b52:	2001      	movs	r0, #1
    2b54:	4b01      	ldr	r3, [pc, #4]	; (2b5c <TC2_Handler+0xc>)
    2b56:	4798      	blx	r3
    2b58:	bd10      	pop	{r4, pc}
    2b5a:	46c0      	nop			; (mov r8, r8)
    2b5c:	000027e9 	.word	0x000027e9

00002b60 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
    2b60:	4770      	bx	lr
	...

00002b64 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    2b64:	b530      	push	{r4, r5, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    2b66:	4b0a      	ldr	r3, [pc, #40]	; (2b90 <_sercom_set_handler+0x2c>)
    2b68:	781b      	ldrb	r3, [r3, #0]
    2b6a:	2b00      	cmp	r3, #0
    2b6c:	d10c      	bne.n	2b88 <_sercom_set_handler+0x24>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    2b6e:	4c09      	ldr	r4, [pc, #36]	; (2b94 <_sercom_set_handler+0x30>)
    2b70:	4d09      	ldr	r5, [pc, #36]	; (2b98 <_sercom_set_handler+0x34>)
    2b72:	6025      	str	r5, [r4, #0]
			_sercom_instances[i] = NULL;
    2b74:	4b09      	ldr	r3, [pc, #36]	; (2b9c <_sercom_set_handler+0x38>)
    2b76:	2200      	movs	r2, #0
    2b78:	601a      	str	r2, [r3, #0]
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    2b7a:	6065      	str	r5, [r4, #4]
			_sercom_instances[i] = NULL;
    2b7c:	605a      	str	r2, [r3, #4]
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    2b7e:	60a5      	str	r5, [r4, #8]
			_sercom_instances[i] = NULL;
    2b80:	609a      	str	r2, [r3, #8]
		}

		_handler_table_initialized = true;
    2b82:	3201      	adds	r2, #1
    2b84:	4b02      	ldr	r3, [pc, #8]	; (2b90 <_sercom_set_handler+0x2c>)
    2b86:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    2b88:	0080      	lsls	r0, r0, #2
    2b8a:	4b02      	ldr	r3, [pc, #8]	; (2b94 <_sercom_set_handler+0x30>)
    2b8c:	50c1      	str	r1, [r0, r3]
}
    2b8e:	bd30      	pop	{r4, r5, pc}
    2b90:	200000be 	.word	0x200000be
    2b94:	200000c0 	.word	0x200000c0
    2b98:	00002b61 	.word	0x00002b61
    2b9c:	200002b8 	.word	0x200002b8

00002ba0 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    2ba0:	b510      	push	{r4, lr}
    2ba2:	b082      	sub	sp, #8
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    2ba4:	ac01      	add	r4, sp, #4
    2ba6:	2309      	movs	r3, #9
    2ba8:	7023      	strb	r3, [r4, #0]
    2baa:	3301      	adds	r3, #1
    2bac:	7063      	strb	r3, [r4, #1]
    2bae:	3301      	adds	r3, #1
    2bb0:	70a3      	strb	r3, [r4, #2]
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    2bb2:	4b02      	ldr	r3, [pc, #8]	; (2bbc <_sercom_get_interrupt_vector+0x1c>)
    2bb4:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    2bb6:	5620      	ldrsb	r0, [r4, r0]
}
    2bb8:	b002      	add	sp, #8
    2bba:	bd10      	pop	{r4, pc}
    2bbc:	000018c5 	.word	0x000018c5

00002bc0 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    2bc0:	b510      	push	{r4, lr}
    2bc2:	4b02      	ldr	r3, [pc, #8]	; (2bcc <SERCOM0_Handler+0xc>)
    2bc4:	681b      	ldr	r3, [r3, #0]
    2bc6:	2000      	movs	r0, #0
    2bc8:	4798      	blx	r3
    2bca:	bd10      	pop	{r4, pc}
    2bcc:	200000c0 	.word	0x200000c0

00002bd0 <SERCOM1_Handler>:
    2bd0:	b510      	push	{r4, lr}
    2bd2:	4b02      	ldr	r3, [pc, #8]	; (2bdc <SERCOM1_Handler+0xc>)
    2bd4:	685b      	ldr	r3, [r3, #4]
    2bd6:	2001      	movs	r0, #1
    2bd8:	4798      	blx	r3
    2bda:	bd10      	pop	{r4, pc}
    2bdc:	200000c0 	.word	0x200000c0

00002be0 <SERCOM2_Handler>:
    2be0:	b510      	push	{r4, lr}
    2be2:	4b02      	ldr	r3, [pc, #8]	; (2bec <SERCOM2_Handler+0xc>)
    2be4:	689b      	ldr	r3, [r3, #8]
    2be6:	2002      	movs	r0, #2
    2be8:	4798      	blx	r3
    2bea:	bd10      	pop	{r4, pc}
    2bec:	200000c0 	.word	0x200000c0

00002bf0 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
    2bf0:	b570      	push	{r4, r5, r6, lr}
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    2bf2:	2200      	movs	r2, #0
    2bf4:	4b10      	ldr	r3, [pc, #64]	; (2c38 <EIC_Handler+0x48>)
    2bf6:	701a      	strb	r2, [r3, #0]
    2bf8:	2300      	movs	r3, #0

	if (eic_index < EIC_INST_NUM) {
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    2bfa:	4910      	ldr	r1, [pc, #64]	; (2c3c <EIC_Handler+0x4c>)
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    2bfc:	251f      	movs	r5, #31
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    2bfe:	4e10      	ldr	r6, [pc, #64]	; (2c40 <EIC_Handler+0x50>)
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    2c00:	4c0d      	ldr	r4, [pc, #52]	; (2c38 <EIC_Handler+0x48>)
    2c02:	e00a      	b.n	2c1a <EIC_Handler+0x2a>
		return eics[eic_index];
    2c04:	490d      	ldr	r1, [pc, #52]	; (2c3c <EIC_Handler+0x4c>)
    2c06:	e008      	b.n	2c1a <EIC_Handler+0x2a>
    2c08:	7823      	ldrb	r3, [r4, #0]
    2c0a:	3301      	adds	r3, #1
    2c0c:	b2db      	uxtb	r3, r3
    2c0e:	7023      	strb	r3, [r4, #0]
    2c10:	2b0f      	cmp	r3, #15
    2c12:	d810      	bhi.n	2c36 <EIC_Handler+0x46>
		return NULL;
    2c14:	2100      	movs	r1, #0
	if (eic_index < EIC_INST_NUM) {
    2c16:	2b1f      	cmp	r3, #31
    2c18:	d9f4      	bls.n	2c04 <EIC_Handler+0x14>
	uint32_t eic_mask   = (1UL << (channel % 32));
    2c1a:	0028      	movs	r0, r5
    2c1c:	4018      	ands	r0, r3
    2c1e:	2201      	movs	r2, #1
    2c20:	4082      	lsls	r2, r0

	return (eic_module->INTFLAG.reg & eic_mask);
    2c22:	6908      	ldr	r0, [r1, #16]
		if (extint_chan_is_detected(_current_channel)) {
    2c24:	4210      	tst	r0, r2
    2c26:	d0ef      	beq.n	2c08 <EIC_Handler+0x18>
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));

	eic_module->INTFLAG.reg = eic_mask;
    2c28:	610a      	str	r2, [r1, #16]
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    2c2a:	009b      	lsls	r3, r3, #2
    2c2c:	599b      	ldr	r3, [r3, r6]
    2c2e:	2b00      	cmp	r3, #0
    2c30:	d0ea      	beq.n	2c08 <EIC_Handler+0x18>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
    2c32:	4798      	blx	r3
    2c34:	e7e8      	b.n	2c08 <EIC_Handler+0x18>
			}
		}
	}
}
    2c36:	bd70      	pop	{r4, r5, r6, pc}
    2c38:	200002c4 	.word	0x200002c4
    2c3c:	40001800 	.word	0x40001800
    2c40:	2000020c 	.word	0x2000020c

00002c44 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    2c44:	b500      	push	{lr}
    2c46:	b083      	sub	sp, #12
	config->mux_position = SYSTEM_PINMUX_GPIO;
    2c48:	ab01      	add	r3, sp, #4
    2c4a:	2280      	movs	r2, #128	; 0x80
    2c4c:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    2c4e:	780a      	ldrb	r2, [r1, #0]
    2c50:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    2c52:	784a      	ldrb	r2, [r1, #1]
    2c54:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    2c56:	788a      	ldrb	r2, [r1, #2]
    2c58:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    2c5a:	0019      	movs	r1, r3
    2c5c:	4b01      	ldr	r3, [pc, #4]	; (2c64 <port_pin_set_config+0x20>)
    2c5e:	4798      	blx	r3
}
    2c60:	b003      	add	sp, #12
    2c62:	bd00      	pop	{pc}
    2c64:	000034c5 	.word	0x000034c5

00002c68 <tc_callback_PWM>:


/* These are just place holder but actual code is in the SPI interrupt.c */
void tc_callback_PWM(struct tc_module *const module_inst)
{
}
    2c68:	4770      	bx	lr

00002c6a <tc_callback_OF>:
void tc_callback_OF(struct tc_module *const module_inst)
{
}
    2c6a:	4770      	bx	lr

00002c6c <increasing_sort_tag>:
{
    2c6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    2c6e:	46c6      	mov	lr, r8
    2c70:	b500      	push	{lr}
    2c72:	b084      	sub	sp, #16
    2c74:	2300      	movs	r3, #0
		temp_temp_pin_array[i] = temp_pin_array_2[i] ;
    2c76:	4c23      	ldr	r4, [pc, #140]	; (2d04 <increasing_sort_tag+0x98>)
    2c78:	a802      	add	r0, sp, #8
		temp_temp_compare_array[i] = temp_compare_array_2[i] ;
    2c7a:	4923      	ldr	r1, [pc, #140]	; (2d08 <increasing_sort_tag+0x9c>)
		temp_temp_pin_array[i] = temp_pin_array_2[i] ;
    2c7c:	5ce2      	ldrb	r2, [r4, r3]
    2c7e:	54c2      	strb	r2, [r0, r3]
		temp_temp_compare_array[i] = temp_compare_array_2[i] ;
    2c80:	5cca      	ldrb	r2, [r1, r3]
    2c82:	466d      	mov	r5, sp
    2c84:	54ea      	strb	r2, [r5, r3]
    2c86:	3301      	adds	r3, #1
	for(i=0;i<NO_OF_LEDS;i++)
    2c88:	2b08      	cmp	r3, #8
    2c8a:	d1f7      	bne.n	2c7c <increasing_sort_tag+0x10>
    2c8c:	3b01      	subs	r3, #1
    2c8e:	469c      	mov	ip, r3
				temp = temp_temp_pin_array[j];
    2c90:	ad02      	add	r5, sp, #8
    2c92:	e01a      	b.n	2cca <increasing_sort_tag+0x5e>
		for(j=0;j< N-i-1;j++)
    2c94:	3301      	adds	r3, #1
    2c96:	b2db      	uxtb	r3, r3
    2c98:	001a      	movs	r2, r3
    2c9a:	42bb      	cmp	r3, r7
    2c9c:	da0e      	bge.n	2cbc <increasing_sort_tag+0x50>
			if(temp_temp_compare_array[j]>temp_temp_compare_array[j+1])
    2c9e:	4669      	mov	r1, sp
    2ca0:	5c88      	ldrb	r0, [r1, r2]
    2ca2:	1c51      	adds	r1, r2, #1
    2ca4:	466c      	mov	r4, sp
    2ca6:	5c64      	ldrb	r4, [r4, r1]
    2ca8:	42a0      	cmp	r0, r4
    2caa:	d9f3      	bls.n	2c94 <increasing_sort_tag+0x28>
				temp_temp_compare_array[j] = temp_temp_compare_array[j+1];
    2cac:	466e      	mov	r6, sp
    2cae:	54b4      	strb	r4, [r6, r2]
				temp_temp_compare_array[j+1]= temp;
    2cb0:	5470      	strb	r0, [r6, r1]
				temp = temp_temp_pin_array[j];
    2cb2:	5ca8      	ldrb	r0, [r5, r2]
				temp_temp_pin_array[j]   = temp_temp_pin_array[j+1];
    2cb4:	5c6c      	ldrb	r4, [r5, r1]
    2cb6:	54ac      	strb	r4, [r5, r2]
				temp_temp_pin_array[j+1] = temp;
    2cb8:	5468      	strb	r0, [r5, r1]
    2cba:	e7eb      	b.n	2c94 <increasing_sort_tag+0x28>
    2cbc:	2301      	movs	r3, #1
    2cbe:	425b      	negs	r3, r3
    2cc0:	4698      	mov	r8, r3
    2cc2:	44c4      	add	ip, r8
	for(i=0; i< N-1 ;i++)
    2cc4:	4663      	mov	r3, ip
    2cc6:	2b00      	cmp	r3, #0
    2cc8:	d005      	beq.n	2cd6 <increasing_sort_tag+0x6a>
		for(j=0;j< N-i-1;j++)
    2cca:	4667      	mov	r7, ip
    2ccc:	2200      	movs	r2, #0
    2cce:	2300      	movs	r3, #0
    2cd0:	2f00      	cmp	r7, #0
    2cd2:	dce4      	bgt.n	2c9e <increasing_sort_tag+0x32>
    2cd4:	e7f2      	b.n	2cbc <increasing_sort_tag+0x50>
	lock_temp_array = true;
    2cd6:	2201      	movs	r2, #1
    2cd8:	4b0c      	ldr	r3, [pc, #48]	; (2d0c <increasing_sort_tag+0xa0>)
    2cda:	701a      	strb	r2, [r3, #0]
    2cdc:	2300      	movs	r3, #0
		temp_pin_array[i]     = temp_temp_pin_array[i]  ;
    2cde:	ac02      	add	r4, sp, #8
    2ce0:	480b      	ldr	r0, [pc, #44]	; (2d10 <increasing_sort_tag+0xa4>)
		temp_compare_array[i] = temp_temp_compare_array[i];
    2ce2:	490c      	ldr	r1, [pc, #48]	; (2d14 <increasing_sort_tag+0xa8>)
		temp_pin_array[i]     = temp_temp_pin_array[i]  ;
    2ce4:	5d1a      	ldrb	r2, [r3, r4]
    2ce6:	54c2      	strb	r2, [r0, r3]
		temp_compare_array[i] = temp_temp_compare_array[i];
    2ce8:	466a      	mov	r2, sp
    2cea:	5c9a      	ldrb	r2, [r3, r2]
    2cec:	54ca      	strb	r2, [r1, r3]
    2cee:	3301      	adds	r3, #1
	for(i=0;i<N;i++)
    2cf0:	2b08      	cmp	r3, #8
    2cf2:	d1f7      	bne.n	2ce4 <increasing_sort_tag+0x78>
	lock_temp_array = false;
    2cf4:	2200      	movs	r2, #0
    2cf6:	4b05      	ldr	r3, [pc, #20]	; (2d0c <increasing_sort_tag+0xa0>)
    2cf8:	701a      	strb	r2, [r3, #0]
}
    2cfa:	b004      	add	sp, #16
    2cfc:	bc04      	pop	{r2}
    2cfe:	4690      	mov	r8, r2
    2d00:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2d02:	46c0      	nop			; (mov r8, r8)
    2d04:	20000328 	.word	0x20000328
    2d08:	2000034c 	.word	0x2000034c
    2d0c:	200000f2 	.word	0x200000f2
    2d10:	20000330 	.word	0x20000330
    2d14:	2000030c 	.word	0x2000030c

00002d18 <ORB_timer_init>:
{
    2d18:	b510      	push	{r4, lr}
    2d1a:	b08e      	sub	sp, #56	; 0x38
	config->clock_source               = GCLK_GENERATOR_0;
    2d1c:	aa01      	add	r2, sp, #4
    2d1e:	2300      	movs	r3, #0
    2d20:	2100      	movs	r1, #0
    2d22:	7013      	strb	r3, [r2, #0]
	config->wave_generation            = TC_WAVE_GENERATION_NORMAL_FREQ;
    2d24:	7193      	strb	r3, [r2, #6]
	config->reload_action              = TC_RELOAD_ACTION_GCLK;
    2d26:	8113      	strh	r3, [r2, #8]
	config->run_in_standby             = false;
    2d28:	2000      	movs	r0, #0
    2d2a:	7050      	strb	r0, [r2, #1]
	config->waveform_invert_output     = TC_WAVEFORM_INVERT_OUTPUT_NONE;
    2d2c:	7291      	strb	r1, [r2, #10]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
    2d2e:	72d1      	strb	r1, [r2, #11]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
    2d30:	7311      	strb	r1, [r2, #12]
	config->count_direction            = TC_COUNT_DIRECTION_UP;
    2d32:	7391      	strb	r1, [r2, #14]
	config->oneshot                    = false;
    2d34:	7351      	strb	r1, [r2, #13]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].enabled = false;
    2d36:	7411      	strb	r1, [r2, #16]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_out = 0;
    2d38:	6153      	str	r3, [r2, #20]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_mux = 0;
    2d3a:	6193      	str	r3, [r2, #24]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].enabled = false;
    2d3c:	7711      	strb	r1, [r2, #28]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_out = 0;
    2d3e:	6213      	str	r3, [r2, #32]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_mux = 0;
    2d40:	6253      	str	r3, [r2, #36]	; 0x24
	config->counter_16_bit.value                   = 0x0000;
    2d42:	8513      	strh	r3, [r2, #40]	; 0x28
		[TC_COMPARE_CAPTURE_CHANNEL_0]                        = 0x0000;
    2d44:	8553      	strh	r3, [r2, #42]	; 0x2a
		[TC_COMPARE_CAPTURE_CHANNEL_1]                        = 0x0000;
    2d46:	8593      	strh	r3, [r2, #44]	; 0x2c
	orb_tc_config.clock_prescaler = TC_CLOCK_PRESCALER_DIV256;
    2d48:	23c0      	movs	r3, #192	; 0xc0
    2d4a:	00db      	lsls	r3, r3, #3
    2d4c:	8093      	strh	r3, [r2, #4]
	orb_tc_config.counter_size = TC_COUNTER_SIZE_8BIT;
    2d4e:	2304      	movs	r3, #4
    2d50:	7093      	strb	r3, [r2, #2]
	orb_tc_config.counter_8_bit.period = 0XFF;
    2d52:	21ff      	movs	r1, #255	; 0xff
    2d54:	3325      	adds	r3, #37	; 0x25
    2d56:	54d1      	strb	r1, [r2, r3]
	tc_init(&orb_tc_instance, TC1, &orb_tc_config);
    2d58:	4c07      	ldr	r4, [pc, #28]	; (2d78 <ORB_timer_init+0x60>)
    2d5a:	4908      	ldr	r1, [pc, #32]	; (2d7c <ORB_timer_init+0x64>)
    2d5c:	0020      	movs	r0, r4
    2d5e:	4b08      	ldr	r3, [pc, #32]	; (2d80 <ORB_timer_init+0x68>)
    2d60:	4798      	blx	r3
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    2d62:	6822      	ldr	r2, [r4, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    2d64:	7bd3      	ldrb	r3, [r2, #15]
	while (tc_is_syncing(module_inst)) {
    2d66:	b25b      	sxtb	r3, r3
    2d68:	2b00      	cmp	r3, #0
    2d6a:	dbfb      	blt.n	2d64 <ORB_timer_init+0x4c>
	tc_module->CTRLA.reg |= TC_CTRLA_ENABLE;
    2d6c:	8813      	ldrh	r3, [r2, #0]
    2d6e:	2102      	movs	r1, #2
    2d70:	430b      	orrs	r3, r1
    2d72:	8013      	strh	r3, [r2, #0]
}
    2d74:	b00e      	add	sp, #56	; 0x38
    2d76:	bd10      	pop	{r4, pc}
    2d78:	200002c8 	.word	0x200002c8
    2d7c:	42001800 	.word	0x42001800
    2d80:	00002585 	.word	0x00002585

00002d84 <set_drivestrength_ORB>:
{
    2d84:	b510      	push	{r4, lr}
	system_pinmux_group_set_output_strength(port_base,CLEAR_ORB_LEDS,SYSTEM_PINMUX_PIN_STRENGTH_HIGH);
    2d86:	2201      	movs	r2, #1
    2d88:	4902      	ldr	r1, [pc, #8]	; (2d94 <set_drivestrength_ORB+0x10>)
    2d8a:	4803      	ldr	r0, [pc, #12]	; (2d98 <set_drivestrength_ORB+0x14>)
    2d8c:	4b03      	ldr	r3, [pc, #12]	; (2d9c <set_drivestrength_ORB+0x18>)
    2d8e:	4798      	blx	r3
}
    2d90:	bd10      	pop	{r4, pc}
    2d92:	46c0      	nop			; (mov r8, r8)
    2d94:	c8038300 	.word	0xc8038300
    2d98:	41004400 	.word	0x41004400
    2d9c:	000034f5 	.word	0x000034f5

00002da0 <ORB_setup_pins>:
{
    2da0:	b530      	push	{r4, r5, lr}
    2da2:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    2da4:	ac01      	add	r4, sp, #4
    2da6:	2301      	movs	r3, #1
    2da8:	7063      	strb	r3, [r4, #1]
	config->powersave  = false;
    2daa:	2200      	movs	r2, #0
    2dac:	70a2      	strb	r2, [r4, #2]
	config_port_pin.direction  = PORT_PIN_DIR_OUTPUT;
    2dae:	7023      	strb	r3, [r4, #0]
	port_pin_set_config(ORB_R1, &config_port_pin);
    2db0:	0021      	movs	r1, r4
    2db2:	200f      	movs	r0, #15
    2db4:	4d0e      	ldr	r5, [pc, #56]	; (2df0 <ORB_setup_pins+0x50>)
    2db6:	47a8      	blx	r5
	port_pin_set_config(ORB_G1, &config_port_pin);
    2db8:	0021      	movs	r1, r4
    2dba:	2010      	movs	r0, #16
    2dbc:	47a8      	blx	r5
	port_pin_set_config(ORB_B1, &config_port_pin);
    2dbe:	0021      	movs	r1, r4
    2dc0:	2011      	movs	r0, #17
    2dc2:	47a8      	blx	r5
	port_pin_set_config(ORB_R2, &config_port_pin);
    2dc4:	0021      	movs	r1, r4
    2dc6:	2008      	movs	r0, #8
    2dc8:	47a8      	blx	r5
	port_pin_set_config(ORB_G2, &config_port_pin);
    2dca:	0021      	movs	r1, r4
    2dcc:	2009      	movs	r0, #9
    2dce:	47a8      	blx	r5
	port_pin_set_config(ORB_B2, &config_port_pin);
    2dd0:	0021      	movs	r1, r4
    2dd2:	201b      	movs	r0, #27
    2dd4:	47a8      	blx	r5
	port_pin_set_config(LED1, &config_port_pin);
    2dd6:	0021      	movs	r1, r4
    2dd8:	201f      	movs	r0, #31
    2dda:	47a8      	blx	r5
	port_pin_set_config(LED4, &config_port_pin);
    2ddc:	0021      	movs	r1, r4
    2dde:	201e      	movs	r0, #30
    2de0:	47a8      	blx	r5
	set_drivestrength_ORB();
    2de2:	4b04      	ldr	r3, [pc, #16]	; (2df4 <ORB_setup_pins+0x54>)
    2de4:	4798      	blx	r3
	port_base->OUTCLR.reg	   = CLEAR_ORB_LEDS;
    2de6:	4a04      	ldr	r2, [pc, #16]	; (2df8 <ORB_setup_pins+0x58>)
    2de8:	4b04      	ldr	r3, [pc, #16]	; (2dfc <ORB_setup_pins+0x5c>)
    2dea:	615a      	str	r2, [r3, #20]
}
    2dec:	b003      	add	sp, #12
    2dee:	bd30      	pop	{r4, r5, pc}
    2df0:	00002c45 	.word	0x00002c45
    2df4:	00002d85 	.word	0x00002d85
    2df8:	c8038300 	.word	0xc8038300
    2dfc:	41004400 	.word	0x41004400

00002e00 <ORB_timer_callbacks_init>:

//Register the callbacks 
void ORB_timer_callbacks_init()
{
    2e00:	b570      	push	{r4, r5, r6, lr}
	tc_register_callback(&orb_tc_instance, tc_callback_OF,TC_CALLBACK_OVERFLOW);
    2e02:	4d05      	ldr	r5, [pc, #20]	; (2e18 <ORB_timer_callbacks_init+0x18>)
    2e04:	2200      	movs	r2, #0
    2e06:	4905      	ldr	r1, [pc, #20]	; (2e1c <ORB_timer_callbacks_init+0x1c>)
    2e08:	0028      	movs	r0, r5
    2e0a:	4c05      	ldr	r4, [pc, #20]	; (2e20 <ORB_timer_callbacks_init+0x20>)
    2e0c:	47a0      	blx	r4
	tc_register_callback(&orb_tc_instance, tc_callback_PWM,TC_CALLBACK_CC_CHANNEL0);
    2e0e:	2202      	movs	r2, #2
    2e10:	4904      	ldr	r1, [pc, #16]	; (2e24 <ORB_timer_callbacks_init+0x24>)
    2e12:	0028      	movs	r0, r5
    2e14:	47a0      	blx	r4
}
    2e16:	bd70      	pop	{r4, r5, r6, pc}
    2e18:	200002c8 	.word	0x200002c8
    2e1c:	00002c6b 	.word	0x00002c6b
    2e20:	000027b5 	.word	0x000027b5
    2e24:	00002c69 	.word	0x00002c69

00002e28 <enable_ORB>:

//Enable the callbacks
void enable_ORB()
{
    2e28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2e2a:	46ce      	mov	lr, r9
    2e2c:	4647      	mov	r7, r8
    2e2e:	b580      	push	{r7, lr}
	system_interrupt_enable(_tc_interrupt_get_interrupt_vector(_tc_get_inst_index(module->hw)));
    2e30:	4c13      	ldr	r4, [pc, #76]	; (2e80 <enable_ORB+0x58>)
    2e32:	6820      	ldr	r0, [r4, #0]
    2e34:	4b13      	ldr	r3, [pc, #76]	; (2e84 <enable_ORB+0x5c>)
    2e36:	4699      	mov	r9, r3
    2e38:	4798      	blx	r3
	return (enum system_interrupt_vector)tc_interrupt_vectors[inst_num];
    2e3a:	4b13      	ldr	r3, [pc, #76]	; (2e88 <enable_ORB+0x60>)
    2e3c:	4698      	mov	r8, r3
    2e3e:	5c1b      	ldrb	r3, [r3, r0]
    2e40:	261f      	movs	r6, #31
    2e42:	4033      	ands	r3, r6
    2e44:	2501      	movs	r5, #1
    2e46:	002a      	movs	r2, r5
    2e48:	409a      	lsls	r2, r3
    2e4a:	4f10      	ldr	r7, [pc, #64]	; (2e8c <enable_ORB+0x64>)
    2e4c:	603a      	str	r2, [r7, #0]
		module->enable_callback_mask |= (1 << callback_type);
    2e4e:	7e63      	ldrb	r3, [r4, #25]
    2e50:	2201      	movs	r2, #1
    2e52:	4313      	orrs	r3, r2
    2e54:	7663      	strb	r3, [r4, #25]
		module->hw->COUNT8.INTENSET.reg = (1 << callback_type);
    2e56:	6823      	ldr	r3, [r4, #0]
    2e58:	735d      	strb	r5, [r3, #13]
	system_interrupt_enable(_tc_interrupt_get_interrupt_vector(_tc_get_inst_index(module->hw)));
    2e5a:	0018      	movs	r0, r3
    2e5c:	47c8      	blx	r9
    2e5e:	4643      	mov	r3, r8
    2e60:	5c1b      	ldrb	r3, [r3, r0]
    2e62:	401e      	ands	r6, r3
    2e64:	40b5      	lsls	r5, r6
    2e66:	603d      	str	r5, [r7, #0]
		module->enable_callback_mask |= TC_INTFLAG_MC(1);
    2e68:	7e63      	ldrb	r3, [r4, #25]
    2e6a:	2210      	movs	r2, #16
    2e6c:	4313      	orrs	r3, r2
    2e6e:	7663      	strb	r3, [r4, #25]
		module->hw->COUNT8.INTENSET.reg = TC_INTFLAG_MC(1);
    2e70:	6823      	ldr	r3, [r4, #0]
    2e72:	2210      	movs	r2, #16
    2e74:	735a      	strb	r2, [r3, #13]
	tc_enable_callback(&orb_tc_instance, TC_CALLBACK_OVERFLOW);
	tc_enable_callback(&orb_tc_instance, TC_CALLBACK_CC_CHANNEL0);
}
    2e76:	bc0c      	pop	{r2, r3}
    2e78:	4690      	mov	r8, r2
    2e7a:	4699      	mov	r9, r3
    2e7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2e7e:	46c0      	nop			; (mov r8, r8)
    2e80:	200002c8 	.word	0x200002c8
    2e84:	00002561 	.word	0x00002561
    2e88:	00003c9c 	.word	0x00003c9c
    2e8c:	e000e100 	.word	0xe000e100

00002e90 <initializing_pin_array>:


//Initialize the pin array with PINS of RGB LED and LED 1 , LED 4
void initializing_pin_array()
{
	temp_pin_array_2[0]  = ORB_R1;
    2e90:	4b08      	ldr	r3, [pc, #32]	; (2eb4 <initializing_pin_array+0x24>)
    2e92:	220f      	movs	r2, #15
    2e94:	701a      	strb	r2, [r3, #0]
	temp_pin_array_2[1]  = ORB_G1;
    2e96:	3201      	adds	r2, #1
    2e98:	705a      	strb	r2, [r3, #1]
	temp_pin_array_2[2]  = ORB_B1;
    2e9a:	3201      	adds	r2, #1
    2e9c:	709a      	strb	r2, [r3, #2]
	temp_pin_array_2[3]  = ORB_R2;
    2e9e:	3a09      	subs	r2, #9
    2ea0:	70da      	strb	r2, [r3, #3]
	temp_pin_array_2[4]  = ORB_G2;
    2ea2:	3201      	adds	r2, #1
    2ea4:	711a      	strb	r2, [r3, #4]
	temp_pin_array_2[5]  = ORB_B2;
    2ea6:	3212      	adds	r2, #18
    2ea8:	715a      	strb	r2, [r3, #5]
	temp_pin_array_2[6]  = LED1;
    2eaa:	3204      	adds	r2, #4
    2eac:	719a      	strb	r2, [r3, #6]
	temp_pin_array_2[7]  = LED4;
    2eae:	3a01      	subs	r2, #1
    2eb0:	71da      	strb	r2, [r3, #7]
}
    2eb2:	4770      	bx	lr
    2eb4:	20000328 	.word	0x20000328

00002eb8 <initializing_compare_array>:


void initializing_compare_array()
{
	temp_compare_array_2[0] = 255;//Left  -- R
    2eb8:	4b05      	ldr	r3, [pc, #20]	; (2ed0 <initializing_compare_array+0x18>)
    2eba:	22ff      	movs	r2, #255	; 0xff
    2ebc:	701a      	strb	r2, [r3, #0]
	temp_compare_array_2[1] = 255;//Left  -- G
    2ebe:	705a      	strb	r2, [r3, #1]
	temp_compare_array_2[2] = 255;//Left  -- B
    2ec0:	709a      	strb	r2, [r3, #2]
	
	temp_compare_array_2[3] = 255;//Right -- R
    2ec2:	70da      	strb	r2, [r3, #3]
	temp_compare_array_2[4] = 255;//Right -- G
    2ec4:	711a      	strb	r2, [r3, #4]
	temp_compare_array_2[5] = 255;//Right -- B
    2ec6:	715a      	strb	r2, [r3, #5]
	
	temp_compare_array_2[6] = 255;//LED1
    2ec8:	719a      	strb	r2, [r3, #6]
	temp_compare_array_2[7] = 255;//LED4
    2eca:	71da      	strb	r2, [r3, #7]
}
    2ecc:	4770      	bx	lr
    2ece:	46c0      	nop			; (mov r8, r8)
    2ed0:	2000034c 	.word	0x2000034c

00002ed4 <ORB_init_array>:


void ORB_init_array()
{
    2ed4:	b510      	push	{r4, lr}
	initializing_pin_array();
    2ed6:	4b03      	ldr	r3, [pc, #12]	; (2ee4 <ORB_init_array+0x10>)
    2ed8:	4798      	blx	r3
	initializing_compare_array();
    2eda:	4b03      	ldr	r3, [pc, #12]	; (2ee8 <ORB_init_array+0x14>)
    2edc:	4798      	blx	r3
	increasing_sort_tag();
    2ede:	4b03      	ldr	r3, [pc, #12]	; (2eec <ORB_init_array+0x18>)
    2ee0:	4798      	blx	r3
}
    2ee2:	bd10      	pop	{r4, pc}
    2ee4:	00002e91 	.word	0x00002e91
    2ee8:	00002eb9 	.word	0x00002eb9
    2eec:	00002c6d 	.word	0x00002c6d

00002ef0 <ORB_init>:

void ORB_init()
{
    2ef0:	b510      	push	{r4, lr}
	//Timer Initialization
	ORB_timer_init();
    2ef2:	4b04      	ldr	r3, [pc, #16]	; (2f04 <ORB_init+0x14>)
    2ef4:	4798      	blx	r3
	ORB_setup_pins();
    2ef6:	4b04      	ldr	r3, [pc, #16]	; (2f08 <ORB_init+0x18>)
    2ef8:	4798      	blx	r3
	ORB_init_array();
    2efa:	4b04      	ldr	r3, [pc, #16]	; (2f0c <ORB_init+0x1c>)
    2efc:	4798      	blx	r3
	//Initialize the timer callbacks
	ORB_timer_callbacks_init();
    2efe:	4b04      	ldr	r3, [pc, #16]	; (2f10 <ORB_init+0x20>)
    2f00:	4798      	blx	r3

    2f02:	bd10      	pop	{r4, pc}
    2f04:	00002d19 	.word	0x00002d19
    2f08:	00002da1 	.word	0x00002da1
    2f0c:	00002ed5 	.word	0x00002ed5
    2f10:	00002e01 	.word	0x00002e01

00002f14 <system_board_init>:
{
	/* This function is meant to contain board-specific initialization code
	 * for, e.g., the I/O pins. The initialization can rely on application-
	 * specific board configuration, found in conf_board.h.
	 */
    2f14:	4770      	bx	lr
	...

00002f18 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    2f18:	4b0c      	ldr	r3, [pc, #48]	; (2f4c <cpu_irq_enter_critical+0x34>)
    2f1a:	681b      	ldr	r3, [r3, #0]
    2f1c:	2b00      	cmp	r3, #0
    2f1e:	d106      	bne.n	2f2e <cpu_irq_enter_critical+0x16>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    2f20:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
    2f24:	2b00      	cmp	r3, #0
    2f26:	d007      	beq.n	2f38 <cpu_irq_enter_critical+0x20>
			cpu_irq_disable();
			cpu_irq_prev_interrupt_state = true;
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    2f28:	2200      	movs	r2, #0
    2f2a:	4b09      	ldr	r3, [pc, #36]	; (2f50 <cpu_irq_enter_critical+0x38>)
    2f2c:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    2f2e:	4a07      	ldr	r2, [pc, #28]	; (2f4c <cpu_irq_enter_critical+0x34>)
    2f30:	6813      	ldr	r3, [r2, #0]
    2f32:	3301      	adds	r3, #1
    2f34:	6013      	str	r3, [r2, #0]
}
    2f36:	4770      	bx	lr
  __ASM volatile ("cpsid i" : : : "memory");
    2f38:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    2f3a:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    2f3e:	2200      	movs	r2, #0
    2f40:	4b04      	ldr	r3, [pc, #16]	; (2f54 <cpu_irq_enter_critical+0x3c>)
    2f42:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    2f44:	3201      	adds	r2, #1
    2f46:	4b02      	ldr	r3, [pc, #8]	; (2f50 <cpu_irq_enter_critical+0x38>)
    2f48:	701a      	strb	r2, [r3, #0]
    2f4a:	e7f0      	b.n	2f2e <cpu_irq_enter_critical+0x16>
    2f4c:	200000cc 	.word	0x200000cc
    2f50:	200000d0 	.word	0x200000d0
    2f54:	2000000d 	.word	0x2000000d

00002f58 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    2f58:	4b08      	ldr	r3, [pc, #32]	; (2f7c <cpu_irq_leave_critical+0x24>)
    2f5a:	681a      	ldr	r2, [r3, #0]
    2f5c:	3a01      	subs	r2, #1
    2f5e:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    2f60:	681b      	ldr	r3, [r3, #0]
    2f62:	2b00      	cmp	r3, #0
    2f64:	d109      	bne.n	2f7a <cpu_irq_leave_critical+0x22>
    2f66:	4b06      	ldr	r3, [pc, #24]	; (2f80 <cpu_irq_leave_critical+0x28>)
    2f68:	781b      	ldrb	r3, [r3, #0]
    2f6a:	2b00      	cmp	r3, #0
    2f6c:	d005      	beq.n	2f7a <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    2f6e:	2201      	movs	r2, #1
    2f70:	4b04      	ldr	r3, [pc, #16]	; (2f84 <cpu_irq_leave_critical+0x2c>)
    2f72:	701a      	strb	r2, [r3, #0]
    2f74:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
    2f78:	b662      	cpsie	i
	}
}
    2f7a:	4770      	bx	lr
    2f7c:	200000cc 	.word	0x200000cc
    2f80:	200000d0 	.word	0x200000d0
    2f84:	2000000d 	.word	0x2000000d

00002f88 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    2f88:	b510      	push	{r4, lr}
	switch (clock_source) {
    2f8a:	2808      	cmp	r0, #8
    2f8c:	d803      	bhi.n	2f96 <system_clock_source_get_hz+0xe>
    2f8e:	0080      	lsls	r0, r0, #2
    2f90:	4b1b      	ldr	r3, [pc, #108]	; (3000 <system_clock_source_get_hz+0x78>)
    2f92:	581b      	ldr	r3, [r3, r0]
    2f94:	469f      	mov	pc, r3

		return _system_clock_inst.dpll.frequency;
#endif

	default:
		return 0;
    2f96:	2000      	movs	r0, #0
    2f98:	e030      	b.n	2ffc <system_clock_source_get_hz+0x74>
		return _system_clock_inst.xosc.frequency;
    2f9a:	4b1a      	ldr	r3, [pc, #104]	; (3004 <system_clock_source_get_hz+0x7c>)
    2f9c:	6918      	ldr	r0, [r3, #16]
    2f9e:	e02d      	b.n	2ffc <system_clock_source_get_hz+0x74>
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    2fa0:	4b19      	ldr	r3, [pc, #100]	; (3008 <system_clock_source_get_hz+0x80>)
    2fa2:	6a1b      	ldr	r3, [r3, #32]
    2fa4:	059b      	lsls	r3, r3, #22
    2fa6:	0f9b      	lsrs	r3, r3, #30
    2fa8:	4818      	ldr	r0, [pc, #96]	; (300c <system_clock_source_get_hz+0x84>)
    2faa:	40d8      	lsrs	r0, r3
    2fac:	e026      	b.n	2ffc <system_clock_source_get_hz+0x74>
		return _system_clock_inst.xosc32k.frequency;
    2fae:	4b15      	ldr	r3, [pc, #84]	; (3004 <system_clock_source_get_hz+0x7c>)
    2fb0:	6958      	ldr	r0, [r3, #20]
    2fb2:	e023      	b.n	2ffc <system_clock_source_get_hz+0x74>
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    2fb4:	4b13      	ldr	r3, [pc, #76]	; (3004 <system_clock_source_get_hz+0x7c>)
    2fb6:	681b      	ldr	r3, [r3, #0]
			return 0;
    2fb8:	2000      	movs	r0, #0
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    2fba:	079b      	lsls	r3, r3, #30
    2fbc:	d51e      	bpl.n	2ffc <system_clock_source_get_hz+0x74>
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    2fbe:	4912      	ldr	r1, [pc, #72]	; (3008 <system_clock_source_get_hz+0x80>)
    2fc0:	2210      	movs	r2, #16
    2fc2:	68cb      	ldr	r3, [r1, #12]
    2fc4:	421a      	tst	r2, r3
    2fc6:	d0fc      	beq.n	2fc2 <system_clock_source_get_hz+0x3a>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    2fc8:	4b0e      	ldr	r3, [pc, #56]	; (3004 <system_clock_source_get_hz+0x7c>)
    2fca:	681b      	ldr	r3, [r3, #0]
    2fcc:	075b      	lsls	r3, r3, #29
    2fce:	d401      	bmi.n	2fd4 <system_clock_source_get_hz+0x4c>
		return 48000000UL;
    2fd0:	480f      	ldr	r0, [pc, #60]	; (3010 <system_clock_source_get_hz+0x88>)
    2fd2:	e013      	b.n	2ffc <system_clock_source_get_hz+0x74>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    2fd4:	2000      	movs	r0, #0
    2fd6:	4b0f      	ldr	r3, [pc, #60]	; (3014 <system_clock_source_get_hz+0x8c>)
    2fd8:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    2fda:	4b0a      	ldr	r3, [pc, #40]	; (3004 <system_clock_source_get_hz+0x7c>)
    2fdc:	689b      	ldr	r3, [r3, #8]
    2fde:	041b      	lsls	r3, r3, #16
    2fe0:	0c1b      	lsrs	r3, r3, #16
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    2fe2:	4358      	muls	r0, r3
    2fe4:	e00a      	b.n	2ffc <system_clock_source_get_hz+0x74>
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    2fe6:	2350      	movs	r3, #80	; 0x50
    2fe8:	4a07      	ldr	r2, [pc, #28]	; (3008 <system_clock_source_get_hz+0x80>)
    2fea:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
    2fec:	2000      	movs	r0, #0
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    2fee:	075b      	lsls	r3, r3, #29
    2ff0:	d504      	bpl.n	2ffc <system_clock_source_get_hz+0x74>
		return _system_clock_inst.dpll.frequency;
    2ff2:	4b04      	ldr	r3, [pc, #16]	; (3004 <system_clock_source_get_hz+0x7c>)
    2ff4:	68d8      	ldr	r0, [r3, #12]
    2ff6:	e001      	b.n	2ffc <system_clock_source_get_hz+0x74>
		return 32768UL;
    2ff8:	2080      	movs	r0, #128	; 0x80
    2ffa:	0200      	lsls	r0, r0, #8
	}
}
    2ffc:	bd10      	pop	{r4, pc}
    2ffe:	46c0      	nop			; (mov r8, r8)
    3000:	00003ca0 	.word	0x00003ca0
    3004:	200000d4 	.word	0x200000d4
    3008:	40000800 	.word	0x40000800
    300c:	007a1200 	.word	0x007a1200
    3010:	02dc6c00 	.word	0x02dc6c00
    3014:	000033e9 	.word	0x000033e9

00003018 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    3018:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    301a:	490c      	ldr	r1, [pc, #48]	; (304c <system_clock_source_osc8m_set_config+0x34>)
    301c:	6a0b      	ldr	r3, [r1, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    301e:	7804      	ldrb	r4, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
    3020:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    3022:	7840      	ldrb	r0, [r0, #1]
    3024:	2201      	movs	r2, #1
    3026:	4010      	ands	r0, r2
    3028:	0180      	lsls	r0, r0, #6
    302a:	2640      	movs	r6, #64	; 0x40
    302c:	43b3      	bics	r3, r6
    302e:	4303      	orrs	r3, r0
    3030:	402a      	ands	r2, r5
    3032:	01d2      	lsls	r2, r2, #7
    3034:	2080      	movs	r0, #128	; 0x80
    3036:	4383      	bics	r3, r0
    3038:	4313      	orrs	r3, r2
    303a:	2203      	movs	r2, #3
    303c:	4022      	ands	r2, r4
    303e:	0212      	lsls	r2, r2, #8
    3040:	4803      	ldr	r0, [pc, #12]	; (3050 <system_clock_source_osc8m_set_config+0x38>)
    3042:	4003      	ands	r3, r0
    3044:	4313      	orrs	r3, r2
    3046:	620b      	str	r3, [r1, #32]
}
    3048:	bd70      	pop	{r4, r5, r6, pc}
    304a:	46c0      	nop			; (mov r8, r8)
    304c:	40000800 	.word	0x40000800
    3050:	fffffcff 	.word	0xfffffcff

00003054 <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    3054:	2808      	cmp	r0, #8
    3056:	d803      	bhi.n	3060 <system_clock_source_enable+0xc>
    3058:	0080      	lsls	r0, r0, #2
    305a:	4b25      	ldr	r3, [pc, #148]	; (30f0 <system_clock_source_enable+0x9c>)
    305c:	581b      	ldr	r3, [r3, r0]
    305e:	469f      	mov	pc, r3
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    3060:	2017      	movs	r0, #23
    3062:	e044      	b.n	30ee <system_clock_source_enable+0x9a>
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    3064:	4a23      	ldr	r2, [pc, #140]	; (30f4 <system_clock_source_enable+0xa0>)
    3066:	6a13      	ldr	r3, [r2, #32]
    3068:	2102      	movs	r1, #2
    306a:	430b      	orrs	r3, r1
    306c:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
    306e:	2000      	movs	r0, #0
    3070:	e03d      	b.n	30ee <system_clock_source_enable+0x9a>
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    3072:	4a20      	ldr	r2, [pc, #128]	; (30f4 <system_clock_source_enable+0xa0>)
    3074:	6993      	ldr	r3, [r2, #24]
    3076:	2102      	movs	r1, #2
    3078:	430b      	orrs	r3, r1
    307a:	6193      	str	r3, [r2, #24]
	}

	return STATUS_OK;
    307c:	2000      	movs	r0, #0
		break;
    307e:	e036      	b.n	30ee <system_clock_source_enable+0x9a>
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    3080:	4a1c      	ldr	r2, [pc, #112]	; (30f4 <system_clock_source_enable+0xa0>)
    3082:	8a13      	ldrh	r3, [r2, #16]
    3084:	2102      	movs	r1, #2
    3086:	430b      	orrs	r3, r1
    3088:	8213      	strh	r3, [r2, #16]
	return STATUS_OK;
    308a:	2000      	movs	r0, #0
		break;
    308c:	e02f      	b.n	30ee <system_clock_source_enable+0x9a>
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    308e:	4a19      	ldr	r2, [pc, #100]	; (30f4 <system_clock_source_enable+0xa0>)
    3090:	8a93      	ldrh	r3, [r2, #20]
    3092:	2102      	movs	r1, #2
    3094:	430b      	orrs	r3, r1
    3096:	8293      	strh	r3, [r2, #20]
	return STATUS_OK;
    3098:	2000      	movs	r0, #0
		break;
    309a:	e028      	b.n	30ee <system_clock_source_enable+0x9a>
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    309c:	4916      	ldr	r1, [pc, #88]	; (30f8 <system_clock_source_enable+0xa4>)
    309e:	680b      	ldr	r3, [r1, #0]
    30a0:	2202      	movs	r2, #2
    30a2:	4313      	orrs	r3, r2
    30a4:	600b      	str	r3, [r1, #0]
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    30a6:	4b13      	ldr	r3, [pc, #76]	; (30f4 <system_clock_source_enable+0xa0>)
    30a8:	849a      	strh	r2, [r3, #36]	; 0x24
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    30aa:	0019      	movs	r1, r3
    30ac:	320e      	adds	r2, #14
    30ae:	68cb      	ldr	r3, [r1, #12]
    30b0:	421a      	tst	r2, r3
    30b2:	d0fc      	beq.n	30ae <system_clock_source_enable+0x5a>
	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    30b4:	4a10      	ldr	r2, [pc, #64]	; (30f8 <system_clock_source_enable+0xa4>)
    30b6:	6891      	ldr	r1, [r2, #8]
    30b8:	4b0e      	ldr	r3, [pc, #56]	; (30f4 <system_clock_source_enable+0xa0>)
    30ba:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    30bc:	6852      	ldr	r2, [r2, #4]
    30be:	629a      	str	r2, [r3, #40]	; 0x28
	SYSCTRL->DFLLCTRL.reg = 0;
    30c0:	2200      	movs	r2, #0
    30c2:	849a      	strh	r2, [r3, #36]	; 0x24
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    30c4:	0019      	movs	r1, r3
    30c6:	3210      	adds	r2, #16
    30c8:	68cb      	ldr	r3, [r1, #12]
    30ca:	421a      	tst	r2, r3
    30cc:	d0fc      	beq.n	30c8 <system_clock_source_enable+0x74>
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    30ce:	4b0a      	ldr	r3, [pc, #40]	; (30f8 <system_clock_source_enable+0xa4>)
    30d0:	681b      	ldr	r3, [r3, #0]
    30d2:	b29b      	uxth	r3, r3
    30d4:	4a07      	ldr	r2, [pc, #28]	; (30f4 <system_clock_source_enable+0xa0>)
    30d6:	8493      	strh	r3, [r2, #36]	; 0x24
	return STATUS_OK;
    30d8:	2000      	movs	r0, #0
    30da:	e008      	b.n	30ee <system_clock_source_enable+0x9a>
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    30dc:	4905      	ldr	r1, [pc, #20]	; (30f4 <system_clock_source_enable+0xa0>)
    30de:	2244      	movs	r2, #68	; 0x44
    30e0:	5c8b      	ldrb	r3, [r1, r2]
    30e2:	2002      	movs	r0, #2
    30e4:	4303      	orrs	r3, r0
    30e6:	548b      	strb	r3, [r1, r2]
	return STATUS_OK;
    30e8:	2000      	movs	r0, #0
		break;
    30ea:	e000      	b.n	30ee <system_clock_source_enable+0x9a>
		return STATUS_OK;
    30ec:	2000      	movs	r0, #0
}
    30ee:	4770      	bx	lr
    30f0:	00003cc4 	.word	0x00003cc4
    30f4:	40000800 	.word	0x40000800
    30f8:	200000d4 	.word	0x200000d4

000030fc <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    30fc:	b530      	push	{r4, r5, lr}
    30fe:	b085      	sub	sp, #20
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    3100:	22c2      	movs	r2, #194	; 0xc2
    3102:	00d2      	lsls	r2, r2, #3
    3104:	4b1a      	ldr	r3, [pc, #104]	; (3170 <system_clock_init+0x74>)
    3106:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    3108:	4a1a      	ldr	r2, [pc, #104]	; (3174 <system_clock_init+0x78>)
    310a:	6853      	ldr	r3, [r2, #4]
    310c:	211e      	movs	r1, #30
    310e:	438b      	bics	r3, r1
    3110:	6053      	str	r3, [r2, #4]
	gclk_conf.source_generator = GCLK_GENERATOR_1;
    3112:	2301      	movs	r3, #1
    3114:	466a      	mov	r2, sp
    3116:	7013      	strb	r3, [r2, #0]
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    3118:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    311a:	4d17      	ldr	r5, [pc, #92]	; (3178 <system_clock_init+0x7c>)
    311c:	b2e0      	uxtb	r0, r4
    311e:	4669      	mov	r1, sp
    3120:	47a8      	blx	r5
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    3122:	3401      	adds	r4, #1
    3124:	2c18      	cmp	r4, #24
    3126:	d1f9      	bne.n	311c <system_clock_init+0x20>
	config->run_in_standby  = false;
    3128:	a803      	add	r0, sp, #12
    312a:	2400      	movs	r4, #0
    312c:	7044      	strb	r4, [r0, #1]
	config->on_demand       = true;
    312e:	2501      	movs	r5, #1
    3130:	7085      	strb	r5, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    3132:	7004      	strb	r4, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
    3134:	4b11      	ldr	r3, [pc, #68]	; (317c <system_clock_init+0x80>)
    3136:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    3138:	2006      	movs	r0, #6
    313a:	4b11      	ldr	r3, [pc, #68]	; (3180 <system_clock_init+0x84>)
    313c:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    313e:	4b11      	ldr	r3, [pc, #68]	; (3184 <system_clock_init+0x88>)
    3140:	4798      	blx	r3
	PM->CPUSEL.reg = (uint32_t)divider;
    3142:	4b11      	ldr	r3, [pc, #68]	; (3188 <system_clock_init+0x8c>)
    3144:	721c      	strb	r4, [r3, #8]
			PM->APBASEL.reg = (uint32_t)divider;
    3146:	725c      	strb	r4, [r3, #9]
			PM->APBBSEL.reg = (uint32_t)divider;
    3148:	729c      	strb	r4, [r3, #10]
			PM->APBCSEL.reg = (uint32_t)divider;
    314a:	72dc      	strb	r4, [r3, #11]
	config->division_factor    = 1;
    314c:	9501      	str	r5, [sp, #4]
	config->high_when_disabled = false;
    314e:	466b      	mov	r3, sp
    3150:	705c      	strb	r4, [r3, #1]
	config->source_clock       = GCLK_SOURCE_OSC8M;
    3152:	2306      	movs	r3, #6
    3154:	466a      	mov	r2, sp
    3156:	7013      	strb	r3, [r2, #0]
	config->run_in_standby     = false;
    3158:	7214      	strb	r4, [r2, #8]
	config->output_enable      = false;
    315a:	7254      	strb	r4, [r2, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    315c:	4669      	mov	r1, sp
    315e:	2000      	movs	r0, #0
    3160:	4b0a      	ldr	r3, [pc, #40]	; (318c <system_clock_init+0x90>)
    3162:	4798      	blx	r3
    3164:	2000      	movs	r0, #0
    3166:	4b0a      	ldr	r3, [pc, #40]	; (3190 <system_clock_init+0x94>)
    3168:	4798      	blx	r3
#endif
}
    316a:	b005      	add	sp, #20
    316c:	bd30      	pop	{r4, r5, pc}
    316e:	46c0      	nop			; (mov r8, r8)
    3170:	40000800 	.word	0x40000800
    3174:	41004000 	.word	0x41004000
    3178:	000033cd 	.word	0x000033cd
    317c:	00003019 	.word	0x00003019
    3180:	00003055 	.word	0x00003055
    3184:	00003195 	.word	0x00003195
    3188:	40000400 	.word	0x40000400
    318c:	000031b9 	.word	0x000031b9
    3190:	00003271 	.word	0x00003271

00003194 <system_gclk_init>:
			PM->APBAMASK.reg |= mask;
    3194:	4a06      	ldr	r2, [pc, #24]	; (31b0 <system_gclk_init+0x1c>)
    3196:	6993      	ldr	r3, [r2, #24]
    3198:	2108      	movs	r1, #8
    319a:	430b      	orrs	r3, r1
    319c:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    319e:	2201      	movs	r2, #1
    31a0:	4b04      	ldr	r3, [pc, #16]	; (31b4 <system_gclk_init+0x20>)
    31a2:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    31a4:	0019      	movs	r1, r3
    31a6:	780b      	ldrb	r3, [r1, #0]
    31a8:	4213      	tst	r3, r2
    31aa:	d1fc      	bne.n	31a6 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    31ac:	4770      	bx	lr
    31ae:	46c0      	nop			; (mov r8, r8)
    31b0:	40000400 	.word	0x40000400
    31b4:	40000c00 	.word	0x40000c00

000031b8 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    31b8:	b570      	push	{r4, r5, r6, lr}
    31ba:	0006      	movs	r6, r0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    31bc:	0004      	movs	r4, r0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    31be:	780d      	ldrb	r5, [r1, #0]
    31c0:	022d      	lsls	r5, r5, #8
    31c2:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    31c4:	784b      	ldrb	r3, [r1, #1]
    31c6:	2b00      	cmp	r3, #0
    31c8:	d002      	beq.n	31d0 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    31ca:	2380      	movs	r3, #128	; 0x80
    31cc:	02db      	lsls	r3, r3, #11
    31ce:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    31d0:	7a4b      	ldrb	r3, [r1, #9]
    31d2:	2b00      	cmp	r3, #0
    31d4:	d002      	beq.n	31dc <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    31d6:	2380      	movs	r3, #128	; 0x80
    31d8:	031b      	lsls	r3, r3, #12
    31da:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    31dc:	6848      	ldr	r0, [r1, #4]
    31de:	2801      	cmp	r0, #1
    31e0:	d910      	bls.n	3204 <system_gclk_gen_set_config+0x4c>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    31e2:	1e43      	subs	r3, r0, #1
    31e4:	4218      	tst	r0, r3
    31e6:	d134      	bne.n	3252 <system_gclk_gen_set_config+0x9a>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    31e8:	2802      	cmp	r0, #2
    31ea:	d930      	bls.n	324e <system_gclk_gen_set_config+0x96>
    31ec:	2302      	movs	r3, #2
    31ee:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    31f0:	3201      	adds	r2, #1
						mask <<= 1) {
    31f2:	005b      	lsls	r3, r3, #1
			for (mask = (1UL << 1); mask < config->division_factor;
    31f4:	4298      	cmp	r0, r3
    31f6:	d8fb      	bhi.n	31f0 <system_gclk_gen_set_config+0x38>
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    31f8:	0212      	lsls	r2, r2, #8
    31fa:	4332      	orrs	r2, r6
    31fc:	0014      	movs	r4, r2
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    31fe:	2380      	movs	r3, #128	; 0x80
    3200:	035b      	lsls	r3, r3, #13
    3202:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    3204:	7a0b      	ldrb	r3, [r1, #8]
    3206:	2b00      	cmp	r3, #0
    3208:	d002      	beq.n	3210 <system_gclk_gen_set_config+0x58>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    320a:	2380      	movs	r3, #128	; 0x80
    320c:	039b      	lsls	r3, r3, #14
    320e:	431d      	orrs	r5, r3
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    3210:	4a13      	ldr	r2, [pc, #76]	; (3260 <system_gclk_gen_set_config+0xa8>)
    3212:	7853      	ldrb	r3, [r2, #1]
	}

	while (system_gclk_is_syncing()) {
    3214:	b25b      	sxtb	r3, r3
    3216:	2b00      	cmp	r3, #0
    3218:	dbfb      	blt.n	3212 <system_gclk_gen_set_config+0x5a>
	cpu_irq_enter_critical();
    321a:	4b12      	ldr	r3, [pc, #72]	; (3264 <system_gclk_gen_set_config+0xac>)
    321c:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    321e:	4b12      	ldr	r3, [pc, #72]	; (3268 <system_gclk_gen_set_config+0xb0>)
    3220:	701e      	strb	r6, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    3222:	4a0f      	ldr	r2, [pc, #60]	; (3260 <system_gclk_gen_set_config+0xa8>)
    3224:	7853      	ldrb	r3, [r2, #1]

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    3226:	b25b      	sxtb	r3, r3
    3228:	2b00      	cmp	r3, #0
    322a:	dbfb      	blt.n	3224 <system_gclk_gen_set_config+0x6c>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    322c:	4b0c      	ldr	r3, [pc, #48]	; (3260 <system_gclk_gen_set_config+0xa8>)
    322e:	609c      	str	r4, [r3, #8]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    3230:	001a      	movs	r2, r3
    3232:	7853      	ldrb	r3, [r2, #1]

	while (system_gclk_is_syncing()) {
    3234:	b25b      	sxtb	r3, r3
    3236:	2b00      	cmp	r3, #0
    3238:	dbfb      	blt.n	3232 <system_gclk_gen_set_config+0x7a>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    323a:	4a09      	ldr	r2, [pc, #36]	; (3260 <system_gclk_gen_set_config+0xa8>)
    323c:	6853      	ldr	r3, [r2, #4]
    323e:	2180      	movs	r1, #128	; 0x80
    3240:	0249      	lsls	r1, r1, #9
    3242:	400b      	ands	r3, r1
    3244:	431d      	orrs	r5, r3
    3246:	6055      	str	r5, [r2, #4]
	cpu_irq_leave_critical();
    3248:	4b08      	ldr	r3, [pc, #32]	; (326c <system_gclk_gen_set_config+0xb4>)
    324a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    324c:	bd70      	pop	{r4, r5, r6, pc}
			for (mask = (1UL << 1); mask < config->division_factor;
    324e:	2200      	movs	r2, #0
    3250:	e7d2      	b.n	31f8 <system_gclk_gen_set_config+0x40>
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    3252:	0204      	lsls	r4, r0, #8
			new_gendiv_config  |=
    3254:	4334      	orrs	r4, r6
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    3256:	2380      	movs	r3, #128	; 0x80
    3258:	029b      	lsls	r3, r3, #10
    325a:	431d      	orrs	r5, r3
    325c:	e7d2      	b.n	3204 <system_gclk_gen_set_config+0x4c>
    325e:	46c0      	nop			; (mov r8, r8)
    3260:	40000c00 	.word	0x40000c00
    3264:	00002f19 	.word	0x00002f19
    3268:	40000c08 	.word	0x40000c08
    326c:	00002f59 	.word	0x00002f59

00003270 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    3270:	b510      	push	{r4, lr}
    3272:	0004      	movs	r4, r0
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    3274:	4a0b      	ldr	r2, [pc, #44]	; (32a4 <system_gclk_gen_enable+0x34>)
    3276:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    3278:	b25b      	sxtb	r3, r3
    327a:	2b00      	cmp	r3, #0
    327c:	dbfb      	blt.n	3276 <system_gclk_gen_enable+0x6>
	cpu_irq_enter_critical();
    327e:	4b0a      	ldr	r3, [pc, #40]	; (32a8 <system_gclk_gen_enable+0x38>)
    3280:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    3282:	4b0a      	ldr	r3, [pc, #40]	; (32ac <system_gclk_gen_enable+0x3c>)
    3284:	701c      	strb	r4, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    3286:	4a07      	ldr	r2, [pc, #28]	; (32a4 <system_gclk_gen_enable+0x34>)
    3288:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    328a:	b25b      	sxtb	r3, r3
    328c:	2b00      	cmp	r3, #0
    328e:	dbfb      	blt.n	3288 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    3290:	4a04      	ldr	r2, [pc, #16]	; (32a4 <system_gclk_gen_enable+0x34>)
    3292:	6851      	ldr	r1, [r2, #4]
    3294:	2380      	movs	r3, #128	; 0x80
    3296:	025b      	lsls	r3, r3, #9
    3298:	430b      	orrs	r3, r1
    329a:	6053      	str	r3, [r2, #4]
	cpu_irq_leave_critical();
    329c:	4b04      	ldr	r3, [pc, #16]	; (32b0 <system_gclk_gen_enable+0x40>)
    329e:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    32a0:	bd10      	pop	{r4, pc}
    32a2:	46c0      	nop			; (mov r8, r8)
    32a4:	40000c00 	.word	0x40000c00
    32a8:	00002f19 	.word	0x00002f19
    32ac:	40000c04 	.word	0x40000c04
    32b0:	00002f59 	.word	0x00002f59

000032b4 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    32b4:	b570      	push	{r4, r5, r6, lr}
    32b6:	0004      	movs	r4, r0
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    32b8:	4a1a      	ldr	r2, [pc, #104]	; (3324 <system_gclk_gen_get_hz+0x70>)
    32ba:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    32bc:	b25b      	sxtb	r3, r3
    32be:	2b00      	cmp	r3, #0
    32c0:	dbfb      	blt.n	32ba <system_gclk_gen_get_hz+0x6>
	cpu_irq_enter_critical();
    32c2:	4b19      	ldr	r3, [pc, #100]	; (3328 <system_gclk_gen_get_hz+0x74>)
    32c4:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    32c6:	4b19      	ldr	r3, [pc, #100]	; (332c <system_gclk_gen_get_hz+0x78>)
    32c8:	701c      	strb	r4, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    32ca:	4a16      	ldr	r2, [pc, #88]	; (3324 <system_gclk_gen_get_hz+0x70>)
    32cc:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    32ce:	b25b      	sxtb	r3, r3
    32d0:	2b00      	cmp	r3, #0
    32d2:	dbfb      	blt.n	32cc <system_gclk_gen_get_hz+0x18>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    32d4:	4e13      	ldr	r6, [pc, #76]	; (3324 <system_gclk_gen_get_hz+0x70>)
    32d6:	6870      	ldr	r0, [r6, #4]
    32d8:	04c0      	lsls	r0, r0, #19
    32da:	0ec0      	lsrs	r0, r0, #27
	uint32_t gen_input_hz = system_clock_source_get_hz(
    32dc:	4b14      	ldr	r3, [pc, #80]	; (3330 <system_gclk_gen_get_hz+0x7c>)
    32de:	4798      	blx	r3
    32e0:	0005      	movs	r5, r0

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    32e2:	4b12      	ldr	r3, [pc, #72]	; (332c <system_gclk_gen_get_hz+0x78>)
    32e4:	701c      	strb	r4, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    32e6:	6876      	ldr	r6, [r6, #4]
    32e8:	02f6      	lsls	r6, r6, #11
    32ea:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    32ec:	4b11      	ldr	r3, [pc, #68]	; (3334 <system_gclk_gen_get_hz+0x80>)
    32ee:	701c      	strb	r4, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    32f0:	4a0c      	ldr	r2, [pc, #48]	; (3324 <system_gclk_gen_get_hz+0x70>)
    32f2:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    32f4:	b25b      	sxtb	r3, r3
    32f6:	2b00      	cmp	r3, #0
    32f8:	dbfb      	blt.n	32f2 <system_gclk_gen_get_hz+0x3e>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    32fa:	4b0a      	ldr	r3, [pc, #40]	; (3324 <system_gclk_gen_get_hz+0x70>)
    32fc:	689c      	ldr	r4, [r3, #8]
    32fe:	0224      	lsls	r4, r4, #8
    3300:	0c24      	lsrs	r4, r4, #16
	cpu_irq_leave_critical();
    3302:	4b0d      	ldr	r3, [pc, #52]	; (3338 <system_gclk_gen_get_hz+0x84>)
    3304:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    3306:	2e00      	cmp	r6, #0
    3308:	d107      	bne.n	331a <system_gclk_gen_get_hz+0x66>
    330a:	2c01      	cmp	r4, #1
    330c:	d907      	bls.n	331e <system_gclk_gen_get_hz+0x6a>
		gen_input_hz /= divider;
    330e:	0021      	movs	r1, r4
    3310:	0028      	movs	r0, r5
    3312:	4b0a      	ldr	r3, [pc, #40]	; (333c <system_gclk_gen_get_hz+0x88>)
    3314:	4798      	blx	r3
    3316:	0005      	movs	r5, r0
    3318:	e001      	b.n	331e <system_gclk_gen_get_hz+0x6a>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    331a:	3401      	adds	r4, #1
    331c:	40e5      	lsrs	r5, r4
	}

	return gen_input_hz;
}
    331e:	0028      	movs	r0, r5
    3320:	bd70      	pop	{r4, r5, r6, pc}
    3322:	46c0      	nop			; (mov r8, r8)
    3324:	40000c00 	.word	0x40000c00
    3328:	00002f19 	.word	0x00002f19
    332c:	40000c04 	.word	0x40000c04
    3330:	00002f89 	.word	0x00002f89
    3334:	40000c08 	.word	0x40000c08
    3338:	00002f59 	.word	0x00002f59
    333c:	000036b5 	.word	0x000036b5

00003340 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    3340:	b510      	push	{r4, lr}
    3342:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    3344:	4b06      	ldr	r3, [pc, #24]	; (3360 <system_gclk_chan_enable+0x20>)
    3346:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    3348:	4b06      	ldr	r3, [pc, #24]	; (3364 <system_gclk_chan_enable+0x24>)
    334a:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    334c:	4a06      	ldr	r2, [pc, #24]	; (3368 <system_gclk_chan_enable+0x28>)
    334e:	8853      	ldrh	r3, [r2, #2]
    3350:	2180      	movs	r1, #128	; 0x80
    3352:	01c9      	lsls	r1, r1, #7
    3354:	430b      	orrs	r3, r1
    3356:	8053      	strh	r3, [r2, #2]
	cpu_irq_leave_critical();
    3358:	4b04      	ldr	r3, [pc, #16]	; (336c <system_gclk_chan_enable+0x2c>)
    335a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    335c:	bd10      	pop	{r4, pc}
    335e:	46c0      	nop			; (mov r8, r8)
    3360:	00002f19 	.word	0x00002f19
    3364:	40000c02 	.word	0x40000c02
    3368:	40000c00 	.word	0x40000c00
    336c:	00002f59 	.word	0x00002f59

00003370 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    3370:	b510      	push	{r4, lr}
    3372:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    3374:	4b0f      	ldr	r3, [pc, #60]	; (33b4 <system_gclk_chan_disable+0x44>)
    3376:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    3378:	4b0f      	ldr	r3, [pc, #60]	; (33b8 <system_gclk_chan_disable+0x48>)
    337a:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    337c:	4a0f      	ldr	r2, [pc, #60]	; (33bc <system_gclk_chan_disable+0x4c>)
    337e:	8853      	ldrh	r3, [r2, #2]
    3380:	051b      	lsls	r3, r3, #20
    3382:	0f18      	lsrs	r0, r3, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    3384:	8853      	ldrh	r3, [r2, #2]
    3386:	490e      	ldr	r1, [pc, #56]	; (33c0 <system_gclk_chan_disable+0x50>)
    3388:	400b      	ands	r3, r1
    338a:	8053      	strh	r3, [r2, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    338c:	8853      	ldrh	r3, [r2, #2]
    338e:	490d      	ldr	r1, [pc, #52]	; (33c4 <system_gclk_chan_disable+0x54>)
    3390:	400b      	ands	r3, r1
    3392:	8053      	strh	r3, [r2, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    3394:	0011      	movs	r1, r2
    3396:	2280      	movs	r2, #128	; 0x80
    3398:	01d2      	lsls	r2, r2, #7
    339a:	884b      	ldrh	r3, [r1, #2]
    339c:	4213      	tst	r3, r2
    339e:	d1fc      	bne.n	339a <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    33a0:	4906      	ldr	r1, [pc, #24]	; (33bc <system_gclk_chan_disable+0x4c>)
    33a2:	884a      	ldrh	r2, [r1, #2]
    33a4:	0203      	lsls	r3, r0, #8
    33a6:	4806      	ldr	r0, [pc, #24]	; (33c0 <system_gclk_chan_disable+0x50>)
    33a8:	4002      	ands	r2, r0
    33aa:	4313      	orrs	r3, r2
    33ac:	804b      	strh	r3, [r1, #2]
	cpu_irq_leave_critical();
    33ae:	4b06      	ldr	r3, [pc, #24]	; (33c8 <system_gclk_chan_disable+0x58>)
    33b0:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    33b2:	bd10      	pop	{r4, pc}
    33b4:	00002f19 	.word	0x00002f19
    33b8:	40000c02 	.word	0x40000c02
    33bc:	40000c00 	.word	0x40000c00
    33c0:	fffff0ff 	.word	0xfffff0ff
    33c4:	ffffbfff 	.word	0xffffbfff
    33c8:	00002f59 	.word	0x00002f59

000033cc <system_gclk_chan_set_config>:
{
    33cc:	b510      	push	{r4, lr}
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    33ce:	780c      	ldrb	r4, [r1, #0]
    33d0:	0224      	lsls	r4, r4, #8
    33d2:	4304      	orrs	r4, r0
	system_gclk_chan_disable(channel);
    33d4:	4b02      	ldr	r3, [pc, #8]	; (33e0 <system_gclk_chan_set_config+0x14>)
    33d6:	4798      	blx	r3
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    33d8:	b2a4      	uxth	r4, r4
    33da:	4b02      	ldr	r3, [pc, #8]	; (33e4 <system_gclk_chan_set_config+0x18>)
    33dc:	805c      	strh	r4, [r3, #2]
}
    33de:	bd10      	pop	{r4, pc}
    33e0:	00003371 	.word	0x00003371
    33e4:	40000c00 	.word	0x40000c00

000033e8 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    33e8:	b510      	push	{r4, lr}
    33ea:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    33ec:	4b06      	ldr	r3, [pc, #24]	; (3408 <system_gclk_chan_get_hz+0x20>)
    33ee:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    33f0:	4b06      	ldr	r3, [pc, #24]	; (340c <system_gclk_chan_get_hz+0x24>)
    33f2:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    33f4:	4b06      	ldr	r3, [pc, #24]	; (3410 <system_gclk_chan_get_hz+0x28>)
    33f6:	885c      	ldrh	r4, [r3, #2]
    33f8:	0524      	lsls	r4, r4, #20
    33fa:	0f24      	lsrs	r4, r4, #28
	cpu_irq_leave_critical();
    33fc:	4b05      	ldr	r3, [pc, #20]	; (3414 <system_gclk_chan_get_hz+0x2c>)
    33fe:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    3400:	0020      	movs	r0, r4
    3402:	4b05      	ldr	r3, [pc, #20]	; (3418 <system_gclk_chan_get_hz+0x30>)
    3404:	4798      	blx	r3
}
    3406:	bd10      	pop	{r4, pc}
    3408:	00002f19 	.word	0x00002f19
    340c:	40000c02 	.word	0x40000c02
    3410:	40000c00 	.word	0x40000c00
    3414:	00002f59 	.word	0x00002f59
    3418:	000032b5 	.word	0x000032b5

0000341c <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    341c:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    341e:	78d3      	ldrb	r3, [r2, #3]
    3420:	2b00      	cmp	r3, #0
    3422:	d135      	bne.n	3490 <_system_pinmux_config+0x74>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    3424:	7813      	ldrb	r3, [r2, #0]
    3426:	2b80      	cmp	r3, #128	; 0x80
    3428:	d029      	beq.n	347e <_system_pinmux_config+0x62>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    342a:	061b      	lsls	r3, r3, #24
    342c:	2480      	movs	r4, #128	; 0x80
    342e:	0264      	lsls	r4, r4, #9
    3430:	4323      	orrs	r3, r4
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    3432:	7854      	ldrb	r4, [r2, #1]
    3434:	2502      	movs	r5, #2
    3436:	43ac      	bics	r4, r5
    3438:	d106      	bne.n	3448 <_system_pinmux_config+0x2c>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    343a:	7894      	ldrb	r4, [r2, #2]
    343c:	2c00      	cmp	r4, #0
    343e:	d120      	bne.n	3482 <_system_pinmux_config+0x66>
			pin_cfg |= PORT_WRCONFIG_INEN;
    3440:	2480      	movs	r4, #128	; 0x80
    3442:	02a4      	lsls	r4, r4, #10
    3444:	4323      	orrs	r3, r4
				pin_cfg |= PORT_WRCONFIG_PULLEN;
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    3446:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    3448:	7854      	ldrb	r4, [r2, #1]
    344a:	3c01      	subs	r4, #1
    344c:	2c01      	cmp	r4, #1
    344e:	d91c      	bls.n	348a <_system_pinmux_config+0x6e>
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    3450:	040d      	lsls	r5, r1, #16
    3452:	0c2d      	lsrs	r5, r5, #16

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    3454:	24a0      	movs	r4, #160	; 0xa0
    3456:	05e4      	lsls	r4, r4, #23
    3458:	432c      	orrs	r4, r5
    345a:	431c      	orrs	r4, r3
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    345c:	6284      	str	r4, [r0, #40]	; 0x28
	uint32_t upper_pin_mask = (pin_mask >> 16);
    345e:	0c0d      	lsrs	r5, r1, #16

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    3460:	24d0      	movs	r4, #208	; 0xd0
    3462:	0624      	lsls	r4, r4, #24
    3464:	432c      	orrs	r4, r5
    3466:	431c      	orrs	r4, r3
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    3468:	6284      	str	r4, [r0, #40]	; 0x28
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    346a:	78d4      	ldrb	r4, [r2, #3]
    346c:	2c00      	cmp	r4, #0
    346e:	d122      	bne.n	34b6 <_system_pinmux_config+0x9a>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    3470:	035b      	lsls	r3, r3, #13
    3472:	d51c      	bpl.n	34ae <_system_pinmux_config+0x92>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    3474:	7893      	ldrb	r3, [r2, #2]
    3476:	2b01      	cmp	r3, #1
    3478:	d01e      	beq.n	34b8 <_system_pinmux_config+0x9c>
				port->OUTSET.reg = pin_mask;
			} else {
				port->OUTCLR.reg = pin_mask;
    347a:	6141      	str	r1, [r0, #20]
    347c:	e017      	b.n	34ae <_system_pinmux_config+0x92>
	uint32_t pin_cfg = 0;
    347e:	2300      	movs	r3, #0
    3480:	e7d7      	b.n	3432 <_system_pinmux_config+0x16>
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    3482:	24c0      	movs	r4, #192	; 0xc0
    3484:	02e4      	lsls	r4, r4, #11
    3486:	4323      	orrs	r3, r4
    3488:	e7dd      	b.n	3446 <_system_pinmux_config+0x2a>
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    348a:	4c0d      	ldr	r4, [pc, #52]	; (34c0 <_system_pinmux_config+0xa4>)
    348c:	4023      	ands	r3, r4
    348e:	e7df      	b.n	3450 <_system_pinmux_config+0x34>
		port->DIRCLR.reg = pin_mask;
    3490:	6041      	str	r1, [r0, #4]
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    3492:	040c      	lsls	r4, r1, #16
    3494:	0c24      	lsrs	r4, r4, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    3496:	23a0      	movs	r3, #160	; 0xa0
    3498:	05db      	lsls	r3, r3, #23
    349a:	4323      	orrs	r3, r4
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    349c:	6283      	str	r3, [r0, #40]	; 0x28
	uint32_t upper_pin_mask = (pin_mask >> 16);
    349e:	0c0c      	lsrs	r4, r1, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    34a0:	23d0      	movs	r3, #208	; 0xd0
    34a2:	061b      	lsls	r3, r3, #24
    34a4:	4323      	orrs	r3, r4
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    34a6:	6283      	str	r3, [r0, #40]	; 0x28
	if(!config->powersave) {
    34a8:	78d3      	ldrb	r3, [r2, #3]
    34aa:	2b00      	cmp	r3, #0
    34ac:	d103      	bne.n	34b6 <_system_pinmux_config+0x9a>
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    34ae:	7853      	ldrb	r3, [r2, #1]
    34b0:	3b01      	subs	r3, #1
    34b2:	2b01      	cmp	r3, #1
    34b4:	d902      	bls.n	34bc <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
		}
	}
}
    34b6:	bd30      	pop	{r4, r5, pc}
				port->OUTSET.reg = pin_mask;
    34b8:	6181      	str	r1, [r0, #24]
    34ba:	e7f8      	b.n	34ae <_system_pinmux_config+0x92>
			port->DIRSET.reg = pin_mask;
    34bc:	6081      	str	r1, [r0, #8]
}
    34be:	e7fa      	b.n	34b6 <_system_pinmux_config+0x9a>
    34c0:	fffbffff 	.word	0xfffbffff

000034c4 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    34c4:	b510      	push	{r4, lr}
    34c6:	000a      	movs	r2, r1
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    34c8:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    34ca:	2300      	movs	r3, #0
	if (port_index < PORT_INST_NUM) {
    34cc:	2900      	cmp	r1, #0
    34ce:	d104      	bne.n	34da <system_pinmux_pin_set_config+0x16>
		return &(ports[port_index]->Group[group_index]);
    34d0:	0943      	lsrs	r3, r0, #5
    34d2:	01db      	lsls	r3, r3, #7
    34d4:	4905      	ldr	r1, [pc, #20]	; (34ec <system_pinmux_pin_set_config+0x28>)
    34d6:	468c      	mov	ip, r1
    34d8:	4463      	add	r3, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    34da:	241f      	movs	r4, #31
    34dc:	4020      	ands	r0, r4
    34de:	2101      	movs	r1, #1
    34e0:	4081      	lsls	r1, r0

	_system_pinmux_config(port, pin_mask, config);
    34e2:	0018      	movs	r0, r3
    34e4:	4b02      	ldr	r3, [pc, #8]	; (34f0 <system_pinmux_pin_set_config+0x2c>)
    34e6:	4798      	blx	r3
}
    34e8:	bd10      	pop	{r4, pc}
    34ea:	46c0      	nop			; (mov r8, r8)
    34ec:	41004400 	.word	0x41004400
    34f0:	0000341d 	.word	0x0000341d

000034f4 <system_pinmux_group_set_output_strength>:
 */
void system_pinmux_group_set_output_strength(
		PortGroup *const port,
		const uint32_t mask,
		const enum system_pinmux_pin_strength mode)
{
    34f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    34f6:	46c6      	mov	lr, r8
    34f8:	b500      	push	{lr}
	Assert(port);

	for (int i = 0; i < 32; i++) {
    34fa:	2300      	movs	r3, #0
		if (mask & (1UL << i)) {
    34fc:	2601      	movs	r6, #1
			if (mode == SYSTEM_PINMUX_PIN_STRENGTH_HIGH) {
				port->PINCFG[i].reg |=  PORT_PINCFG_DRVSTR;
			} else {
				port->PINCFG[i].reg &= ~PORT_PINCFG_DRVSTR;
    34fe:	2440      	movs	r4, #64	; 0x40
    3500:	46a0      	mov	r8, r4
				port->PINCFG[i].reg |=  PORT_PINCFG_DRVSTR;
    3502:	46a4      	mov	ip, r4
    3504:	e009      	b.n	351a <system_pinmux_group_set_output_strength+0x26>
    3506:	18c5      	adds	r5, r0, r3
    3508:	3540      	adds	r5, #64	; 0x40
    350a:	782c      	ldrb	r4, [r5, #0]
    350c:	4667      	mov	r7, ip
    350e:	433c      	orrs	r4, r7
    3510:	b2e4      	uxtb	r4, r4
    3512:	702c      	strb	r4, [r5, #0]
	for (int i = 0; i < 32; i++) {
    3514:	3301      	adds	r3, #1
    3516:	2b20      	cmp	r3, #32
    3518:	d00c      	beq.n	3534 <system_pinmux_group_set_output_strength+0x40>
		if (mask & (1UL << i)) {
    351a:	000c      	movs	r4, r1
    351c:	40dc      	lsrs	r4, r3
    351e:	4226      	tst	r6, r4
    3520:	d0f8      	beq.n	3514 <system_pinmux_group_set_output_strength+0x20>
			if (mode == SYSTEM_PINMUX_PIN_STRENGTH_HIGH) {
    3522:	2a01      	cmp	r2, #1
    3524:	d0ef      	beq.n	3506 <system_pinmux_group_set_output_strength+0x12>
				port->PINCFG[i].reg &= ~PORT_PINCFG_DRVSTR;
    3526:	18c4      	adds	r4, r0, r3
    3528:	3440      	adds	r4, #64	; 0x40
    352a:	7825      	ldrb	r5, [r4, #0]
    352c:	4647      	mov	r7, r8
    352e:	43bd      	bics	r5, r7
    3530:	7025      	strb	r5, [r4, #0]
    3532:	e7ef      	b.n	3514 <system_pinmux_group_set_output_strength+0x20>
			}
		}
	}
}
    3534:	bc04      	pop	{r2}
    3536:	4690      	mov	r8, r2
    3538:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000353a <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    353a:	4770      	bx	lr

0000353c <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    353c:	b510      	push	{r4, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    353e:	4b05      	ldr	r3, [pc, #20]	; (3554 <system_init+0x18>)
    3540:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    3542:	4b05      	ldr	r3, [pc, #20]	; (3558 <system_init+0x1c>)
    3544:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    3546:	4b05      	ldr	r3, [pc, #20]	; (355c <system_init+0x20>)
    3548:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    354a:	4b05      	ldr	r3, [pc, #20]	; (3560 <system_init+0x24>)
    354c:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    354e:	4b05      	ldr	r3, [pc, #20]	; (3564 <system_init+0x28>)
    3550:	4798      	blx	r3
}
    3552:	bd10      	pop	{r4, pc}
    3554:	000030fd 	.word	0x000030fd
    3558:	00002f15 	.word	0x00002f15
    355c:	0000353b 	.word	0x0000353b
    3560:	00001725 	.word	0x00001725
    3564:	0000353b 	.word	0x0000353b

00003568 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    3568:	e7fe      	b.n	3568 <Dummy_Handler>
	...

0000356c <Reset_Handler>:
void Reset_Handler(void){
    356c:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
    356e:	4a26      	ldr	r2, [pc, #152]	; (3608 <Reset_Handler+0x9c>)
    3570:	4b26      	ldr	r3, [pc, #152]	; (360c <Reset_Handler+0xa0>)
    3572:	429a      	cmp	r2, r3
    3574:	d011      	beq.n	359a <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
    3576:	001a      	movs	r2, r3
    3578:	4b25      	ldr	r3, [pc, #148]	; (3610 <Reset_Handler+0xa4>)
    357a:	429a      	cmp	r2, r3
    357c:	d20d      	bcs.n	359a <Reset_Handler+0x2e>
    357e:	4a25      	ldr	r2, [pc, #148]	; (3614 <Reset_Handler+0xa8>)
    3580:	3303      	adds	r3, #3
    3582:	1a9b      	subs	r3, r3, r2
    3584:	089b      	lsrs	r3, r3, #2
    3586:	3301      	adds	r3, #1
    3588:	009b      	lsls	r3, r3, #2
    358a:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    358c:	481f      	ldr	r0, [pc, #124]	; (360c <Reset_Handler+0xa0>)
    358e:	491e      	ldr	r1, [pc, #120]	; (3608 <Reset_Handler+0x9c>)
    3590:	588c      	ldr	r4, [r1, r2]
    3592:	5084      	str	r4, [r0, r2]
    3594:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
    3596:	429a      	cmp	r2, r3
    3598:	d1fa      	bne.n	3590 <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
    359a:	4a1f      	ldr	r2, [pc, #124]	; (3618 <Reset_Handler+0xac>)
    359c:	4b1f      	ldr	r3, [pc, #124]	; (361c <Reset_Handler+0xb0>)
    359e:	429a      	cmp	r2, r3
    35a0:	d20a      	bcs.n	35b8 <Reset_Handler+0x4c>
    35a2:	43d3      	mvns	r3, r2
    35a4:	491d      	ldr	r1, [pc, #116]	; (361c <Reset_Handler+0xb0>)
    35a6:	185b      	adds	r3, r3, r1
    35a8:	2103      	movs	r1, #3
    35aa:	438b      	bics	r3, r1
    35ac:	3304      	adds	r3, #4
    35ae:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
    35b0:	2100      	movs	r1, #0
    35b2:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
    35b4:	4293      	cmp	r3, r2
    35b6:	d1fc      	bne.n	35b2 <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    35b8:	4a19      	ldr	r2, [pc, #100]	; (3620 <Reset_Handler+0xb4>)
    35ba:	21ff      	movs	r1, #255	; 0xff
    35bc:	4b19      	ldr	r3, [pc, #100]	; (3624 <Reset_Handler+0xb8>)
    35be:	438b      	bics	r3, r1
    35c0:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    35c2:	39fd      	subs	r1, #253	; 0xfd
    35c4:	2390      	movs	r3, #144	; 0x90
    35c6:	005b      	lsls	r3, r3, #1
    35c8:	4a17      	ldr	r2, [pc, #92]	; (3628 <Reset_Handler+0xbc>)
    35ca:	50d1      	str	r1, [r2, r3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    35cc:	4b17      	ldr	r3, [pc, #92]	; (362c <Reset_Handler+0xc0>)
    35ce:	7b9a      	ldrb	r2, [r3, #14]
    35d0:	312e      	adds	r1, #46	; 0x2e
    35d2:	438a      	bics	r2, r1
    35d4:	2120      	movs	r1, #32
    35d6:	430a      	orrs	r2, r1
    35d8:	739a      	strb	r2, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    35da:	7b9a      	ldrb	r2, [r3, #14]
    35dc:	210c      	movs	r1, #12
    35de:	438a      	bics	r2, r1
    35e0:	2108      	movs	r1, #8
    35e2:	430a      	orrs	r2, r1
    35e4:	739a      	strb	r2, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    35e6:	7b9a      	ldrb	r2, [r3, #14]
    35e8:	2103      	movs	r1, #3
    35ea:	438a      	bics	r2, r1
    35ec:	2102      	movs	r1, #2
    35ee:	430a      	orrs	r2, r1
    35f0:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
    35f2:	4a0f      	ldr	r2, [pc, #60]	; (3630 <Reset_Handler+0xc4>)
    35f4:	6853      	ldr	r3, [r2, #4]
    35f6:	2180      	movs	r1, #128	; 0x80
    35f8:	430b      	orrs	r3, r1
    35fa:	6053      	str	r3, [r2, #4]
        __libc_init_array();
    35fc:	4b0d      	ldr	r3, [pc, #52]	; (3634 <Reset_Handler+0xc8>)
    35fe:	4798      	blx	r3
        main();
    3600:	4b0d      	ldr	r3, [pc, #52]	; (3638 <Reset_Handler+0xcc>)
    3602:	4798      	blx	r3
    3604:	e7fe      	b.n	3604 <Reset_Handler+0x98>
    3606:	46c0      	nop			; (mov r8, r8)
    3608:	00003d08 	.word	0x00003d08
    360c:	20000000 	.word	0x20000000
    3610:	20000074 	.word	0x20000074
    3614:	20000004 	.word	0x20000004
    3618:	20000074 	.word	0x20000074
    361c:	20000358 	.word	0x20000358
    3620:	e000ed00 	.word	0xe000ed00
    3624:	00000800 	.word	0x00000800
    3628:	41007000 	.word	0x41007000
    362c:	41004800 	.word	0x41004800
    3630:	41004000 	.word	0x41004000
    3634:	000039a1 	.word	0x000039a1
    3638:	00003661 	.word	0x00003661

0000363c <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    363c:	0003      	movs	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    363e:	4a06      	ldr	r2, [pc, #24]	; (3658 <_sbrk+0x1c>)
    3640:	6812      	ldr	r2, [r2, #0]
    3642:	2a00      	cmp	r2, #0
    3644:	d004      	beq.n	3650 <_sbrk+0x14>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
    3646:	4a04      	ldr	r2, [pc, #16]	; (3658 <_sbrk+0x1c>)
    3648:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    364a:	18c3      	adds	r3, r0, r3
    364c:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
}
    364e:	4770      	bx	lr
		heap = (unsigned char *)&_end;
    3650:	4902      	ldr	r1, [pc, #8]	; (365c <_sbrk+0x20>)
    3652:	4a01      	ldr	r2, [pc, #4]	; (3658 <_sbrk+0x1c>)
    3654:	6011      	str	r1, [r2, #0]
    3656:	e7f6      	b.n	3646 <_sbrk+0xa>
    3658:	200000ec 	.word	0x200000ec
    365c:	20000758 	.word	0x20000758

00003660 <main>:
	read_all_sensors();
}


int main (void)
{
    3660:	b570      	push	{r4, r5, r6, lr}
	//Clock , external interrupts initialization
	system_init();
    3662:	4b0a      	ldr	r3, [pc, #40]	; (368c <main+0x2c>)
    3664:	4798      	blx	r3
	delay_init();
    3666:	4b0a      	ldr	r3, [pc, #40]	; (3690 <main+0x30>)
    3668:	4798      	blx	r3
	//RGB , LED1, LED4 initialization
	ORB_init();
    366a:	4b0a      	ldr	r3, [pc, #40]	; (3694 <main+0x34>)
    366c:	4798      	blx	r3
	//ADC initialization
	sensor_init();
    366e:	4b0a      	ldr	r3, [pc, #40]	; (3698 <main+0x38>)
    3670:	4798      	blx	r3
	//Servo port TCC module initialization
	super_servo_init();
    3672:	4b0a      	ldr	r3, [pc, #40]	; (369c <main+0x3c>)
    3674:	4798      	blx	r3
	//Starting the interrupts for TCC module
	enable_super_servo();
    3676:	4b0a      	ldr	r3, [pc, #40]	; (36a0 <main+0x40>)
    3678:	4798      	blx	r3
	//Starting the interrupts for TC module
	enable_ORB();
    367a:	4b0a      	ldr	r3, [pc, #40]	; (36a4 <main+0x44>)
    367c:	4798      	blx	r3
	//SPI module initialization as slave
	spi_slave_init();
    367e:	4b0a      	ldr	r3, [pc, #40]	; (36a8 <main+0x48>)
    3680:	4798      	blx	r3
	read_all_sensors();
    3682:	4d0a      	ldr	r5, [pc, #40]	; (36ac <main+0x4c>)
	
	while(1)
	{
		sensor_check();
		spi_main_loop();    // Interprets command and assigns it to the right function 
    3684:	4c0a      	ldr	r4, [pc, #40]	; (36b0 <main+0x50>)
	read_all_sensors();
    3686:	47a8      	blx	r5
		spi_main_loop();    // Interprets command and assigns it to the right function 
    3688:	47a0      	blx	r4
    368a:	e7fc      	b.n	3686 <main+0x26>
    368c:	0000353d 	.word	0x0000353d
    3690:	0000119d 	.word	0x0000119d
    3694:	00002ef1 	.word	0x00002ef1
    3698:	00001ce9 	.word	0x00001ce9
    369c:	00001da5 	.word	0x00001da5
    36a0:	00001cf5 	.word	0x00001cf5
    36a4:	00002e29 	.word	0x00002e29
    36a8:	00001085 	.word	0x00001085
    36ac:	00001ac9 	.word	0x00001ac9
    36b0:	00000dd5 	.word	0x00000dd5

000036b4 <__udivsi3>:
    36b4:	2200      	movs	r2, #0
    36b6:	0843      	lsrs	r3, r0, #1
    36b8:	428b      	cmp	r3, r1
    36ba:	d374      	bcc.n	37a6 <__udivsi3+0xf2>
    36bc:	0903      	lsrs	r3, r0, #4
    36be:	428b      	cmp	r3, r1
    36c0:	d35f      	bcc.n	3782 <__udivsi3+0xce>
    36c2:	0a03      	lsrs	r3, r0, #8
    36c4:	428b      	cmp	r3, r1
    36c6:	d344      	bcc.n	3752 <__udivsi3+0x9e>
    36c8:	0b03      	lsrs	r3, r0, #12
    36ca:	428b      	cmp	r3, r1
    36cc:	d328      	bcc.n	3720 <__udivsi3+0x6c>
    36ce:	0c03      	lsrs	r3, r0, #16
    36d0:	428b      	cmp	r3, r1
    36d2:	d30d      	bcc.n	36f0 <__udivsi3+0x3c>
    36d4:	22ff      	movs	r2, #255	; 0xff
    36d6:	0209      	lsls	r1, r1, #8
    36d8:	ba12      	rev	r2, r2
    36da:	0c03      	lsrs	r3, r0, #16
    36dc:	428b      	cmp	r3, r1
    36de:	d302      	bcc.n	36e6 <__udivsi3+0x32>
    36e0:	1212      	asrs	r2, r2, #8
    36e2:	0209      	lsls	r1, r1, #8
    36e4:	d065      	beq.n	37b2 <__udivsi3+0xfe>
    36e6:	0b03      	lsrs	r3, r0, #12
    36e8:	428b      	cmp	r3, r1
    36ea:	d319      	bcc.n	3720 <__udivsi3+0x6c>
    36ec:	e000      	b.n	36f0 <__udivsi3+0x3c>
    36ee:	0a09      	lsrs	r1, r1, #8
    36f0:	0bc3      	lsrs	r3, r0, #15
    36f2:	428b      	cmp	r3, r1
    36f4:	d301      	bcc.n	36fa <__udivsi3+0x46>
    36f6:	03cb      	lsls	r3, r1, #15
    36f8:	1ac0      	subs	r0, r0, r3
    36fa:	4152      	adcs	r2, r2
    36fc:	0b83      	lsrs	r3, r0, #14
    36fe:	428b      	cmp	r3, r1
    3700:	d301      	bcc.n	3706 <__udivsi3+0x52>
    3702:	038b      	lsls	r3, r1, #14
    3704:	1ac0      	subs	r0, r0, r3
    3706:	4152      	adcs	r2, r2
    3708:	0b43      	lsrs	r3, r0, #13
    370a:	428b      	cmp	r3, r1
    370c:	d301      	bcc.n	3712 <__udivsi3+0x5e>
    370e:	034b      	lsls	r3, r1, #13
    3710:	1ac0      	subs	r0, r0, r3
    3712:	4152      	adcs	r2, r2
    3714:	0b03      	lsrs	r3, r0, #12
    3716:	428b      	cmp	r3, r1
    3718:	d301      	bcc.n	371e <__udivsi3+0x6a>
    371a:	030b      	lsls	r3, r1, #12
    371c:	1ac0      	subs	r0, r0, r3
    371e:	4152      	adcs	r2, r2
    3720:	0ac3      	lsrs	r3, r0, #11
    3722:	428b      	cmp	r3, r1
    3724:	d301      	bcc.n	372a <__udivsi3+0x76>
    3726:	02cb      	lsls	r3, r1, #11
    3728:	1ac0      	subs	r0, r0, r3
    372a:	4152      	adcs	r2, r2
    372c:	0a83      	lsrs	r3, r0, #10
    372e:	428b      	cmp	r3, r1
    3730:	d301      	bcc.n	3736 <__udivsi3+0x82>
    3732:	028b      	lsls	r3, r1, #10
    3734:	1ac0      	subs	r0, r0, r3
    3736:	4152      	adcs	r2, r2
    3738:	0a43      	lsrs	r3, r0, #9
    373a:	428b      	cmp	r3, r1
    373c:	d301      	bcc.n	3742 <__udivsi3+0x8e>
    373e:	024b      	lsls	r3, r1, #9
    3740:	1ac0      	subs	r0, r0, r3
    3742:	4152      	adcs	r2, r2
    3744:	0a03      	lsrs	r3, r0, #8
    3746:	428b      	cmp	r3, r1
    3748:	d301      	bcc.n	374e <__udivsi3+0x9a>
    374a:	020b      	lsls	r3, r1, #8
    374c:	1ac0      	subs	r0, r0, r3
    374e:	4152      	adcs	r2, r2
    3750:	d2cd      	bcs.n	36ee <__udivsi3+0x3a>
    3752:	09c3      	lsrs	r3, r0, #7
    3754:	428b      	cmp	r3, r1
    3756:	d301      	bcc.n	375c <__udivsi3+0xa8>
    3758:	01cb      	lsls	r3, r1, #7
    375a:	1ac0      	subs	r0, r0, r3
    375c:	4152      	adcs	r2, r2
    375e:	0983      	lsrs	r3, r0, #6
    3760:	428b      	cmp	r3, r1
    3762:	d301      	bcc.n	3768 <__udivsi3+0xb4>
    3764:	018b      	lsls	r3, r1, #6
    3766:	1ac0      	subs	r0, r0, r3
    3768:	4152      	adcs	r2, r2
    376a:	0943      	lsrs	r3, r0, #5
    376c:	428b      	cmp	r3, r1
    376e:	d301      	bcc.n	3774 <__udivsi3+0xc0>
    3770:	014b      	lsls	r3, r1, #5
    3772:	1ac0      	subs	r0, r0, r3
    3774:	4152      	adcs	r2, r2
    3776:	0903      	lsrs	r3, r0, #4
    3778:	428b      	cmp	r3, r1
    377a:	d301      	bcc.n	3780 <__udivsi3+0xcc>
    377c:	010b      	lsls	r3, r1, #4
    377e:	1ac0      	subs	r0, r0, r3
    3780:	4152      	adcs	r2, r2
    3782:	08c3      	lsrs	r3, r0, #3
    3784:	428b      	cmp	r3, r1
    3786:	d301      	bcc.n	378c <__udivsi3+0xd8>
    3788:	00cb      	lsls	r3, r1, #3
    378a:	1ac0      	subs	r0, r0, r3
    378c:	4152      	adcs	r2, r2
    378e:	0883      	lsrs	r3, r0, #2
    3790:	428b      	cmp	r3, r1
    3792:	d301      	bcc.n	3798 <__udivsi3+0xe4>
    3794:	008b      	lsls	r3, r1, #2
    3796:	1ac0      	subs	r0, r0, r3
    3798:	4152      	adcs	r2, r2
    379a:	0843      	lsrs	r3, r0, #1
    379c:	428b      	cmp	r3, r1
    379e:	d301      	bcc.n	37a4 <__udivsi3+0xf0>
    37a0:	004b      	lsls	r3, r1, #1
    37a2:	1ac0      	subs	r0, r0, r3
    37a4:	4152      	adcs	r2, r2
    37a6:	1a41      	subs	r1, r0, r1
    37a8:	d200      	bcs.n	37ac <__udivsi3+0xf8>
    37aa:	4601      	mov	r1, r0
    37ac:	4152      	adcs	r2, r2
    37ae:	4610      	mov	r0, r2
    37b0:	4770      	bx	lr
    37b2:	e7ff      	b.n	37b4 <__udivsi3+0x100>
    37b4:	b501      	push	{r0, lr}
    37b6:	2000      	movs	r0, #0
    37b8:	f000 f8f0 	bl	399c <__aeabi_idiv0>
    37bc:	bd02      	pop	{r1, pc}
    37be:	46c0      	nop			; (mov r8, r8)

000037c0 <__aeabi_uidivmod>:
    37c0:	2900      	cmp	r1, #0
    37c2:	d0f7      	beq.n	37b4 <__udivsi3+0x100>
    37c4:	e776      	b.n	36b4 <__udivsi3>
    37c6:	4770      	bx	lr

000037c8 <__divsi3>:
    37c8:	4603      	mov	r3, r0
    37ca:	430b      	orrs	r3, r1
    37cc:	d47f      	bmi.n	38ce <__divsi3+0x106>
    37ce:	2200      	movs	r2, #0
    37d0:	0843      	lsrs	r3, r0, #1
    37d2:	428b      	cmp	r3, r1
    37d4:	d374      	bcc.n	38c0 <__divsi3+0xf8>
    37d6:	0903      	lsrs	r3, r0, #4
    37d8:	428b      	cmp	r3, r1
    37da:	d35f      	bcc.n	389c <__divsi3+0xd4>
    37dc:	0a03      	lsrs	r3, r0, #8
    37de:	428b      	cmp	r3, r1
    37e0:	d344      	bcc.n	386c <__divsi3+0xa4>
    37e2:	0b03      	lsrs	r3, r0, #12
    37e4:	428b      	cmp	r3, r1
    37e6:	d328      	bcc.n	383a <__divsi3+0x72>
    37e8:	0c03      	lsrs	r3, r0, #16
    37ea:	428b      	cmp	r3, r1
    37ec:	d30d      	bcc.n	380a <__divsi3+0x42>
    37ee:	22ff      	movs	r2, #255	; 0xff
    37f0:	0209      	lsls	r1, r1, #8
    37f2:	ba12      	rev	r2, r2
    37f4:	0c03      	lsrs	r3, r0, #16
    37f6:	428b      	cmp	r3, r1
    37f8:	d302      	bcc.n	3800 <__divsi3+0x38>
    37fa:	1212      	asrs	r2, r2, #8
    37fc:	0209      	lsls	r1, r1, #8
    37fe:	d065      	beq.n	38cc <__divsi3+0x104>
    3800:	0b03      	lsrs	r3, r0, #12
    3802:	428b      	cmp	r3, r1
    3804:	d319      	bcc.n	383a <__divsi3+0x72>
    3806:	e000      	b.n	380a <__divsi3+0x42>
    3808:	0a09      	lsrs	r1, r1, #8
    380a:	0bc3      	lsrs	r3, r0, #15
    380c:	428b      	cmp	r3, r1
    380e:	d301      	bcc.n	3814 <__divsi3+0x4c>
    3810:	03cb      	lsls	r3, r1, #15
    3812:	1ac0      	subs	r0, r0, r3
    3814:	4152      	adcs	r2, r2
    3816:	0b83      	lsrs	r3, r0, #14
    3818:	428b      	cmp	r3, r1
    381a:	d301      	bcc.n	3820 <__divsi3+0x58>
    381c:	038b      	lsls	r3, r1, #14
    381e:	1ac0      	subs	r0, r0, r3
    3820:	4152      	adcs	r2, r2
    3822:	0b43      	lsrs	r3, r0, #13
    3824:	428b      	cmp	r3, r1
    3826:	d301      	bcc.n	382c <__divsi3+0x64>
    3828:	034b      	lsls	r3, r1, #13
    382a:	1ac0      	subs	r0, r0, r3
    382c:	4152      	adcs	r2, r2
    382e:	0b03      	lsrs	r3, r0, #12
    3830:	428b      	cmp	r3, r1
    3832:	d301      	bcc.n	3838 <__divsi3+0x70>
    3834:	030b      	lsls	r3, r1, #12
    3836:	1ac0      	subs	r0, r0, r3
    3838:	4152      	adcs	r2, r2
    383a:	0ac3      	lsrs	r3, r0, #11
    383c:	428b      	cmp	r3, r1
    383e:	d301      	bcc.n	3844 <__divsi3+0x7c>
    3840:	02cb      	lsls	r3, r1, #11
    3842:	1ac0      	subs	r0, r0, r3
    3844:	4152      	adcs	r2, r2
    3846:	0a83      	lsrs	r3, r0, #10
    3848:	428b      	cmp	r3, r1
    384a:	d301      	bcc.n	3850 <__divsi3+0x88>
    384c:	028b      	lsls	r3, r1, #10
    384e:	1ac0      	subs	r0, r0, r3
    3850:	4152      	adcs	r2, r2
    3852:	0a43      	lsrs	r3, r0, #9
    3854:	428b      	cmp	r3, r1
    3856:	d301      	bcc.n	385c <__divsi3+0x94>
    3858:	024b      	lsls	r3, r1, #9
    385a:	1ac0      	subs	r0, r0, r3
    385c:	4152      	adcs	r2, r2
    385e:	0a03      	lsrs	r3, r0, #8
    3860:	428b      	cmp	r3, r1
    3862:	d301      	bcc.n	3868 <__divsi3+0xa0>
    3864:	020b      	lsls	r3, r1, #8
    3866:	1ac0      	subs	r0, r0, r3
    3868:	4152      	adcs	r2, r2
    386a:	d2cd      	bcs.n	3808 <__divsi3+0x40>
    386c:	09c3      	lsrs	r3, r0, #7
    386e:	428b      	cmp	r3, r1
    3870:	d301      	bcc.n	3876 <__divsi3+0xae>
    3872:	01cb      	lsls	r3, r1, #7
    3874:	1ac0      	subs	r0, r0, r3
    3876:	4152      	adcs	r2, r2
    3878:	0983      	lsrs	r3, r0, #6
    387a:	428b      	cmp	r3, r1
    387c:	d301      	bcc.n	3882 <__divsi3+0xba>
    387e:	018b      	lsls	r3, r1, #6
    3880:	1ac0      	subs	r0, r0, r3
    3882:	4152      	adcs	r2, r2
    3884:	0943      	lsrs	r3, r0, #5
    3886:	428b      	cmp	r3, r1
    3888:	d301      	bcc.n	388e <__divsi3+0xc6>
    388a:	014b      	lsls	r3, r1, #5
    388c:	1ac0      	subs	r0, r0, r3
    388e:	4152      	adcs	r2, r2
    3890:	0903      	lsrs	r3, r0, #4
    3892:	428b      	cmp	r3, r1
    3894:	d301      	bcc.n	389a <__divsi3+0xd2>
    3896:	010b      	lsls	r3, r1, #4
    3898:	1ac0      	subs	r0, r0, r3
    389a:	4152      	adcs	r2, r2
    389c:	08c3      	lsrs	r3, r0, #3
    389e:	428b      	cmp	r3, r1
    38a0:	d301      	bcc.n	38a6 <__divsi3+0xde>
    38a2:	00cb      	lsls	r3, r1, #3
    38a4:	1ac0      	subs	r0, r0, r3
    38a6:	4152      	adcs	r2, r2
    38a8:	0883      	lsrs	r3, r0, #2
    38aa:	428b      	cmp	r3, r1
    38ac:	d301      	bcc.n	38b2 <__divsi3+0xea>
    38ae:	008b      	lsls	r3, r1, #2
    38b0:	1ac0      	subs	r0, r0, r3
    38b2:	4152      	adcs	r2, r2
    38b4:	0843      	lsrs	r3, r0, #1
    38b6:	428b      	cmp	r3, r1
    38b8:	d301      	bcc.n	38be <__divsi3+0xf6>
    38ba:	004b      	lsls	r3, r1, #1
    38bc:	1ac0      	subs	r0, r0, r3
    38be:	4152      	adcs	r2, r2
    38c0:	1a41      	subs	r1, r0, r1
    38c2:	d200      	bcs.n	38c6 <__divsi3+0xfe>
    38c4:	4601      	mov	r1, r0
    38c6:	4152      	adcs	r2, r2
    38c8:	4610      	mov	r0, r2
    38ca:	4770      	bx	lr
    38cc:	e05d      	b.n	398a <__divsi3+0x1c2>
    38ce:	0fca      	lsrs	r2, r1, #31
    38d0:	d000      	beq.n	38d4 <__divsi3+0x10c>
    38d2:	4249      	negs	r1, r1
    38d4:	1003      	asrs	r3, r0, #32
    38d6:	d300      	bcc.n	38da <__divsi3+0x112>
    38d8:	4240      	negs	r0, r0
    38da:	4053      	eors	r3, r2
    38dc:	2200      	movs	r2, #0
    38de:	469c      	mov	ip, r3
    38e0:	0903      	lsrs	r3, r0, #4
    38e2:	428b      	cmp	r3, r1
    38e4:	d32d      	bcc.n	3942 <__divsi3+0x17a>
    38e6:	0a03      	lsrs	r3, r0, #8
    38e8:	428b      	cmp	r3, r1
    38ea:	d312      	bcc.n	3912 <__divsi3+0x14a>
    38ec:	22fc      	movs	r2, #252	; 0xfc
    38ee:	0189      	lsls	r1, r1, #6
    38f0:	ba12      	rev	r2, r2
    38f2:	0a03      	lsrs	r3, r0, #8
    38f4:	428b      	cmp	r3, r1
    38f6:	d30c      	bcc.n	3912 <__divsi3+0x14a>
    38f8:	0189      	lsls	r1, r1, #6
    38fa:	1192      	asrs	r2, r2, #6
    38fc:	428b      	cmp	r3, r1
    38fe:	d308      	bcc.n	3912 <__divsi3+0x14a>
    3900:	0189      	lsls	r1, r1, #6
    3902:	1192      	asrs	r2, r2, #6
    3904:	428b      	cmp	r3, r1
    3906:	d304      	bcc.n	3912 <__divsi3+0x14a>
    3908:	0189      	lsls	r1, r1, #6
    390a:	d03a      	beq.n	3982 <__divsi3+0x1ba>
    390c:	1192      	asrs	r2, r2, #6
    390e:	e000      	b.n	3912 <__divsi3+0x14a>
    3910:	0989      	lsrs	r1, r1, #6
    3912:	09c3      	lsrs	r3, r0, #7
    3914:	428b      	cmp	r3, r1
    3916:	d301      	bcc.n	391c <__divsi3+0x154>
    3918:	01cb      	lsls	r3, r1, #7
    391a:	1ac0      	subs	r0, r0, r3
    391c:	4152      	adcs	r2, r2
    391e:	0983      	lsrs	r3, r0, #6
    3920:	428b      	cmp	r3, r1
    3922:	d301      	bcc.n	3928 <__divsi3+0x160>
    3924:	018b      	lsls	r3, r1, #6
    3926:	1ac0      	subs	r0, r0, r3
    3928:	4152      	adcs	r2, r2
    392a:	0943      	lsrs	r3, r0, #5
    392c:	428b      	cmp	r3, r1
    392e:	d301      	bcc.n	3934 <__divsi3+0x16c>
    3930:	014b      	lsls	r3, r1, #5
    3932:	1ac0      	subs	r0, r0, r3
    3934:	4152      	adcs	r2, r2
    3936:	0903      	lsrs	r3, r0, #4
    3938:	428b      	cmp	r3, r1
    393a:	d301      	bcc.n	3940 <__divsi3+0x178>
    393c:	010b      	lsls	r3, r1, #4
    393e:	1ac0      	subs	r0, r0, r3
    3940:	4152      	adcs	r2, r2
    3942:	08c3      	lsrs	r3, r0, #3
    3944:	428b      	cmp	r3, r1
    3946:	d301      	bcc.n	394c <__divsi3+0x184>
    3948:	00cb      	lsls	r3, r1, #3
    394a:	1ac0      	subs	r0, r0, r3
    394c:	4152      	adcs	r2, r2
    394e:	0883      	lsrs	r3, r0, #2
    3950:	428b      	cmp	r3, r1
    3952:	d301      	bcc.n	3958 <__divsi3+0x190>
    3954:	008b      	lsls	r3, r1, #2
    3956:	1ac0      	subs	r0, r0, r3
    3958:	4152      	adcs	r2, r2
    395a:	d2d9      	bcs.n	3910 <__divsi3+0x148>
    395c:	0843      	lsrs	r3, r0, #1
    395e:	428b      	cmp	r3, r1
    3960:	d301      	bcc.n	3966 <__divsi3+0x19e>
    3962:	004b      	lsls	r3, r1, #1
    3964:	1ac0      	subs	r0, r0, r3
    3966:	4152      	adcs	r2, r2
    3968:	1a41      	subs	r1, r0, r1
    396a:	d200      	bcs.n	396e <__divsi3+0x1a6>
    396c:	4601      	mov	r1, r0
    396e:	4663      	mov	r3, ip
    3970:	4152      	adcs	r2, r2
    3972:	105b      	asrs	r3, r3, #1
    3974:	4610      	mov	r0, r2
    3976:	d301      	bcc.n	397c <__divsi3+0x1b4>
    3978:	4240      	negs	r0, r0
    397a:	2b00      	cmp	r3, #0
    397c:	d500      	bpl.n	3980 <__divsi3+0x1b8>
    397e:	4249      	negs	r1, r1
    3980:	4770      	bx	lr
    3982:	4663      	mov	r3, ip
    3984:	105b      	asrs	r3, r3, #1
    3986:	d300      	bcc.n	398a <__divsi3+0x1c2>
    3988:	4240      	negs	r0, r0
    398a:	b501      	push	{r0, lr}
    398c:	2000      	movs	r0, #0
    398e:	f000 f805 	bl	399c <__aeabi_idiv0>
    3992:	bd02      	pop	{r1, pc}

00003994 <__aeabi_idivmod>:
    3994:	2900      	cmp	r1, #0
    3996:	d0f8      	beq.n	398a <__divsi3+0x1c2>
    3998:	e716      	b.n	37c8 <__divsi3>
    399a:	4770      	bx	lr

0000399c <__aeabi_idiv0>:
    399c:	4770      	bx	lr
    399e:	46c0      	nop			; (mov r8, r8)

000039a0 <__libc_init_array>:
    39a0:	b570      	push	{r4, r5, r6, lr}
    39a2:	2600      	movs	r6, #0
    39a4:	4d0c      	ldr	r5, [pc, #48]	; (39d8 <__libc_init_array+0x38>)
    39a6:	4c0d      	ldr	r4, [pc, #52]	; (39dc <__libc_init_array+0x3c>)
    39a8:	1b64      	subs	r4, r4, r5
    39aa:	10a4      	asrs	r4, r4, #2
    39ac:	42a6      	cmp	r6, r4
    39ae:	d109      	bne.n	39c4 <__libc_init_array+0x24>
    39b0:	2600      	movs	r6, #0
    39b2:	f000 f999 	bl	3ce8 <_init>
    39b6:	4d0a      	ldr	r5, [pc, #40]	; (39e0 <__libc_init_array+0x40>)
    39b8:	4c0a      	ldr	r4, [pc, #40]	; (39e4 <__libc_init_array+0x44>)
    39ba:	1b64      	subs	r4, r4, r5
    39bc:	10a4      	asrs	r4, r4, #2
    39be:	42a6      	cmp	r6, r4
    39c0:	d105      	bne.n	39ce <__libc_init_array+0x2e>
    39c2:	bd70      	pop	{r4, r5, r6, pc}
    39c4:	00b3      	lsls	r3, r6, #2
    39c6:	58eb      	ldr	r3, [r5, r3]
    39c8:	4798      	blx	r3
    39ca:	3601      	adds	r6, #1
    39cc:	e7ee      	b.n	39ac <__libc_init_array+0xc>
    39ce:	00b3      	lsls	r3, r6, #2
    39d0:	58eb      	ldr	r3, [r5, r3]
    39d2:	4798      	blx	r3
    39d4:	3601      	adds	r6, #1
    39d6:	e7f2      	b.n	39be <__libc_init_array+0x1e>
    39d8:	00003cf4 	.word	0x00003cf4
    39dc:	00003cf4 	.word	0x00003cf4
    39e0:	00003cf4 	.word	0x00003cf4
    39e4:	00003cf8 	.word	0x00003cf8

000039e8 <malloc>:
    39e8:	b510      	push	{r4, lr}
    39ea:	4b03      	ldr	r3, [pc, #12]	; (39f8 <malloc+0x10>)
    39ec:	0001      	movs	r1, r0
    39ee:	6818      	ldr	r0, [r3, #0]
    39f0:	f000 f816 	bl	3a20 <_malloc_r>
    39f4:	bd10      	pop	{r4, pc}
    39f6:	46c0      	nop			; (mov r8, r8)
    39f8:	20000010 	.word	0x20000010

000039fc <memcpy>:
    39fc:	2300      	movs	r3, #0
    39fe:	b510      	push	{r4, lr}
    3a00:	429a      	cmp	r2, r3
    3a02:	d100      	bne.n	3a06 <memcpy+0xa>
    3a04:	bd10      	pop	{r4, pc}
    3a06:	5ccc      	ldrb	r4, [r1, r3]
    3a08:	54c4      	strb	r4, [r0, r3]
    3a0a:	3301      	adds	r3, #1
    3a0c:	e7f8      	b.n	3a00 <memcpy+0x4>

00003a0e <memset>:
    3a0e:	0003      	movs	r3, r0
    3a10:	1882      	adds	r2, r0, r2
    3a12:	4293      	cmp	r3, r2
    3a14:	d100      	bne.n	3a18 <memset+0xa>
    3a16:	4770      	bx	lr
    3a18:	7019      	strb	r1, [r3, #0]
    3a1a:	3301      	adds	r3, #1
    3a1c:	e7f9      	b.n	3a12 <memset+0x4>
	...

00003a20 <_malloc_r>:
    3a20:	2303      	movs	r3, #3
    3a22:	b570      	push	{r4, r5, r6, lr}
    3a24:	1ccd      	adds	r5, r1, #3
    3a26:	439d      	bics	r5, r3
    3a28:	3508      	adds	r5, #8
    3a2a:	0006      	movs	r6, r0
    3a2c:	2d0c      	cmp	r5, #12
    3a2e:	d21e      	bcs.n	3a6e <_malloc_r+0x4e>
    3a30:	250c      	movs	r5, #12
    3a32:	42a9      	cmp	r1, r5
    3a34:	d81d      	bhi.n	3a72 <_malloc_r+0x52>
    3a36:	0030      	movs	r0, r6
    3a38:	f000 f862 	bl	3b00 <__malloc_lock>
    3a3c:	4a25      	ldr	r2, [pc, #148]	; (3ad4 <_malloc_r+0xb4>)
    3a3e:	6814      	ldr	r4, [r2, #0]
    3a40:	0021      	movs	r1, r4
    3a42:	2900      	cmp	r1, #0
    3a44:	d119      	bne.n	3a7a <_malloc_r+0x5a>
    3a46:	4c24      	ldr	r4, [pc, #144]	; (3ad8 <_malloc_r+0xb8>)
    3a48:	6823      	ldr	r3, [r4, #0]
    3a4a:	2b00      	cmp	r3, #0
    3a4c:	d103      	bne.n	3a56 <_malloc_r+0x36>
    3a4e:	0030      	movs	r0, r6
    3a50:	f000 f844 	bl	3adc <_sbrk_r>
    3a54:	6020      	str	r0, [r4, #0]
    3a56:	0029      	movs	r1, r5
    3a58:	0030      	movs	r0, r6
    3a5a:	f000 f83f 	bl	3adc <_sbrk_r>
    3a5e:	1c43      	adds	r3, r0, #1
    3a60:	d12c      	bne.n	3abc <_malloc_r+0x9c>
    3a62:	230c      	movs	r3, #12
    3a64:	0030      	movs	r0, r6
    3a66:	6033      	str	r3, [r6, #0]
    3a68:	f000 f84b 	bl	3b02 <__malloc_unlock>
    3a6c:	e003      	b.n	3a76 <_malloc_r+0x56>
    3a6e:	2d00      	cmp	r5, #0
    3a70:	dadf      	bge.n	3a32 <_malloc_r+0x12>
    3a72:	230c      	movs	r3, #12
    3a74:	6033      	str	r3, [r6, #0]
    3a76:	2000      	movs	r0, #0
    3a78:	bd70      	pop	{r4, r5, r6, pc}
    3a7a:	680b      	ldr	r3, [r1, #0]
    3a7c:	1b5b      	subs	r3, r3, r5
    3a7e:	d41a      	bmi.n	3ab6 <_malloc_r+0x96>
    3a80:	2b0b      	cmp	r3, #11
    3a82:	d903      	bls.n	3a8c <_malloc_r+0x6c>
    3a84:	600b      	str	r3, [r1, #0]
    3a86:	18cc      	adds	r4, r1, r3
    3a88:	6025      	str	r5, [r4, #0]
    3a8a:	e003      	b.n	3a94 <_malloc_r+0x74>
    3a8c:	428c      	cmp	r4, r1
    3a8e:	d10e      	bne.n	3aae <_malloc_r+0x8e>
    3a90:	6863      	ldr	r3, [r4, #4]
    3a92:	6013      	str	r3, [r2, #0]
    3a94:	0030      	movs	r0, r6
    3a96:	f000 f834 	bl	3b02 <__malloc_unlock>
    3a9a:	0020      	movs	r0, r4
    3a9c:	2207      	movs	r2, #7
    3a9e:	300b      	adds	r0, #11
    3aa0:	1d23      	adds	r3, r4, #4
    3aa2:	4390      	bics	r0, r2
    3aa4:	1ac3      	subs	r3, r0, r3
    3aa6:	d0e7      	beq.n	3a78 <_malloc_r+0x58>
    3aa8:	425a      	negs	r2, r3
    3aaa:	50e2      	str	r2, [r4, r3]
    3aac:	e7e4      	b.n	3a78 <_malloc_r+0x58>
    3aae:	684b      	ldr	r3, [r1, #4]
    3ab0:	6063      	str	r3, [r4, #4]
    3ab2:	000c      	movs	r4, r1
    3ab4:	e7ee      	b.n	3a94 <_malloc_r+0x74>
    3ab6:	000c      	movs	r4, r1
    3ab8:	6849      	ldr	r1, [r1, #4]
    3aba:	e7c2      	b.n	3a42 <_malloc_r+0x22>
    3abc:	2303      	movs	r3, #3
    3abe:	1cc4      	adds	r4, r0, #3
    3ac0:	439c      	bics	r4, r3
    3ac2:	42a0      	cmp	r0, r4
    3ac4:	d0e0      	beq.n	3a88 <_malloc_r+0x68>
    3ac6:	1a21      	subs	r1, r4, r0
    3ac8:	0030      	movs	r0, r6
    3aca:	f000 f807 	bl	3adc <_sbrk_r>
    3ace:	1c43      	adds	r3, r0, #1
    3ad0:	d1da      	bne.n	3a88 <_malloc_r+0x68>
    3ad2:	e7c6      	b.n	3a62 <_malloc_r+0x42>
    3ad4:	200000fc 	.word	0x200000fc
    3ad8:	20000100 	.word	0x20000100

00003adc <_sbrk_r>:
    3adc:	2300      	movs	r3, #0
    3ade:	b570      	push	{r4, r5, r6, lr}
    3ae0:	4c06      	ldr	r4, [pc, #24]	; (3afc <_sbrk_r+0x20>)
    3ae2:	0005      	movs	r5, r0
    3ae4:	0008      	movs	r0, r1
    3ae6:	6023      	str	r3, [r4, #0]
    3ae8:	f7ff fda8 	bl	363c <_sbrk>
    3aec:	1c43      	adds	r3, r0, #1
    3aee:	d103      	bne.n	3af8 <_sbrk_r+0x1c>
    3af0:	6823      	ldr	r3, [r4, #0]
    3af2:	2b00      	cmp	r3, #0
    3af4:	d000      	beq.n	3af8 <_sbrk_r+0x1c>
    3af6:	602b      	str	r3, [r5, #0]
    3af8:	bd70      	pop	{r4, r5, r6, pc}
    3afa:	46c0      	nop			; (mov r8, r8)
    3afc:	20000354 	.word	0x20000354

00003b00 <__malloc_lock>:
    3b00:	4770      	bx	lr

00003b02 <__malloc_unlock>:
    3b02:	4770      	bx	lr
    3b04:	00000e30 	.word	0x00000e30
    3b08:	00000e12 	.word	0x00000e12
    3b0c:	00000e12 	.word	0x00000e12
    3b10:	00000e3e 	.word	0x00000e3e
    3b14:	00000e4c 	.word	0x00000e4c
    3b18:	00000e62 	.word	0x00000e62
    3b1c:	00000e78 	.word	0x00000e78
    3b20:	00000e86 	.word	0x00000e86
    3b24:	00000e94 	.word	0x00000e94
    3b28:	00000ea2 	.word	0x00000ea2
    3b2c:	00000eb0 	.word	0x00000eb0
    3b30:	00000ef0 	.word	0x00000ef0
    3b34:	000013ee 	.word	0x000013ee
    3b38:	0000163a 	.word	0x0000163a
    3b3c:	0000163a 	.word	0x0000163a
    3b40:	0000163a 	.word	0x0000163a
    3b44:	0000163a 	.word	0x0000163a
    3b48:	0000163a 	.word	0x0000163a
    3b4c:	0000163a 	.word	0x0000163a
    3b50:	0000163a 	.word	0x0000163a
    3b54:	0000163a 	.word	0x0000163a
    3b58:	0000163a 	.word	0x0000163a
    3b5c:	0000163a 	.word	0x0000163a
    3b60:	0000163a 	.word	0x0000163a
    3b64:	0000163a 	.word	0x0000163a
    3b68:	0000163a 	.word	0x0000163a
    3b6c:	0000163a 	.word	0x0000163a
    3b70:	0000163a 	.word	0x0000163a
    3b74:	000013d6 	.word	0x000013d6
    3b78:	0000163a 	.word	0x0000163a
    3b7c:	0000163a 	.word	0x0000163a
    3b80:	0000163a 	.word	0x0000163a
    3b84:	0000163a 	.word	0x0000163a
    3b88:	0000163a 	.word	0x0000163a
    3b8c:	0000163a 	.word	0x0000163a
    3b90:	0000163a 	.word	0x0000163a
    3b94:	0000163a 	.word	0x0000163a
    3b98:	0000163a 	.word	0x0000163a
    3b9c:	0000163a 	.word	0x0000163a
    3ba0:	0000163a 	.word	0x0000163a
    3ba4:	0000163a 	.word	0x0000163a
    3ba8:	0000163a 	.word	0x0000163a
    3bac:	0000163a 	.word	0x0000163a
    3bb0:	0000163a 	.word	0x0000163a
    3bb4:	000013e6 	.word	0x000013e6
    3bb8:	0000163a 	.word	0x0000163a
    3bbc:	0000163a 	.word	0x0000163a
    3bc0:	0000163a 	.word	0x0000163a
    3bc4:	0000163a 	.word	0x0000163a
    3bc8:	0000163a 	.word	0x0000163a
    3bcc:	0000163a 	.word	0x0000163a
    3bd0:	0000163a 	.word	0x0000163a
    3bd4:	0000163a 	.word	0x0000163a
    3bd8:	0000163a 	.word	0x0000163a
    3bdc:	0000163a 	.word	0x0000163a
    3be0:	0000163a 	.word	0x0000163a
    3be4:	0000163a 	.word	0x0000163a
    3be8:	0000163a 	.word	0x0000163a
    3bec:	0000163a 	.word	0x0000163a
    3bf0:	0000163a 	.word	0x0000163a
    3bf4:	000013de 	.word	0x000013de
    3bf8:	000013f6 	.word	0x000013f6
    3bfc:	000013be 	.word	0x000013be
    3c00:	000013ce 	.word	0x000013ce
    3c04:	000013c6 	.word	0x000013c6
    3c08:	00000002 	.word	0x00000002
    3c0c:	00000003 	.word	0x00000003
    3c10:	00000004 	.word	0x00000004
    3c14:	00000005 	.word	0x00000005
    3c18:	00000006 	.word	0x00000006
    3c1c:	00000007 	.word	0x00000007
    3c20:	0000000e 	.word	0x0000000e
    3c24:	0000000f 	.word	0x0000000f
    3c28:	0000000a 	.word	0x0000000a
    3c2c:	0000000b 	.word	0x0000000b
    3c30:	0000ffff 	.word	0x0000ffff
    3c34:	0000ffff 	.word	0x0000ffff
    3c38:	0000ffff 	.word	0x0000ffff
    3c3c:	0000ffff 	.word	0x0000ffff
    3c40:	0000ffff 	.word	0x0000ffff
    3c44:	0000ffff 	.word	0x0000ffff
    3c48:	0000ffff 	.word	0x0000ffff
    3c4c:	0000ffff 	.word	0x0000ffff
    3c50:	0000ffff 	.word	0x0000ffff
    3c54:	0000ffff 	.word	0x0000ffff
    3c58:	42000800 	.word	0x42000800
    3c5c:	42000c00 	.word	0x42000c00
    3c60:	42001000 	.word	0x42001000

00003c64 <sensor_analog_inputs>:
    3c64:	00080906                                ....

00003c68 <_tcc_intflag>:
    3c68:	00000001 00000002 00000004 00000008     ................
    3c78:	00001000 00002000 00004000 00008000     ..... ...@......
    3c88:	00010000 00020000 00040000 00080000     ................

00003c98 <tc_interrupt_vectors.12355>:
    3c98:	00000e0d                                ....

00003c9c <tc_interrupt_vectors.12355>:
    3c9c:	00000e0d 00002f9a 00002f96 00002f96     ...../.../.../..
    3cac:	00002ff8 00002ff8 00002fae 00002fa0     ./.../.../.../..
    3cbc:	00002fb4 00002fe6 00003080 00003060     ./.../...0..`0..
    3ccc:	00003060 000030ec 00003072 0000308e     `0...0..r0...0..
    3cdc:	00003064 0000309c 000030dc              d0...0...0..

00003ce8 <_init>:
    3ce8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3cea:	46c0      	nop			; (mov r8, r8)
    3cec:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3cee:	bc08      	pop	{r3}
    3cf0:	469e      	mov	lr, r3
    3cf2:	4770      	bx	lr

00003cf4 <__init_array_start>:
    3cf4:	000008b5 	.word	0x000008b5

00003cf8 <_fini>:
    3cf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3cfa:	46c0      	nop			; (mov r8, r8)
    3cfc:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3cfe:	bc08      	pop	{r3}
    3d00:	469e      	mov	lr, r3
    3d02:	4770      	bx	lr

00003d04 <__fini_array_start>:
    3d04:	0000088d 	.word	0x0000088d
